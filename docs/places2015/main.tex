\documentclass[a4paper]{article}
\usepackage{amsmath,amssymb,centernot,colortbl,mathwidth,scalerel,stmaryrd,url,xspace,mathrsfs,enumitem,bm}
\usepackage[table]{xcolor}
\addtolength{\jot}{-3px}

\usepackage{hyperref}
\hypersetup{colorlinks=true,citecolor=blue}

\usepackage[numbers,sort&compress,sectionbib,square]{natbib}
\renewcommand{\bibname}{References}

\usepackage{mathpartir}
\mprset{sep=1em}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

\input{preamble}
\usepackage{fullpage}
%\usepackage{mathptmx}
\usepackage{newtxtext}
\title{Asynchronous Semantics for Impatient GV \\ Or an \emph{even less patient} GV}

\date{\today}

\begin{document}
\maketitle

\begin{figure}[float]
\begin{syntax}
  \text{Session types} & S & ::= & \gvout{T}{S} \mid \gvin{T}{S} \mid \gvconst{end} \mid \channel{S} \\
%  \text{Buffer types} & B & ::= & \epsilon \mid T;B \\
  \text{Types} & T,U & ::= & S \mid \one \mid T \gvtimes U \mid \zero \mid T \gvplus U \mid T \lto U
  \\ % \mid {!T} \\
  \text{Terms} & L,M,N & ::= & x \mid K \app M \mid \lambda x.M \mid M\,N \\
  & & \mid & (M,N) \mid \gvlet{(x,y)}{M}{N} \\
  & & \mid & \mkwd{inl}\,M \mid \mkwd{inr}\,M \mid \gvcase{M}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N} \\
  & & \mid & () \mid \gvletunit{M}{N} \mid \gvconst{absurd} \app M \\
  %\text{Constants} & K & ::= & \gvconst{send} \mid \gvconst{receive} \mid \gvconst{fork} \mid \gvconst{wait} \mid \gvconst{link}\\
  \text{Constants} & K & ::= & \gvconst{send} \mid \gvconst{receive} \mid \gvconst{fork} \mid \gvconst{close} \mid \gvconst{link}\\
\end{syntax}
\caption{Syntax of GV Terms and Types}\label{fig:gv-syntax}
\end{figure}

\begin{figure}[float]
\begin{syntax}
  \text{Values} & V,W & ::= & x \mid \lambda^\sigma x.M \\
  & & \mid & () \mid (V,W) \mid \mkwd{inl}\,V \mid \mkwd{inr}\,V  \\
  \text{Substitutions} & \sigma & ::= & \{ \bind {x_1} {V_1}, \dots, \bind {x_n} {V_n} \} \\
  & & & \qquad\text{ where the $x_i$ are pairwise distinct} \\
  \text{Evaluation contexts} & \Ex & ::= &  [~] \mid \Ex\,M \mid V\,\Ex \mid K \app V \mid \gvletunit{\Ex}{M} \\
  & & \mid & (\Ex,M) \mid (V,\Ex) \mid \gvlet{(x,y)}{\Ex}{M} \\
  & & \mid & \mkwd{inl}\,\Ex \mid \mkwd{inr}\,\Ex \mid \gvcase{\Ex}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N'} \\
  & \Fx & ::= & \phi \Ex \\
  \text{Configurations} & C,D & ::= & \phi M \mid C \parallel C' \mid (\nu x y) C \mid \gvendpoint{x}{\gvbuf{}{V_1}{}}{y}{\gvbuf{}{V_2}{}} \\
  \text{Configuration contexts} & \Cx & ::= & [~] \mid \Cx \parallel P \mid (\nu x y)\Cx \\
  \text{Flags} & \phi & ::= & \wcirc \mid \bcirc
\end{syntax}
\caption{Syntax of Values, Configurations, and Contexts}\label{fig:gv-eval-syntax}
\end{figure}

\begin{figure}[float]
\vspace{1ex}
~Term reduction
\begin{align*}
%%  (\lambda^\sigma x.M)\,V &\teval M(\{\bind x V\} \uplus \sigma) \\
  (\lambda x.M)\app V &\teval M \{\bind x V\} \\
  \gvletunit{()}{M} &\teval M \\
  \gvlet{(x,y)}{(V,V')}{M} &\teval M \{ \bind x V, \bind y {V'} \} \\
  \gvcase{(\mkwd{inl}\,V)}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N'} &\teval N \{ \bind x V \} \\
  E[M] &\teval E[M'] \qquad \text{if $M \teval M'$}
\end{align*}
~Configuration equivalence
\begin{mathpar}
\Fx[\mathsf{link}\,(x,y)] \equiv \Fx[\mathsf{link}\,(y,x)]

C \parallel D \equiv D \parallel C

C \parallel (D \parallel E) \equiv (C \parallel D) \parallel E

% scope extrusion with endpoint name restriction...
%C \parallel (\nu x y)D \equiv (\nu x y)(C \parallel D) \text{ if $x, y \not\in \fv(C)$}
C \parallel (\nu x)D \equiv (\nu x)(C \parallel D) \text{ if $x \not\in \fv(C)$}

\Cx[C] \equiv \Cx[D] \text{ if $C \equiv D$}

% Channel symmetry
\gvendpoint{x}{\gvbuf{}{V_1}{}}{y}{\gvbuf{}{V_2}{}} \equiv \gvendpoint{y}{\gvbuf{}{V_2}{}}{x}{\gvbuf{}{V_1}{}}

\end{mathpar}
~Configuration reduction
\begin{mathpar}
\inferrule
  [Send]
  { }
  {\Fx[\gvconst{send} \app (V,x)] \parallel \gvendpoint{x}{\gvbuf{}{V_1}{}}{y}{\gvbuf{}{V_2}{}}
    \ceval \Fx[x] \parallel
    \gvendpoint{x}{\gvbuf{}{V_1}{}}{y}{\gvbuf{V}{V_2}{}} }
    %\parallel \gvendpoint{y}{\gvbuf{V}{V}{}}{x}{\gvbuf{}{V\prime}{}}}

\inferrule
  [Receive]
  { }
  {\Fx[\gvconst{receive(x)}] \parallel \gvendpoint{x}{\gvbuf{}{V}{V}}{y}{V'} \ceval
    \Fx[(V, x)] \parallel \gvendpoint{x}{\gvbuf{}{V_1}{}}{y}{V_2} }

\inferrule
   [Lift]
   {C \ceval C'}
   {\Cx[C] \ceval \Cx[C']}

% \inferrule
%   [Fork]
%   {\text{$x, y$ are fresh endpoint names}}
%   {\Fx[\gvconst{fork} \app (\clos{\sigma}{z}{M})] \ceval
%     (\nu x y)( % \Fx[a] \parallel
%     \gvendpoint{x}{\epsilon}{y}{\epsilon}
%     \parallel M(\{\bind z y\} \uplus \sigma))}
\inferrule
  [Fork]
  {\text{$x,y$ fresh}}
  {\Fx[\gvconst{fork} \app \lambda z.M] \ceval
    (\nu x y)(\Fx[x] \parallel \gvendpoint{x}{\epsilon}{y}{\epsilon} \parallel M\{\bind z y\})}

  %% [Fork]
  %% {\text{$x$ fresh}}
  %% {\Fx[\gvconst{fork} \app V] \ceval (\nu x)(\Fx[x] \parallel (V\,x))}

%\inferrule
% [Wait]
% { }
% {(\nu x y)(\Fx[\gvconst{wait} \app x] \parallel
% \gvendpoint{x}{\epsilon}{y}{\epsilon})
%   \ceval
%      \Fx[()]}
%
\inferrule
   [Link]
   %{x \in \fv(M)}
   { }
   {
    \Fx[\gvconst{link} \app (x, y)] \parallel
    \gvendpoint{x'}{\gvbuf{}{U'}{}}{x}{\gvbuf{}{U}{}} \parallel
    \gvendpoint{y}{\gvbuf{}{V}{}}{y'}{\gvbuf{}{V'}{}}
    \ceval
    \Fx[()] \parallel \gvendpoint{x'}{\overrightarrow{U'} \mdoubleplus \overrightarrow{V}}
    {y'}{\overrightarrow{V} \mdoubleplus \overrightarrow{U}}
   }
   %{(\nu x) (\Fx[\gvconst{link} \app (x, y)] \parallel \Fx'[M]) \ceval
   %(\nu x)(\Fx[x] \parallel \Fx'[\gvletunit{\gvconst{wait} \app x}{M\{y/x\}}])}

\inferrule
   [LiftV]
   {M \teval M'}
   {\Cx[M] \ceval \Cx[M']}

%% [Lift3] would allow us to slightly simplify [Send] and [Link]
%%
%% \inferrule
%%    [Lift3]
%%    {\Cx[M] \ceval \Cx[M']}
%%    {\Cx[\Fx[M]] \ceval \Cx[\Fx[M']]}
\end{mathpar}
\caption{Reduction Rules and Equivalences for Terms and Configurations}\label{fig:gv-reduction}
\end{figure}

\begin{figure}
\vspace{1ex}
~Buffers and buffer types
\begin{mathpar}
\inferrule
  { }
  {S \compat \varepsilon}

\inferrule
  {S \compat \vec T}
  {!U.S \compat \vec T}

\inferrule
  {S \compat \vec T}
  {?T.S \compat T \vec T}

\inferrule
  { }
  {\vdash \varepsilon : \varepsilon}

\inferrule
  {\Gamma \vdash V : T \\
   \Gamma' \vdash \vec T : \vec T}
  {\Gamma,\Gamma' \vdash V \vec V : T \vec T}
\end{mathpar}
~Configuration typing
\begin{mathpar}
\inferrule
  { \Gamma \vdash M: T \\
    T \not= \outterm }
  {\Gamma \vdash^\bcirc \distinguish M}

\inferrule
  {\Gamma \vdash M: \outterm}
  {\Gamma \vdash^\wcirc \thread M}

\inferrule
  {\Gamma \vdash \vec V: \vec T \\
   \Gamma' \vdash \vec W: \vec U}
  {\Gamma,\Gamma',x:\vec T,y:\vec U \vdash \gvendpoint{x}{\vec V}{y}{\vec W}}
\\
\inferrule
  {\Gamma, x:\channel{S} \vdash^\phi C}
  {\Gamma \vdash^\phi (\nu x) C}

\inferrule
  {\Gamma,x:S \vdash^{\phi} C \\
   \Gamma',x:B \vdash^{\phi'} C' \\
   S \compat B}
  {\Gamma,\Gamma',x:\channel{S} \vdash^{\phi + \phi'} C \parallel C'}

\inferrule
  {\Gamma \vdash^{\phi} C \\
   \Gamma' \vdash^{\phi'} C'}
  {\Gamma,\Gamma' \vdash^{\phi + \phi'} C \parallel C'}
\end{mathpar}
~Combination of flags
\begin{mathpar}
  \wcirc + \wcirc = \wcirc

  \wcirc + \bcirc = \bcirc

  \bcirc + \wcirc = \bcirc

  \bcirc + \bcirc \text{ undefined}
\end{mathpar}
~Reduction of configuration typing environments
\begin{mathpar}
\inferrule
  { }
  {\channel{(\gvout T S)} \ceval \channel S}

\inferrule
  { }
  {\channel{(\gvin T S)} \ceval \channel S}

\inferrule
  {T \ceval T'}
  {\Gamma,x:T \ceval \Gamma,x:T'}
\end{mathpar}
\caption{Configuration typing}
\end{figure}

\end{document}