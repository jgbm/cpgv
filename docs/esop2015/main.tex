% -*- fill-column: 100 -*-

\documentclass[orivec,envcountsame]{llncs}

\usepackage{amsmath,amssymb,centernot,hyperref,mathwidth,stmaryrd,url,xspace}
\usepackage[table]{xcolor}
\usepackage{colortbl}
\addtolength{\jot}{-3px}

\usepackage{mathpartir}
\mprset{sep=1em}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

\input{preamble.tex}

\title{Joke or Something}
\author{J. Garrett Morris \and Sam Lindley \and Philip Wadler}
\institute{The University of Edinburgh \\
           \email{\{Garrett.Morris,Sam.Lindley,Philip.Wadler\}@ed.ac.uk} \vspace{-5mm}}

\begin{document}

\maketitle

\begin{abstract}

\end{abstract}

\section{I'm Pickin' Up Good Vibrations}

I'm intentionally ignoring replication for the time being.  I'm intentionally ignoring CP
polymorphism forever.

\subsection{Syntax}
\newcommand{\one}{\mathbf{1}}
\newcommand{\zero}{\mathbf{0}}
\begin{syntax}
  \text{Session types} & S & ::= & \gvout{T}{S} \mid \gvin{T}{S} \mid % \oplus \{ \overline{l:S} \} \mid \with \{ \overline{l:S} \} \mid
                                   \interm \mid \outterm \mid \channel{S} \\
  \text{Types} & T,U & ::= & S \mid T \times U \mid \one \mid T + U \mid \zero \mid T \lto U \\ % \mid {!T} \\
  \text{Terms} & M,N & ::= & x \mid K \mid \lambda x.M \mid M\,N \\
  & & \mid & (M,N) \mid \gvlet{(x,y)}{M}{N} \\
  & & \mid & \mkwd{inl}\,M \mid \mkwd{inr}\,M \mid \gvcase{M}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N} \\
  & & \mid & () \mid \gvletunit{M}{N} \mid \gvconst{absurd} \app M \\
  \text{Constants} & K & ::= & \gvconst{send} \mid \gvconst{receive} \mid \gvconst{fork} \mid \gvconst{wait} \mid \gvconst{link}\\
\end{syntax}

\begin{mathpar}
\gvdual{\gvout{T}{S}} = \gvin{T}{\gvdual S}

\gvdual{\gvin{T}{S}} = \gvout{T}{\gvdual S}

\gvdual{\interm} = \outterm

\gvdual{\outterm} = \interm
\end{mathpar}

\subsection{Typing}

\begin{mathpar}
\inferrule
  {T \not= \channel{S}}
  {\{x:T\} \vdash x:T}

\inferrule
  {\Gamma,x:T \vdash M:U}
  {\Gamma \vdash \lambda x:T.M : T \lto U}

\inferrule
  {\Gamma \vdash M: T \lto U \\
   \Delta \vdash N: T}
  {\Gamma,\Delta \vdash M\,N: U}

\inferrule
  {\Gamma \vdash M: T \\
   \Delta \vdash N: U}
  {\Gamma,\Delta \vdash (M,N): T \times U}

\inferrule
  {\Gamma \vdash M: T \times T' \\
   \Delta,x:T,y:T' \vdash N: U}
  {\Gamma,\Delta \vdash \gvlet{(x,y)}{M}{N} : U}

\inferrule
  {\Gamma \vdash M: T}
  {\Gamma \vdash \mkwd{inl}\,M: T+U}

\inferrule
  {\Gamma \vdash M: T+T' \\
   \Delta,x:T \vdash N: U \\
   \Delta,x:T' \vdash N': U}
  {\Gamma,\Delta \vdash \gvcase{M}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N'} : U}

\inferrule
  { }
  {\vdash (): \one}

\inferrule
  {\Gamma \vdash M: \one \\
   \Delta \vdash N: T}
  {\Gamma,\Delta \vdash \gvletunit{M}{N}: T}

\inferrule
  {\Gamma \vdash M: \zero}
  {\Gamma, \Gamma' \vdash \gvconst{absurd} \app M : T}

\gvconst{send} : T \times \gvout{T}{S} \lto S

\gvconst{receive} : \gvin{T}{S} \lto T \times S

\gvconst{fork} : (S \lto \outterm) \lto \gvdual{S}

\gvconst{wait} : \interm \lto \one

\gvconst{link} : S \times \gvdual{S} \lto \outterm
\end{mathpar}

\subsection{Evaluation}

\newcommand{\distinguish}[1]{\langle #1 \rangle}

\begin{syntax}
  \text{Values} & V & ::= & x \mid K \mid \lambda x.M \\ % \mid K\,V \\
  & & \mid & () \mid (V,V') \mid \mkwd{inl}\,V \mid \mkwd{inr}\,V  \\
  \text{Expression contexts} & E & ::= &  [] \mid E\,M \mid V\,E \mid \gvletunit{E}{M} \\
  & & \mid & (E,M) \mid (V,E) \mid \gvlet{(x,y)}{E}{M} \\
  & & \mid & \mkwd{inl}\,E \mid \mkwd{inr}\,E \mid \gvcase{E}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N'} \\
  \text{Configurations} & P & ::= & M \mid \distinguish M \mid P \parallel P' \mid (\nu x) P \\
  \text{Configuration contexts} & C & ::= & E \mid \distinguish E \mid C \parallel P \mid (\nu x)C \\
  \text{Flags} & \phi & ::= & \circ \mid \bullet
\end{syntax}
We define combination of flags $\phi + \phi'$ by
\begin{mathpar}
  \circ + \circ = \circ

  \circ + \bullet = \bullet

  \bullet + \circ = \bullet
\end{mathpar}
and leave $\bullet + \bullet$ undefined.  Configuration typing is given by
\begin{mathpar}
\inferrule
  {\Gamma \vdash M: T}
  {\Gamma \vdash^\bullet \distinguish M}

\inferrule
  {\Gamma \vdash M: \outterm}
  {\Gamma \vdash^\circ M}

\inferrule
  {\Gamma, x:\channel{S} \vdash^\phi P}
  {\Gamma \vdash^\phi (\nu x) P}

\inferrule
  {\Gamma,x:S \vdash^{\phi} P \\
   \Gamma',x:\gvdual{S} \vdash^{\phi'} P'}
  {\Gamma,\Gamma',x:\channel{S} \vdash^{\phi + \phi'} P \parallel P'}
\end{mathpar}
We will write $\Gamma \vdash P$ for $\Gamma \vdash^\bullet P$.  Note that while we can write the
classic deadlocked configuration
\[
  (\nu x)(\nu y)(\distinguish{\gvlet{(z,x)}{\gvconst{receive} \app x}{\gvconst{send} \app (z,y)}} \parallel
                 \gvlet{(z,y)}{\gvconst{receive} \app y}{\gvconst {send} \app (z,x)})
\]
it is not well typed: we can only split one of $x,y$ at the $\parallel$.  Term reductions:
\begin{align*}
  (\lambda x:T. M)\,V &\teval M\{V/x\} \\
  \gvletunit{()}{M} &\teval M \\
  \gvlet{(x,y)}{(V,V')}{M} &\teval M\{V/x,V'/y\} \\
  \gvcase{(\mkwd{inl}\,V)}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N'} &\teval N\{V/x\} \\
  E[M] &\teval E[M'] \qquad \text{if $M \teval M'$}
\end{align*}
Configuration (context) equivalence:
\begin{mathpar}
C[\mathsf{link}\,(x,y)] \equiv C[\mathsf{link}\,(y,x)]

C_0 \parallel C_1 \equiv C_1 \parallel C_0

C_0 \parallel (C_1 \parallel C_2) \equiv (C_0 \parallel C_1) \parallel C_2

C_0 \parallel (\nu x)C_1 \equiv (\nu x)(C_0 \parallel C_1) \text{ if $x \not\in \fv(C_0)$}
\end{mathpar}

Awkwardly enough, the equivalence rules do not preserve typing.  For example, supposing that $x \in
\fv(P), y \in \fv(Q), \text{ and } x,y \in \fv(R)$, we have $\vdash (\nu x
y)(P \mid (Q \mid R))$ but not $\nvdash (\nu x y)((P \mid Q) \mid R)$.  We have a simple reduction
rule for configuration types, given by
\begin{mathpar}
\inferrule
%  [T-Output]
  { }
  {\channel{(\gvout T S)} \ceval \channel S}

\inferrule
%  [T-Input]
  { }
  {\channel{(\gvin T S)} \ceval \channel S}

\inferrule
%  [T-Context]
  {T \ceval T'}
  {\Gamma,x:T \ceval \Gamma,x:T'}
\end{mathpar}
Configuration reduction is given by
\begin{mathpar}
\inferrule
  [Send]
  { }
  {C[\gvconst{send} \app (V,x)] \parallel C'[\gvconst{receive} \app x] \ceval C[x] \parallel C'[(V,x)]}

\inferrule
  [Fork]
  {\text{$x$ fresh}}
  {C[\gvconst{fork} \app V] \ceval (\nu x)(C[x] \parallel (V\,x))}

\inferrule
  [Wait]
  { }
  {(\nu x)(C[\gvconst{wait} \app x] \parallel x) \ceval C[()]}

\inferrule
   [Link]
   {x \in \fv(M)}
   {(\nu x) (C[\gvconst{link} \app (x, y)] \parallel C'[M]) \ceval (\nu x)(C[x] \parallel C'[\gvletunit{\gvconst{wait} \app x}{M\{y/x\}}])}

\inferrule
   [Lift]
   {P \ceval P'}
   {C[P] \ceval C[P']}

\inferrule
   [Lift2]
   {M \teval M'}
   {C[M] \ceval C[M']}
%%
%% \inferrule
%%    [DLink]
%%    {x \in \fv(M)}
%%    {(\nu x) (C[\mathsf{link}\,(x, y)] \parallel \distinguish M) \ceval (\nu x)(C[x] \parallel \distinguish{\gvletunit{\mathsf{wait}\,x}{M\{y/x\}}})}
%%
%%
%% \inferrule
%%   {C_0 \equiv C_0' \\
%%    C_0' \ceval C_1' \\
%%    C_1' \equiv C_1}
%%   {C_0 \ceval C_1}
\end{mathpar}
Some things that might be useful.
\begin{lemma}\label{thm:term-preservation}
  If $\Gamma \vdash M: T$ and $M \teval M'$, then $\Gamma \vdash M': T$
\end{lemma}

\noindent
The proof is standard.

\begin{theorem}\label{thm:preservation}
  If $\Gamma \vdash P$ and $P \ceval P'$ then there is some $\Gamma'$ such that either $\Gamma
  \ceval \Gamma'$ or $\Gamma = \Gamma'$ and $\Gamma' \vdash P'$.
\end{theorem}

\begin{proof}
  By induction on the derivation of $P \ceval P'$.
  \begin{itemize}
  \item Cases \textsc{Thread} and \textsc{DThread} follow from \lemref{term-preservation}, with
    $\Gamma = \Gamma'$.
  \item Cases \textsc{New} and \textsc{Par} are immediate by the induction hypothesis.
  \item In case \textsc{Send}, from the assumption $\Gamma \vdash C[\mkwd{send}\,(V,x)] \parallel
    C'[\gvconst{receive} \app x]$, we can assume that $\Gamma$ partitions as
    $\Gamma_1,\Gamma_2,x:\channel{S}$ such that $S = \gvout{T}{S'}$, $V$ has type $T$, and
    $\Gamma_1,x:\gvout{T}{S'} \vdash C[\gvconst{send} \app (V,x)]$,
    $\Gamma_2,x:\gvin{T}{\gvdual{S'}} \vdash C'[\gvconst{receive} \app x]$.  As $\gvconst{send} : T
    \times \gvout{T}{S'} \lto S'$ and $\Gamma_1,x:\gvout{T}{S'} \vdash C[\gvconst{send} \app
    (V,x)]$, we can conclude that $\Gamma_1,x:S' \vdash C[x]$.  By a similar argument, we conclude
    that $\Gamma_2,x:\gvdual{S'} \vdash C'[(V,x)]$. Finally, as $\channel{(\gvout{T}{S})} \ceval
    \channel{S}$, $\Gamma_1,\Gamma_2,x:\channel{(\gvout T S)} \ceval
    \Gamma_1,\Gamma_2,x:\channel{S}$, and we can recompose the resulting processes concluding that
    $\Gamma_1,\Gamma_2,x:\channel{S} \vdash C[x] \parallel C'[(V,x)]$.
  \item In case \textsc{Fork}, from the assumption $\Gamma \vdash C[\gvconst{fork} \app V]$, we can
    conlude that $\Gamma$ splits into $\Gamma_1,\Gamma_2$ and there is some $S$ such that
    $\Gamma_1,x:S \vdash C[x]$ and $\Gamma_2,x:\gvdual{S} \vdash V \app x$.  Thus we have that
    $\Gamma,x:S \vdash C[x] \parallel V \app x$ and $\Gamma \vdash (\nu x)(C[x] \parallel
    V \app x)$.
  \item In case \textsc{Wait}, from the assumption $\Gamma \vdash (\nu x)(C[\gvconst{wait} \app
    x] \parallel x)$, we can conclude that $\Gamma,x:\interm \vdash C[\gvconst{wait} \app x]$ and
    thus, from the typing of \gvconst{wait}, that $\Gamma \vdash C[()]$.
  \item In case \textsc{Link}, from the assumptions $\Gamma \vdash (\nu x) (C[\gvconst{link} \app
    (x, y)] \parallel C'[M]), x \in \fv(M)$, we can conclude that $\Gamma$ partitions as
    $\Gamma_1,\Gamma_2,y:S$ such that $\Gamma_1,y:S,x:\gvdual{S} \vdash C[\gvconst{link} \app (x,
    y)]$ and $\Gamma_2,x:S \vdash C'[M]$.  (Note that the free variable assumption on the reduction
    rule for \gvconst{fork} allows us to assume that neither $C$ or $C'$ binds $x$ or $y$.)  From
    the type of \gvconst{link}, we have that $\Gamma,x:\outterm \vdash C[x]$; similarly, from $x \in
    \fv(M)$, we can conclude that $\Gamma_2,y:S \vdash C'[M\{y/x\}]$.  Finally, from the typing rule
    for \gvconst{wait}, we have that $\Gamma_2,x:\interm,y:S \vdash C'[\gvletunit{\gvconst{wait}
      \app x}{M\{y/x\}}]$, and that $\Gamma \vdash (\nu x)(C[x] \parallel
    C'[\gvletunit{\gvconst{wait} \app x}{M\{y/x\}}])$ \qed
  \end{itemize}
\end{proof}

\begin{theorem}\label{thm:preservation-equiv}
  If $\Gamma \vdash P$, $P \equiv P'$ and $P' \ceval Q'$, then there are some $\Gamma',Q$ such that
  either $\Gamma = \Gamma'$ or $\Gamma \ceval \Gamma'$, $Q' \equiv Q$, and $\Gamma' \vdash Q$.
\end{theorem}

\begin{proof}
  We begin by observing that if $P \ceval Q$, then there is some well-typed $P'$ such that $P =
  C[P']$, $P' \ceval Q'$, and $Q = C[Q']$.  The desired result is then obtained by structural
  induction on $P$, examining the possible equivalences in each case. \qed
\end{proof}

Define $\ceval^\star$ as the reflexive, transitive closure of $\equiv\ceval\equiv$.

\subsection{Deadlock and Its Absence}

Blocked terms:
\newcommand{\blockedp}{\mathsf{blocked}}
\newcommand{\depp}{\mathsf{depends}}
\[\begin{array}{rcl}
  \blockedp(x,M) &\defiff& \exists N. \; M = E[\gvconst{send} \app (x,N)] \\
  && \quad \lor \, M = E[\gvconst{receive} \app x] \\
  && \quad \lor \, M = E[\gvconst{wait} \app x] \\
  \depp(x,y,E[M]) &\defiff& \blockedp(x,M) \land y \in \fv(E) \\
  \depp(x,y,P) &\defiff& (P \equiv C[M] \land \depp(x,y,M)) \lor \, (P \equiv C[Q \parallel Q'] \\
  && \quad \land \, (\exists z. \depp(x,z,Q) \land \depp(z,y,Q')))
\end{array}\]
Finally, we have a natural definition of deadlock:
\newcommand{\deadlockp}{\ensuremath{\mathsf{deadlocked}}}
\[
\deadlockp(P) \defiff P \equiv C[Q \parallel Q'] \land \exists x,y. \depp(x,y,Q) \land \depp(y,x,Q').
\]
Because this definition depends on blocked processes (that is, those waiting to read or write) it
avoids the problems with return values (since a process returning a channel is not blocked on it, it
cannot be part of a deadlocked pair).  We say a process $P$ is deadlock-free if for all $Q$ such
that $P \ceval^\star Q$, $\lnot\deadlockp(Q)$.  Observe that if $P \equiv Q$, then $\deadlockp(P)
\iff \deadlockp(Q)$.

\begin{lemma}\label{thm:procs-share-one-channel}
  If $\Gamma \vdash P$, and $P = C[Q \parallel Q']$, then there is some variable $x$ such that
  $\fv(Q) \cap \fv(Q') = \{ x \}$.
\end{lemma}

\begin{proof}
  By structural induction on the derivation of $\Gamma \vdash P$; the only interesting case is for
  parallel composition, where the desired result is assured by the partitioning of the environment.
\end{proof}

I think we can now show fairly directly that

\begin{lemma}\label{thm:typed-configs-df}
  If $\Gamma \vdash P$ then $\lnot \deadlockp(P)$.
\end{lemma}

\begin{proof}
  By contradiction: suppose $\deadlockp(P)$.  Then we know there must be some variables
  $x_1,\dots,x_n$ and processes $M_1,\dots,M_n$ in $P$ such that
  \[
    \blockedp(x_1,x_2,M_1) \land \blockedp(x_2,x_3,M_2) \land \cdots \land \blockedp(x_n,x_1,M_n).
  \]
  But now there is no possible $\Gamma$ such that any $\Gamma \vdash P'$ for any process $P'$
  containing the $M_i$---such a $P'$ would violate \lemref{procs-share-one-channel}.  \qed
\end{proof}

Finally, the following is trivial.

\begin{theorem}\label{thm:typed-terms-df}
  If $\Gamma \vdash M: T$, then $\distinguish M$ is deadlock-free.
\end{theorem}

\begin{proof}
  If $\Gamma \vdash M: T$, then $\Gamma \vdash \distinguish{M}$, and so
  $\lnot\deadlockp(\distinguish M)$ and, for any $Q$ such that $\distinguish M \ceval^\star Q$, we
  know that there is a well-typed $Q' \equiv Q$, and so $\lnot\deadlockp(Q)$. \qed
\end{proof}

\section{CP Translation and Equivalence}

\section{GV with Mix}

We define a language GVX, which, depending on your perspective, either extends GV with mix or
combines the types of closed sessions.  The syntax is largely as in GV; the meaningful changes are
the elimination of $\interm$ and $\outterm$ in favor of $\gvend$, and the use of \gvconst{close} instead
of \gvconst{wait}.
\begin{syntax}
  \text{Session types} & S & ::= & \gvout{T}{S} \mid \gvin{T}{S} \mid \gvend \mid \channel{S} \\
  \text{Constants} & K & ::= & \gvconst{send} \mid \gvconst{receive} \mid \gvconst{fork} \mid \gvconst{close} \mid \gvconst{link}\\
\end{syntax}
The remaining parts of the grammar are unchanged from GV.  The definition of duality is updated to
reflect that $\gvend$ is self-dual:
\[
  \gvdual \gvend = \gvend
\]
We provide new typing rules for some of the constants
\begin{mathpar}
\gvconst{fork} : (S \lto \one) \lto \gvdual S

\gvconst{close} : \gvend \lto \one

\gvconst{link} : S \times \gvdual S \lto \one
\end{mathpar}
but otherwise the type system is unchanged from that of GV.  We require an extension of the type
system for configurations, however:
\begin{mathpar}
\inferrule
  {\Gamma \vdash M: T}
  {\Gamma \vdash^\bullet \distinguish M}

\inferrule
  {\Gamma \vdash M: \one}
  {\Gamma \vdash^\circ M}

\inferrule
  {\Gamma, x: \channel S \vdash^\phi P}
  {\Gamma \vdash^\phi (\nu x)P}

\inferrule
  {\Gamma, x: S \vdash^\phi P \\
   \Gamma', x: \gvdual S \vdash^{\phi'} P'}
  {\Gamma,\Gamma',x:\channel S \vdash^{\phi + \phi'} P \parallel P'}

\inferrule
  {\Gamma \vdash^\phi P \\
   \Gamma' \vdash^{\phi'} P'}
  {\Gamma,\Gamma' \vdash^{\phi + \phi'} P \parallel P'}
\end{mathpar}
Perhaps the latter two rules can be combined by defining a suitable operation on environments;
however, it seems simpler now to just provide two typing rules.  Rules \textsc{Send, Fork, Lift} and
\textsc{Lift2} apply to GVX unchanged; the remaining reduction rules are
\begin{mathpar}
\inferrule
  { }
  {C[\gvconst{close} \app x] \parallel C'[\gvconst{close} \app x] \ceval C[()] \parallel C'[()]}

\inferrule
  {x \in \fv(P)}
  {C[\gvconst{link} \app (x,y)] \parallel P \ceval C[()] \parallel P \{y/x\}}
\end{mathpar}
The equivalences are similarly extended by
\begin{mathpar}
(\nu x)P \equiv P \text{ if $x \not\in \fv(P)$}

P \parallel () \equiv P
\end{mathpar}
We have a slightly different result about channels shared between processes, to account for the
multiple forms of composition:
\begin{lemma}
  If $\Gamma \vdash P$ and $P = C[Q \parallel Q']$, then $\fv(Q) \cap \fv(Q')$ is either empty or
  the singleton set $\{x\}$ for some variable $x$.
\end{lemma}
The proof is again by induction on the derivation of $\Gamma \vdash P$.  However, note that this has
no consequence for the proof of deadlock freedom (which depended on their being two channels shared
among processes).  Thus we can conclude that
\begin{theorem}
  If $\Gamma \vdash M: T$ then $\distinguish M$ is deadlock free.
\end{theorem}



\section{Direct GV semantics}

\newcommand{\apar}[1]{\mathbin{{[}\:\!\!\rangle}_{\!{#1}}\!}
\newcommand{\con}[3]{{#1} \apar{#2} {#3}}

\[
\mkwd{connect} : (S \lto \outterm, \gvdual{S} \lto T) \lto T
\]

Syntactic sugar:
\begin{align*}
\con{M}{x}{N} &\defiff \mkwd{connect}(\lambda x.M, \lambda x.N) \\
\con{L}{x}{\con{M}{y}{N}} &\defiff \con{L}{x}{(\con{M}{y}{N})} \\
\end{align*}

Equivalences ($\equiv$ is the transitive, reflexive, symmetric closure of the following rules):
\begin{align*}
\mkwd{link}\,(x,y) &\equiv \mkwd{link}\,(y,x) \\
\con{L}{x}{\con{M}{y}{N}} &\equiv \con{M}{y}{\con{L}{x}{N}} \\
\con{L}{x}{\con{M}{y}{N}} &\equiv \con{(\con{L}{x}{M})}{y}{N} \\
%\con{L}{x}{\con{M}{y}{N}} &\equiv \con{(\con{M}{x}{L})}{y}{N} \\
\end{align*}

Interesting reductions
\begin{align*}
\con{E[\mkwd{send}\,(V,x)]}{x}{E'[\mkwd{receive}\,x]}
  &\rto \con{E[x]}{x}{E'[(V,x)]} \\
\con{E[\mkwd{receive}\,x]}{x}{E'[\mkwd{send}\,(V,x)]}
  &\rto \con{E[(V,x)]}{x}{E'[x]} \\[1ex]
\con{x}{x}{E[\mkwd{wait}\,x]}
  &\rto E[()] \\
\con{E[\mkwd{wait}\,x]}{x}{x}
  &\rto E[()] \\[1ex]
\con{E[\mkwd{link}\,(x,y)]}{x}{M}
  &\rto \con{E[x]}{x}{(\mkwd{wait}\,x; M[y/x])} \\
\con{M}{x}{E[\mkwd{link}\,(x,y)]}
  &\rto \con{(\mkwd{wait}\,x; M[y/x])}{x}{E[x]} \\[1ex]
\mkwd{link}\,(x,\mkwd{link}\,(y,z))
  &\rto \mkwd{wait}\,x; \mkwd{link}\,(y,z) \\
E[\con{M}{x}{N}]
  &\rto \con{M}{x}{E[N]} \\
\end{align*}

An alternative is to remove the final commuting conversion rule and augment the notion of value to
include a suitable representation of a collection of blocked communicating processes.

Preservation
\begin{theorem}
If $\Gamma \vdash M : T$ and $M \rto N$ then $\Gamma \vdash N : T$.
\end{theorem}
%
\begin{proof}
By induction on the structure of the derivation of $\Gamma \vdash M : T$ using a standard
substitution lemma for the case of $\beta$-reduction at function types.
\end{proof}

Progress
\begin{theorem}
\label{th:free-progress}
If $\Gamma$ is a session environment (all variables in $\Gamma$ have session type) such that $\Gamma
\vdash M : T$ then one of the following holds:
\begin{enumerate}
\item $M$ is a value; or
\item there exists $N = \blockedp'(y_1, M_1) \apar{x_1} \dots \apar{x_{n}} \blockedp'(y_{n}, M_{n})$
  such that $M \equiv N$ and $\Gamma \vdash N : T$; or
\item there exists $N$ such that $M \rto N$.
\end{enumerate}
\end{theorem}
%
\begin{proof}
By induction on the structure of the derivation of $\Gamma \vdash M : T$.
\end{proof}
% In the second case each $y_i$ must be equal to either $x_i$ or some $x$ in $\Gamma$.

\begin{theorem}
If $\vdash M : T$ then one of the following holds:
\begin{enumerate}
\item $M$ is a value; or
\item there exists $N = \blockedp(x_1, M_1) \apar{x_1} \dots \apar{x_{n-1}} \blockedp(x_{n-1},
  M_{n-1}) \apar{x_n} V$ such that $M \equiv N$ and $\Gamma \vdash N : T$; or
\item there exists $N$ such that $M \rto N$.
\end{enumerate}
\end{theorem}
%
\begin{proof}
By induction on the structure of the derivation of $\vdash M : T$ using
Theorem~\ref{th:free-progress}.
\end{proof}

$\blockedp(x, M)$ means $M$ is blocked on a send or receive involving $x$.

$\blockedp'(x, M)$ means either $M = x$ or $M$ is blocked on a send, receive, link, or wait
involving $x$.

Correspondence between reduction in CP and reduction in GV. Do the following theorems actually hold,
or is the correspondence more subtle? (I'm pretty certain they don't.)

\begin{theorem}
If $P \vdash \Gamma$ and $P \rto Q$ then $\togv{P} \rto \togv{Q}$.
\end{theorem}

\begin{theorem}
If $M \rto N$ then $\tocp{M}z \rto \tocp{N}z$.
\end{theorem}

\end{document}
