% -*- fill-column: 100 -*-

\documentclass[orivec,envcountsame]{llncs}

\usepackage{amsmath,amssymb,centernot,hyperref,mathwidth,stmaryrd,url,xspace}
\usepackage[table]{xcolor}
\usepackage{colortbl}
\addtolength{\jot}{-3px}

\usepackage{mathpartir}
\mprset{sep=1em}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

\input{preamble.tex}

\title{Joke or Something}
\author{J. Garrett Morris \and Sam Lindley \and Philip Wadler}
\institute{The University of Edinburgh \\
           \email{\{Garrett.Morris,Sam.Lindley,Philip.Wadler\}@ed.ac.uk} \vspace{-5mm}}

\begin{document}

\maketitle

\begin{abstract}

\end{abstract}

\section{Introduction}\label{sec:intro}

\section{GV by Example}\label{sec:examples}

\begin{itemize}
\item Bookstore example (with delegation).  On second thought, I'm not sure the example as presented
  in the exceptions paper is quite the one I wanted---there's no reason for the bank and customer to
  interact.  On the other hand, perhaps that doesn't matter---or we could modify it slightly so that
  the bank either challenges the customer as part of the transaction (Verified By Visa).
\item Explain encoding of select and choice into send and receive with sums.
\end{itemize}

\section{I'm Pickin' Up Good Vibrations}

I'm intentionally ignoring replication for the time being.  I'm intentionally ignoring CP
polymorphism forever.

\subsection{Syntax}
\newcommand{\one}{\mathbf{1}}
\newcommand{\zero}{\mathbf{0}}
\begin{syntax}
  \text{Session types} & S & ::= & \gvout{T}{S} \mid \gvin{T}{S} \mid % \oplus \{ \overline{l:S} \} \mid \with \{ \overline{l:S} \} \mid
                                   \interm \mid \outterm \mid \channel{S} \\
  \text{Types} & T,U & ::= & S \mid T \times U \mid \one \mid T + U \mid \zero \mid T \lto U \\ % \mid {!T} \\
  \text{Terms} & M,N & ::= & x \mid K \mid \lambda x.M \mid M\,N \\
  & & \mid & (M,N) \mid \gvlet{(x,y)}{M}{N} \\
  & & \mid & \mkwd{inl}\,M \mid \mkwd{inr}\,M \mid \gvcase{M}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N} \\
  & & \mid & () \mid \gvletunit{M}{N} \mid \gvconst{absurd} \app M \\
  \text{Constants} & K & ::= & \gvconst{send} \mid \gvconst{receive} \mid \gvconst{fork} \mid \gvconst{wait} \mid \gvconst{link}\\
\end{syntax}

\begin{mathpar}
\gvdual{\gvout{T}{S}} = \gvin{T}{\gvdual S}

\gvdual{\gvin{T}{S}} = \gvout{T}{\gvdual S}

\gvdual{\interm} = \outterm

\gvdual{\outterm} = \interm
\end{mathpar}

\subsection{Typing}

\begin{mathpar}
\inferrule
  {T \not= \channel{S}}
  {\{x:T\} \vdash x:T}

\inferrule
  {\Gamma,x:T \vdash M:U}
  {\Gamma \vdash \lambda x.M : T \lto U}

\inferrule
  {\Gamma \vdash M: T \lto U \\
   \Delta \vdash N: T}
  {\Gamma,\Delta \vdash M\,N: U}

\inferrule
  {\Gamma \vdash M: T \\
   \Delta \vdash N: U}
  {\Gamma,\Delta \vdash (M,N): T \times U}

\inferrule
  {\Gamma \vdash M: T \times T' \\
   \Delta,x:T,y:T' \vdash N: U}
  {\Gamma,\Delta \vdash \gvlet{(x,y)}{M}{N} : U}

\inferrule
  {\Gamma \vdash M: T}
  {\Gamma \vdash \mkwd{inl}\,M: T+U}

\inferrule
  {\Gamma \vdash M: T+T' \\
   \Delta,x:T \vdash N: U \\
   \Delta,x:T' \vdash N': U}
  {\Gamma,\Delta \vdash \gvcase{M}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N'} : U}

\inferrule
  { }
  {\vdash (): \one}

\inferrule
  {\Gamma \vdash M: \one \\
   \Delta \vdash N: T}
  {\Gamma,\Delta \vdash \gvletunit{M}{N}: T}

\inferrule
  {\Gamma \vdash M: \zero}
  {\Gamma, \Gamma' \vdash \gvconst{absurd} \app M : T}

\gvconst{send} : T \times \gvout{T}{S} \lto S

\gvconst{receive} : \gvin{T}{S} \lto T \times S

\gvconst{fork} : (S \lto \outterm) \lto \gvdual{S}

\gvconst{wait} : \interm \lto \one

\gvconst{link} : S \times \gvdual{S} \lto \outterm
\end{mathpar}

\subsection{Evaluation}

\newcommand{\distinguish}[1]{\langle #1 \rangle}

\newcommand{\wcirc}{{\mathord{\circ}}}
\newcommand{\bcirc}{{\mathord{\bullet}}}

\begin{syntax}
  \text{Values} & V & ::= & x \mid K \mid \lambda x.M \\ % \mid K\,V \\
  & & \mid & () \mid (V,V') \mid \mkwd{inl}\,V \mid \mkwd{inr}\,V  \\
  \text{Expression contexts} & E & ::= &  [] \mid E\,M \mid V\,E \mid \gvletunit{E}{M} \\
  & & \mid & (E,M) \mid (V,E) \mid \gvlet{(x,y)}{E}{M} \\
  & & \mid & \mkwd{inl}\,E \mid \mkwd{inr}\,E \mid \gvcase{E}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N'} \\
  \text{Configurations} & P & ::= & M \mid \distinguish M \mid P \parallel P' \mid (\nu x) P \\
  \text{Configuration contexts} & C & ::= & E \mid \distinguish E \mid C \parallel P \mid (\nu x)C \\
  \text{Flags} & \phi & ::= & \wcirc \mid \bcirc
\end{syntax}
We define combination of flags $\phi + \phi'$ by
\begin{mathpar}
  \wcirc + \wcirc = \wcirc

  \wcirc + \bcirc = \bcirc

  \bcirc + \wcirc = \bcirc
\end{mathpar}
and leave $\bcirc + \bcirc$ undefined.  Configuration typing is given by
\begin{mathpar}
\inferrule
  {\Gamma \vdash M: T}
  {\Gamma \vdash^\bcirc \distinguish M}

\inferrule
  {\Gamma \vdash M: \outterm}
  {\Gamma \vdash^\wcirc M}

\inferrule
  {\Gamma, x:\channel{S} \vdash^\phi P}
  {\Gamma \vdash^\phi (\nu x) P}

\inferrule
  {\Gamma,x:S \vdash^{\phi} P \\
   \Gamma',x:\gvdual{S} \vdash^{\phi'} P'}
  {\Gamma,\Gamma',x:\channel{S} \vdash^{\phi + \phi'} P \parallel P'}
\end{mathpar}
We will write $\Gamma \vdash P$ for $\Gamma \vdash^\bcirc P$.  Note that while we can write the
classic deadlocked configuration
\[
  (\nu x)(\nu y)(\distinguish{\gvlet{(z,x)}{\gvconst{receive} \app x}{\gvconst{send} \app (z,y)}} \parallel
                 \gvlet{(z,y)}{\gvconst{receive} \app y}{\gvconst {send} \app (z,x)})
\]
it is not well typed: we can only split one of $x,y$ at the $\parallel$.  Term reductions:
\begin{align*}
  (\lambda x.M)\,V &\teval M\{V/x\} \\
  \gvletunit{()}{M} &\teval M \\
  \gvlet{(x,y)}{(V,V')}{M} &\teval M\{V/x,V'/y\} \\
  \gvcase{(\mkwd{inl}\,V)}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N'} &\teval N\{V/x\} \\
  E[M] &\teval E[M'] \qquad \text{if $M \teval M'$}
\end{align*}
Configuration (context) equivalence:
\begin{mathpar}
C[\mathsf{link}\,(x,y)] \equiv C[\mathsf{link}\,(y,x)]

C_0 \parallel C_1 \equiv C_1 \parallel C_0

C_0 \parallel (C_1 \parallel C_2) \equiv (C_0 \parallel C_1) \parallel C_2

C_0 \parallel (\nu x)C_1 \equiv (\nu x)(C_0 \parallel C_1) \text{ if $x \not\in \fv(C_0)$}
\end{mathpar}

Awkwardly enough, the equivalence rules do not preserve typing.  For example, supposing that $x \in
\fv(P), y \in \fv(Q), \text{ and } x,y \in \fv(R)$, we have $\vdash (\nu x
y)(P \mid (Q \mid R))$ but not $\nvdash (\nu x y)((P \mid Q) \mid R)$.  We have a simple reduction
rule for configuration types, given by
\begin{mathpar}
\inferrule
%  [T-Output]
  { }
  {\channel{(\gvout T S)} \ceval \channel S}

\inferrule
%  [T-Input]
  { }
  {\channel{(\gvin T S)} \ceval \channel S}

\inferrule
%  [T-Context]
  {T \ceval T'}
  {\Gamma,x:T \ceval \Gamma,x:T'}
\end{mathpar}
Configuration reduction is given by
\begin{mathpar}
\inferrule
  [Send]
  { }
  {C[\gvconst{send} \app (V,x)] \parallel C'[\gvconst{receive} \app x] \ceval C[x] \parallel C'[(V,x)]}

\inferrule
  [Fork]
  {\text{$x$ fresh}}
  {C[\gvconst{fork} \app V] \ceval (\nu x)(C[x] \parallel (V\,x))}

\inferrule
  [Wait]
  { }
  {(\nu x)(C[\gvconst{wait} \app x] \parallel x) \ceval C[()]}

\inferrule
   [Link]
   {x \in \fv(M)}
   {(\nu x) (C[\gvconst{link} \app (x, y)] \parallel C'[M]) \ceval (\nu x)(C[x] \parallel C'[\gvletunit{\gvconst{wait} \app x}{M\{y/x\}}])}

\inferrule
   [Lift]
   {P \ceval P'}
   {C[P] \ceval C[P']}

\inferrule
   [Lift2]
   {M \teval M'}
   {C[M] \ceval C[M']}
%%
%% \inferrule
%%    [DLink]
%%    {x \in \fv(M)}
%%    {(\nu x) (C[\mathsf{link}\,(x, y)] \parallel \distinguish M) \ceval (\nu x)(C[x] \parallel \distinguish{\gvletunit{\mathsf{wait}\,x}{M\{y/x\}}})}
%%
%%
%% \inferrule
%%   {C_0 \equiv C_0' \\
%%    C_0' \ceval C_1' \\
%%    C_1' \equiv C_1}
%%   {C_0 \ceval C_1}
\end{mathpar}
Some things that might be useful.
\begin{lemma}\label{thm:term-preservation}
  If $\Gamma \vdash M: T$ and $M \teval M'$, then $\Gamma \vdash M': T$
\end{lemma}

\noindent
The proof is standard.

\begin{theorem}\label{thm:preservation}
  If $\Gamma \vdash P$ and $P \ceval P'$ then there is some $\Gamma'$ such that either $\Gamma
  \ceval \Gamma'$ or $\Gamma = \Gamma'$ and $\Gamma' \vdash P'$.
\end{theorem}

\begin{proof}
  By induction on the derivation of $P \ceval P'$.
  \begin{itemize}
  \item Case \textsc{Lift} is immediate by the induction hypothesis.
  \item Case \textsc{Lift2} follows from \lemref{term-preservation}, with $\Gamma = \Gamma'$.
  \item In case \textsc{Send}, from the assumption $\Gamma \vdash C[\mkwd{send}\,(V,x)] \parallel
    C'[\gvconst{receive} \app x]$, we can assume that $\Gamma$ partitions as
    $\Gamma_1,\Gamma_2,x:\channel{S}$ such that $S = \gvout{T}{S'}$, $V$ has type $T$, and
    $\Gamma_1,x:\gvout{T}{S'} \vdash C[\gvconst{send} \app (V,x)]$,
    $\Gamma_2,x:\gvin{T}{\gvdual{S'}} \vdash C'[\gvconst{receive} \app x]$.  As $\gvconst{send} : T
    \times \gvout{T}{S'} \lto S'$ and $\Gamma_1,x:\gvout{T}{S'} \vdash C[\gvconst{send} \app
    (V,x)]$, we can conclude that $\Gamma_1,x:S' \vdash C[x]$.  By a similar argument, we conclude
    that $\Gamma_2,x:\gvdual{S'} \vdash C'[(V,x)]$. Finally, as $\channel{(\gvout{T}{S})} \ceval
    \channel{S}$, $\Gamma_1,\Gamma_2,x:\channel{(\gvout T S)} \ceval
    \Gamma_1,\Gamma_2,x:\channel{S}$, and we can recompose the resulting processes concluding that
    $\Gamma_1,\Gamma_2,x:\channel{S} \vdash C[x] \parallel C'[(V,x)]$.
  \item In case \textsc{Fork}, from the assumption $\Gamma \vdash C[\gvconst{fork} \app V]$, we can
    conlude that $\Gamma$ splits into $\Gamma_1,\Gamma_2$ and there is some $S$ such that
    $\Gamma_1,x:S \vdash C[x]$ and $\Gamma_2,x:\gvdual{S} \vdash V \app x$.  Thus we have that
    $\Gamma,x:S \vdash C[x] \parallel V \app x$ and $\Gamma \vdash (\nu x)(C[x] \parallel
    V \app x)$.
  \item In case \textsc{Wait}, from the assumption $\Gamma \vdash (\nu x)(C[\gvconst{wait} \app
    x] \parallel x)$, we can conclude that $\Gamma,x:\interm \vdash C[\gvconst{wait} \app x]$ and
    thus, from the typing of \gvconst{wait}, that $\Gamma \vdash C[()]$.
  \item In case \textsc{Link}, from the assumptions $\Gamma \vdash (\nu x) (C[\gvconst{link} \app
    (x, y)] \parallel C'[M]), x \in \fv(M)$, we can conclude that $\Gamma$ partitions as
    $\Gamma_1,\Gamma_2,y:S$ such that $\Gamma_1,y:S,x:\gvdual{S} \vdash C[\gvconst{link} \app (x,
    y)]$ and $\Gamma_2,x:S \vdash C'[M]$.  (Note that the free variable assumption on the reduction
    rule for \gvconst{fork} allows us to assume that neither $C$ or $C'$ binds $x$ or $y$.)  From
    the type of \gvconst{link}, we have that $\Gamma,x:\outterm \vdash C[x]$; similarly, from $x \in
    \fv(M)$, we can conclude that $\Gamma_2,y:S \vdash C'[M\{y/x\}]$.  Finally, from the typing rule
    for \gvconst{wait}, we have that $\Gamma_2,x:\interm,y:S \vdash C'[\gvletunit{\gvconst{wait}
      \app x}{M\{y/x\}}]$, and that $\Gamma \vdash (\nu x)(C[x] \parallel
    C'[\gvletunit{\gvconst{wait} \app x}{M\{y/x\}}])$ \qed
  \end{itemize}
\end{proof}

\begin{theorem}\label{thm:preservation-equiv}
  If $\Gamma \vdash P$, $P \equiv P'$ and $P' \ceval Q'$, then there are some $\Gamma',Q$ such that
  either $\Gamma = \Gamma'$ or $\Gamma \ceval \Gamma'$, $Q' \equiv Q$, and $\Gamma' \vdash Q$.
\end{theorem}

\begin{proof}
  We begin by observing that if $P \ceval Q$, then there is some well-typed $P'$ such that $P =
  C[P']$, $P' \ceval Q'$, and $Q = C[Q']$.  The desired result is then obtained by structural
  induction on $P$, examining the possible equivalences in each case. \qed
\end{proof}

Define $\ceval^\star$ as the reflexive, transitive closure of $\equiv\ceval\equiv$.

\subsection{Deadlock and Its Absence}

Blocked terms:
\newcommand{\blockedp}{\mathsf{blocked}}
\newcommand{\depp}{\mathsf{depends}}
\[\begin{array}{rcl}
  \blockedp(x,M) &\defiff& \exists N. \; M = E[\gvconst{send} \app (x,N)] \\
  && \quad \lor \, M = E[\gvconst{receive} \app x] \\
  && \quad \lor \, M = E[\gvconst{wait} \app x] \\
  \depp(x,y,E[M]) &\defiff& \blockedp(x,M) \land y \in \fv(E) \\
  \depp(x,y,P) &\defiff& (P \equiv C[M] \land \depp(x,y,M)) \lor \, (P \equiv C[Q \parallel Q'] \\
  && \quad \land \, (\exists z. \depp(x,z,Q) \land \depp(z,y,Q')))
\end{array}\]
Finally, we have a natural definition of deadlock:
\newcommand{\deadlockp}{\ensuremath{\mathsf{deadlocked}}}
\[
\deadlockp(P) \defiff P \equiv C[Q \parallel Q'] \land \exists x,y. \depp(x,y,Q) \land \depp(y,x,Q').
\]
Because this definition depends on blocked processes (that is, those waiting to read or write) it
avoids the problems with return values (since a process returning a channel is not blocked on it, it
cannot be part of a deadlocked pair).  We say a process $P$ is deadlock-free if for all $Q$ such
that $P \ceval^\star Q$, $\lnot\deadlockp(Q)$.  Observe that if $P \equiv Q$, then $\deadlockp(P)
\iff \deadlockp(Q)$.

\begin{lemma}\label{thm:procs-share-one-channel}
  If $\Gamma \vdash P$, and $P = C[Q \parallel Q']$, then there is some variable $x$ such that
  $\fv(Q) \cap \fv(Q') = \{ x \}$.
\end{lemma}

\begin{proof}
  By structural induction on the derivation of $\Gamma \vdash P$; the only interesting case is for
  parallel composition, where the desired result is assured by the partitioning of the
  environment. \qed
\end{proof}

I think we can now show fairly directly that

\begin{lemma}\label{thm:typed-configs-df}
  If $\Gamma \vdash P$ then $\lnot \deadlockp(P)$.
\end{lemma}

\begin{proof}
  By contradiction: suppose $\deadlockp(P)$.  Then we know there must be some variables
  $x_1,\dots,x_n$ and processes $M_1,\dots,M_n$ in $P$ such that
  \[
    \blockedp(x_1,x_2,M_1) \land \blockedp(x_2,x_3,M_2) \land \cdots \land \blockedp(x_n,x_1,M_n).
  \]
  But now there is no possible $\Gamma$ such that any $\Gamma \vdash P'$ for any process $P'$
  containing the $M_i$---such a $P'$ would violate \lemref{procs-share-one-channel}.  \qed
\end{proof}

Finally, the following is trivial.

\begin{theorem}\label{thm:typed-terms-df}
  If $\Gamma \vdash M: T$, then $\distinguish M$ is deadlock-free.
\end{theorem}

\begin{proof}
  If $\Gamma \vdash M: T$, then $\Gamma \vdash \distinguish{M}$, and so
  $\lnot\deadlockp(\distinguish M)$ and, for any $Q$ such that $\distinguish M \ceval^\star Q$, we
  know that there is a well-typed $Q' \equiv Q$, and so $\lnot\deadlockp(Q)$. \qed
\end{proof}

\begin{definition}
A process $P$ is in canonical form if there is some sequence of variables $x_1,\dots,x_{n-1}$ and
terms $M_1,\dots,M_n$ such that
\[
  P = (\nu x_1)(M_1 \parallel (\nu x_2)(M_2 \parallel \dots \parallel (\nu x_{n-1})(M_{n-1} \parallel \distinguish{M_n})\dots)).
\]
\end{definition}

\begin{lemma}\label{thm:canonical}
  If $\Gamma \vdash P$, then there is some $P' \equiv P$ such that $\Gamma \vdash P'$ and $P'$ is in
  canonical form.
\end{lemma}

\begin{proof}
  Let $x_1,\dots,x_{n-1}$ be the $\nu$-bound variables in $P$ and $M_1,\dots,M_n$ be the terms in
  $P$; the proof is by induction on $n$.  If $n > 1$, then pick some $M_i$ such that there is
  exactly one $\nu$-bound variable $x_j$ where $x_j \in \fv(M_i)$.  (That there must be such an
  $M_i$ and $x_j$ can be established by a standard counting argument, together with
  \lemref{procs-share-one-channel}.)  Now, construct $Q$ from $P$ by the homomorphic extension of
  the mapping $(\nu x_j)P \mapsto P$ and $P \parallel M_i \mapsto P$.  From the assumption that
  $\Gamma \vdash P$, we can conclude that there is some $\Gamma' \subseteq \Gamma$ and type $S$ such
  that $\Gamma',x:S \vdash Q$.  By the induction hypothesis, there is some $Q' \equiv Q$ in
  canonical form.  Finally, let $P' = (\nu x_j)(M_i \parallel Q')$; we can see that
  straightforwardly that $P'$ is in canonical form; that $P \equiv P'$; and, that $\Gamma \vdash
  P'$. \qed
\end{proof}

\begin{theorem}\label{thm:progress-open}
  Let $\Gamma \vdash P$, $P \centernot\ceval$ and let $P' = (\nu x_1)(M_1 \parallel (\nu
  x_2)(M_2 \parallel \dots \parallel (\nu x_{n-1})(M_{n-1} \parallel \distinguish{M_n})\dots))$ be
  a canonical form of $P$.  Then:
  \begin{enumerate}
  \item For $1 \leq i \leq n - 1$ either $\blockedp(x_j,M_i)$ where $j \leq i$ or $\blockedp(y,M_i)$
    for some $y \in \dom(\Gamma)$; and,
  \item Either $M_n$ is a value or $\blockedp(y,M_n)$ for some $y \in \{ x_i \mid i \leq i \leq n -
    1 \} \cup \dom(\Gamma)$.
  \end{enumerate}
\end{theorem}

\begin{proof}
  By induction on the derivation of $\Gamma \vdash P'$, using the definition of $\ceval$. \qed
\end{proof}

\begin{corollary}\label{thm:progress}
  Let $\vdash P$, $P \centernot\ceval$ and let $P' = (\nu x_1)(M_1 \parallel (\nu
  x_2)(M_2 \parallel \dots \parallel (\nu x_{n-1})(M_{n-1} \parallel \distinguish{M_n})\dots))$ be
  a canonical form of $P$.  Then:
  \begin{enumerate}
  \item For $1 \leq i \leq n - 1$, $\blockedp(x_i,M_i)$; and,
  \item $M_n = \distinguish V$ for some value $V$.
  \end{enumerate}
\end{corollary}

\begin{proof}
  By induction on the derivation of $\vdash P'$, relying on \thmref{progress-open}.  \qed
\end{proof}

\section{Direct GV semantics}

\newcommand{\rpar}[1]{\mathbin{{[}\:\!\!\rangle}_{\!{#1}}\!}
\newcommand{\lrpar}[1]{\mathbin{\langle\hspace{-.3ex}\rangle}_{\!{#1}}\!}
\newcommand{\lpar}[1]{\mathbin{\langle\:\!\!{]}}_{{#1}}\!}

\newcommand{\con}[3]{{#1} \rpar{#2} {#3}}

\[
\mkwd{connect} : (S \lto \outterm, \gvdual{S} \lto T) \lto T
\]

Syntactic sugar:
\begin{align*}
\con{M}{x}{N} &\defiff \mkwd{connect}(\lambda x.M, \lambda x.N) \\
\con{L}{x}{\con{M}{y}{N}} &\defiff \con{L}{x}{(\con{M}{y}{N})} \\
\end{align*}

Equivalences ($\equiv$ is the transitive, reflexive, symmetric closure of the following rules):
\begin{align*}
\mkwd{link}\,(x,y) &\equiv \mkwd{link}\,(y,x) \\
\con{L}{x}{\con{M}{y}{N}} &\equiv \con{M}{y}{\con{L}{x}{N}} \\
\con{L}{x}{\con{M}{y}{N}} &\equiv \con{(\con{L}{x}{M})}{y}{N} \\
%\con{L}{x}{\con{M}{y}{N}} &\equiv \con{(\con{M}{x}{L})}{y}{N} \\
\end{align*}

Interesting reductions
\begin{align*}
\con{E[\mkwd{send}\,(V,x)]}{x}{E'[\mkwd{receive}\,x]}
  &\rto \con{E[x]}{x}{E'[(V,x)]} \\
\con{E[\mkwd{receive}\,x]}{x}{E'[\mkwd{send}\,(V,x)]}
  &\rto \con{E[(V,x)]}{x}{E'[x]} \\[1ex]
\con{x}{x}{E[\mkwd{wait}\,x]}
  &\rto E[()] \\
\con{E[\mkwd{wait}\,x]}{x}{x}
  &\rto E[()] \\[1ex]
\con{E[\mkwd{link}\,(x,y)]}{x}{M}
  &\rto \con{E[x]}{x}{(\mkwd{wait}\,x; M[y/x])} \\
\con{M}{x}{E[\mkwd{link}\,(x,y)]}
  &\rto \con{(\mkwd{wait}\,x; M[y/x])}{x}{E[x]} \\[1ex]
\mkwd{link}\,(x,\mkwd{link}\,(y,z))
  &\rto \mkwd{wait}\,x; \mkwd{link}\,(y,z) \\
E[\con{M}{x}{N}]
  &\rto \con{M}{x}{E[N]} \\
\end{align*}

An alternative is to remove the final commuting conversion rule and augment the notion of value to
include a suitable representation of a collection of blocked communicating processes.

Preservation
\begin{theorem}
If $\Gamma \vdash M : T$ and $M \rto N$ then $\Gamma \vdash N : T$.
\end{theorem}
%
\begin{proof}
By induction on the structure of the derivation of $\Gamma \vdash M : T$ using a standard
substitution lemma for the case of $\beta$-reduction at function types. \qed
\end{proof}

Progress
\begin{theorem}
\label{thm:free-progress}
If $\Gamma$ is a session environment (all variables in $\Gamma$ have session type) such that $\Gamma
\vdash M : T$ then one of the following holds:
\begin{enumerate}
\item $M$ is a value; or
\item there exists $N = \blockedp'(y_1, M_1) \rpar{x_1} \dots \rpar{x_{n}} \blockedp'(y_{n}, M_{n})$
  such that $M \equiv N$ and $\Gamma \vdash N : T$; or
\item there exists $N$ such that $M \rto N$.
\end{enumerate}
\end{theorem}
%
\begin{proof}
By induction on the structure of the derivation of $\Gamma \vdash M : T$. \qed
\end{proof}
% In the second case each $y_i$ must be equal to either $x_i$ or some $x$ in $\Gamma$.

\begin{theorem}
If $\vdash M : T$ then one of the following holds:
\begin{enumerate}
\item $M$ is a value; or
\item there exists $N = \blockedp(x_1, M_1) \rpar{x_1} \dots \rpar{x_{n-1}} \blockedp(x_{n-1},
  M_{n-1}) \rpar{x_n} V$ such that $M \equiv N$ and $\Gamma \vdash N : T$; or
\item there exists $N$ such that $M \rto N$.
\end{enumerate}
\end{theorem}
%
\begin{proof}
By induction on the structure of the derivation of $\vdash M : T$ using
\thmref{free-progress}. \qed
\end{proof}

$\blockedp(x, M)$ means $M$ is blocked on a send or receive involving $x$.

$\blockedp'(x, M)$ means either $M = x$ or $M$ is blocked on a send, receive, link, or wait
involving $x$.

\section{CP}

\todo{Shall we restrict ourselves to the multiplicative-additive fragment of CP?}

\begin{figure}[float]

\begin{mathpar}
\inferrule{ }{\cptyp{\link{x}{w}}{x:A,w:\cpdual{A}}}

\inferrule{\cptyp{P}{\Gamma,y:A} \\
           \cptyp{Q}{\Delta,y:\cpdual{A}}}
          {\cptyp{\cut{y}{A}{P}{Q}}{\Gamma,\Delta}}

\inferrule{ }{\cptyp{x[].0}{x:1}}

\inferrule{\cptyp{P}{\Gamma,y:A,x:B}}
          {\cptyp{x(y).P}{\Gamma,x:A \parr B}}

\inferrule{\cptyp{P}{\Gamma,y:A} \\
           \cptyp{Q}{\Delta,x:B}}
          {\cptyp{x[y].(P \mid Q)}{\Gamma,\Delta,x:A \otimes B}}

\inferrule{\cptyp{P}{\Gamma}}
          {\cptyp{x().P}{\Gamma,x:\bot}}

\inferrule{\cptyp{P}{\Gamma,x:A_i}}
          {\cptyp{\sel{x}{in_i}.P}{\Gamma,x:A_1 \oplus A_2}}

\inferrule{\cptyp{P}{\Gamma,x:A} \\
           \cptyp{Q}{\Gamma,x:B}}
          {\cptyp{\case{x}{P;Q}}{\Gamma,x:A \with B}}

\inferrule{ }{\cptyp{\case{x}{}}{\Gamma,x:\top}}
\end{mathpar}

\caption{Typing Rules for CP}\label{fig:cp-typing}
\end{figure}

The types of CP are the propositions of classical linear logic.
%
\[\begin{array}{@{}l@{~}r@{~}c@{~}l@{}}
  \text{Types} & A,B & ::= & A \otimes B \mid A \parr B \mid 1 \mid \bot \mid A \oplus B \mid A \with B \mid 0 \mid \top \\
\end{array}\]
CP adopts the standard notion of classical linear logic duality:
\[
\ba{@{}c@{\qquad}c@{\qquad}c@{\qquad}c@{}}
\begin{eqs}
  \cpdual{(A \otimes B)} &=& \cpdual{A} \parr \cpdual{B} \\
  \cpdual{(A \parr B)} &=& \cpdual{A} \otimes \cpdual{B} \\
\end{eqs}
&
\begin{eqs}
  \cpdual{1} &=& \bot \\
  \cpdual{\bot} &=& 1 \\
\end{eqs}
&
\begin{eqs}
  \cpdual{(A \oplus B)} &=& \cpdual{A} \with \cpdual{B} \\
  \cpdual{(A \with B)} &=& \cpdual{A} \oplus \cpdual{B} \\
\end{eqs}
&
\begin{eqs}
  \cpdual{\top} &=& 0 \\
  \cpdual{0} &=& \top \\
\end{eqs}
\ea
\]
where $X^{\perp\perp} = X$.
%
We let $\Gamma, \Delta$ range over type environments. The judgement $\cptyp{P}{\Gamma}$ states that
process $P$ uses channels $\Gamma$.
%
Typing rules for CP terms are given in Fig.~\ref{fig:cp-typing}. We write $fv(P)$ for the free
variables used in process $P$; in the typing rules, new bound variables are designated $y$.

\paragraph{Structural Rules.}

CP has two structural rules, axiom and cut. We interpret the axiom $\link{x}{w}$ as channel
forwarding: actions on channel $x$ are mirrored on $w$, and vice versa. Thus, $x$ and $w$ must have
dual type. Cut $\cut{y}{A}{P}{Q}$ is interpreted as communication between processes $P$ and $Q$ on
channel $y$; the duality of the typing of $y$ assures that its uses in $P$ and $Q$ are
compatible. We identify CP up to structural equivalence:
%
\small\begin{equations}
  \link{x}{w} &\equiv& \link{w}{x} \\
  \cut{y}{A}{P}{Q} &\equiv& \cut{y}{\cpdual{A}}{Q}{P} \\
  \cut{y}{A}{P}{\cut{z}{B}{Q}{R}} &\equiv& \cut{z}{B}{\cut{y}{A}{P}{Q}}{R}, \quad \text{if $y \not\in fv(R)$} \\
\end{equations}\normalsize%

\paragraph{Input and Output.}

The multiplicative connectives $\parr$ and $\otimes$ are interpreted as input and output. The
process $x(y).P$ inputs channel $y$ on channel $x$, and continues as $P$. The process $x[y].(P \mid
Q)$ is interpreted as bound output: it sends a fresh variable $y$ along $x$, spawns a process $P$ in
which $y$ is used, and continues as process $Q$ in which $x$ is used.  It amounts to the
$\pi$-calculus term $(\nu y) \overline{x}(y).(P \mid Q)$. We write $x[y].P$ as syntactic sugar for
$x[y'].(\link{y}{y'} \mid P)$. The units of $\parr$ and $\otimes$, $\bot$ and $1$, are interpreted
as nullary input and nullary output, respectively.

\paragraph{Selection and Choice.}

The additive connectives $\oplus$ and $\with$ are interpreted as selection and choice. The process
$\case{x}{P_1;P_2}$ offers a choice of processes $P_1$ and $P_2$; dually, the process
$\sel{x}{in_i}.P_i$ chooses the $i$-th alternative. The unit for choice is $0$, indicating
absurdity. Note that there is no term proving $0$. The dual of absurdity is $\top$, and provides
arbitrary behavior; as there is no term proving $0$, no term relying on $\top$ can reduce.

\subsection{Cut Elimination}


\begin{figure}[float]

\begin{equations}
\cut{x}{A}{\link{w}{x}}{P}
  &\Longrightarrow& P[w/x] \\
\cut{x}{A \otimes B}{x[y].(P \mid Q)}{x(y).R}
  &\Longrightarrow&
    \cut{y}{A}{Q}{\cut{x}{B}{P}{R}} \\
\cptyp{\cut{x}{1}{x[].0}{x().P}}{\Gamma}
  &\Longrightarrow&
    P \\
\cut{x}{A \oplus B}{\sel{x}{in_i}.P}{\case{x}{Q_1; Q_2}}
  &\Longrightarrow&
    \cut{x}{A}{P}{Q_i} \\
\end{equations}%
\caption{Principal Cut Elimination Rules}\label{fig:beta-reduction}

\end{figure}

Cut elimination corresponds to synchronous process reduction.  The principal cut reductions are
given in Fig.~\ref{fig:beta-reduction}. These are quite standard; for instance, cut reduction of
$\with$ against $\oplus$ corresponds to picking one of the offered alternatives.

\begin{figure}[float]

\begin{equations}
  \cut{z}{A}{x[y].(P \mid Q)}{R} &\Longrightarrow& x[y].(\cut{z}{A}{P}{R} \mid Q), \qquad \text{if $z \not\in fv(Q)$} \\
  \cut{z}{A}{x[y].(P \mid Q)}{R} &\Longrightarrow& x[y].(P \mid \cut{z}{A}{Q}{R}), \qquad \text{if $z \not\in fv(P)$} \\
  \cut{z}{A}{x(y).P}{Q} &\Longrightarrow& x(y).\cut{z}{A}{P}{Q} \\
  \cut{z}{A}{\sel{x}{in_i}.P}{Q} &\Longrightarrow& \sel{x}{in_i}.\cut{z}{A}{P}{Q} \\
  \cut{z}{A}{\case{x}{P;Q}}{R} &\Longrightarrow& \case{x}{\cut{z}{A}{P}{R}; \cut{z}{A}{Q}{R}} \\
\end{equations}
\caption{Commuting Conversions}\label{fig:commuting}
\end{figure}

The commuting conversions push communication under process prefixes, and are given in
Fig.~\ref{fig:commuting}.

\todo{Show that using a sane rule for send yields an entirely equivalent system --- and use that
  system!}

\todo{Think carefully about what to do with commuting conversions.}

\section{Translation from CP to GV}

\begin{figure}[float]
\small
\begin{equations}
  \togv{\cut{x}{}{P}{Q}} &=&
    \gvlet{x}{\gvfork{x}{\togv{P}}}{\togv{Q}} \\
  \togv{\link{x}{y}} &=& \gvlet{z}{\gvlink{x}{y}}{z} \\
  \togv{x[y].(P \mid Q)} &=&
    \gvlet{x}{\gvsend{(\gvfork{y}{\togv{P}})}{x}}{\togv{Q}} \\
  \togv{x(y).P} &=&
    \gvlet{(y,x)}{\gvreceive{x}}{\togv{P}} \\
  \togv{x[].0} &=& x \\
  \togv{x().P} &=& \gvlet{()}{\mkwd{wait}\,x}{\togv{P}} \\
  \togv{\sel{x}{\mathit{l}}.P} &=&
    \gvlet{x}{\gvselect{l}{x}}{\togv{P}} \\
  \togv{\case{x}{l_i.P_i}_i} &=&
    \gvcase{x}{l_i.\togv{P_i}}_i \\
\end{equations}%
\caption{Translation of CP Terms into GV}\label{fig:fromcp}
\end{figure}

We now present the translation $\togv{-}$ from CP to GV. On types:
\[
\ba{@{}c@{\qquad}c@{\qquad}c@{}}
\begin{eqs}
\togv{A \otimes B} &=& \gvout{\gvdual{\togv{A}}}{\togv{B}} \\
\togv{A \parr B}   &=& \gvin{\togv{A}}{\togv{B}} \\
\end{eqs}
&
\begin{eqs}
\togv{1}           &=& \outterm \\
\togv{\bot}        &=& \interm \\
\end{eqs}
&
\begin{eqs}
\togv{+\{l_i:A_i\}_i}     &=& +\{l_i:\togv{A_i}\}_i  \\
\togv{\with\{l_i:A_i\}_i} &=& \with\{l_i:\togv{A_i}\}_i \\
\end{eqs}
\ea
\]
The translation on terms is given in Fig.~\ref{fig:fromcp}.

\section{Translations Between GV$\pi$-ANF and CP}

\todo{Various translations.}

\todo{Try to fit in with the configuration semantics.}

\todo{Ensure that the definition of $\equiv$ is appropriate for the theorems.}

\todo{Show that GV$\pi$ reduction simulates GV reduction.}

\todo{Show that the A-normalisation rules are sound (easy).}

\begin{theorem}
If $P \equiv Q$, then $\togv{P} \equiv \togv{Q}$.
\end{theorem}

\begin{theorem}
If $P \vdash \Gamma$ and $P \rto Q$, then $\togv{P} \rto^+ \togv{Q}$.
\end{theorem}

\begin{theorem}
If $M, N$ are GV$\pi$-ANF terms and $M \equiv N$, then $\tocp{M}z \equiv \tocp{N}z$.
\end{theorem}

\begin{theorem}
If $M$ is a GV$\pi$-ANF term and $M \rto N$, then $\tocp{M}z \rto^+ \tocp{N}z$.
\end{theorem}

\section{Extending GV}

We define a language GVX, which, depending on your perspective, either extends GV with mix or
combines the types of closed sessions.  The syntax is largely as in GV; the meaningful changes are
the elimination of $\interm$ and $\outterm$ in favor of $\gvend$, and the use of \gvconst{close} instead
of \gvconst{wait}.
\begin{syntax}
  \text{Session types} & S & ::= & \gvout{T}{S} \mid \gvin{T}{S} \mid \gvend \mid \channel{S} \\
  \text{Constants} & K & ::= & \gvconst{send} \mid \gvconst{receive} \mid \gvconst{fork} \mid \gvconst{close} \mid \gvconst{link}\\
\end{syntax}
The remaining parts of the grammar are unchanged from GV.  The definition of duality is updated to
reflect that $\gvend$ is self-dual:
\[
  \gvdual \gvend = \gvend
\]
We provide new typing rules for some of the constants
\begin{mathpar}
\gvconst{fork} : (S \lto \one) \lto \gvdual S

\gvconst{close} : \gvend \lto \one

\gvconst{link} : S \times \gvdual S \lto \one
\end{mathpar}
but otherwise the type system is unchanged from that of GV.  We require an extension of the type
system for configurations, however:
\begin{mathpar}
\inferrule
  {\Gamma \vdash M: T}
  {\Gamma \vdash^\bcirc \distinguish M}

\inferrule
  {\Gamma \vdash M: \one}
  {\Gamma \vdash^\wcirc M}

\inferrule
  {\Gamma, x: \channel S \vdash^\phi P}
  {\Gamma \vdash^\phi (\nu x)P}

\inferrule
  {\Gamma, x: S \vdash^\phi P \\
   \Gamma', x: \gvdual S \vdash^{\phi'} P'}
  {\Gamma,\Gamma',x:\channel S \vdash^{\phi + \phi'} P \parallel P'}

\inferrule
  {\Gamma \vdash^\phi P \\
   \Gamma' \vdash^{\phi'} P'}
  {\Gamma,\Gamma' \vdash^{\phi + \phi'} P \parallel P'}
\end{mathpar}
Perhaps the latter two rules can be combined by defining a suitable operation on environments;
however, it seems simpler now to just provide two typing rules.  Rules \textsc{Send, Fork, Lift} and
\textsc{Lift2} apply to GVX unchanged; the remaining reduction rules are
\begin{mathpar}
\inferrule
  { }
  {(\nu x)(C[\gvconst{close} \app x] \parallel C'[\gvconst{close} \app x)] \ceval C[()] \parallel C'[()]}

\inferrule
  {x \in \fv(P)}
  {C[\gvconst{link} \app (x,y)] \parallel P \ceval C[()] \parallel P \{y/x\}}
\end{mathpar}
The equivalences are similarly extended by
\begin{mathpar}
P \parallel () \equiv P
\end{mathpar}
We have a slightly different result about channels shared between processes, to account for the
multiple forms of composition:
\begin{lemma}
  If $\Gamma \vdash P$ and $P = C[Q \parallel Q']$, then $\fv(Q) \cap \fv(Q')$ is either empty or
  the singleton set $\{x\}$ for some variable $x$.
\end{lemma}
The proof is again by induction on the derivation of $\Gamma \vdash P$.  However, note that this has
no consequence for the proof of deadlock freedom (which depended on their being two channels shared
among processes).  Thus we can conclude that
\begin{theorem}
  If $\Gamma \vdash M: T$ then $\distinguish M$ is deadlock free.
\end{theorem}

\section{Related Work}\label{sec:related}

\section{Conclusions and Future Work}\label{sec:conclusion}


\end{document}
