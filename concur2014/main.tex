% -*- fill-column: 100 -*-

\documentclass[orivec,envcountsame]{llncs}

\usepackage{amsmath,amssymb,mathwidth,stmaryrd,xspace}
\usepackage[table]{xcolor}
\usepackage{colortbl}
\addtolength{\jot}{-3px}

% Attempt to duplicate Springer's style of references
\usepackage[authoryear,compress,round]{natbib}
\renewcommand{\bibsection}{\section*{References}}
\renewcommand{\bibpreamble}{\scriptsize}

\usepackage{mathpartir}
\mprset{sep=1em}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

%% evil space hacks
%% see: http://www-h.eng.cam.ac.uk/help/tpl/textprocessing/squeeze.html
%
\setlength{\textfloatsep}{2ex}
%\setlength{\floatsep}{0ex}
%\setlength{\intextsep}{0ex}
%\setlength{\abovecaptionskip}{0ex}
%\setlength{\belowcaptionskip}{0ex}

\newcommand{\with}{\mathbin\binampersand}
\newcommand{\parr}{\mathbin\bindnasrepma}
\newcommand{\cpdual}[1]{#1^\perp}
\newcommand{\cpbang}[1]{{! #1}}
\newcommand{\cpquery}[1]{{? #1}}
\newcommand{\gvdual}[1]{\overline{#1}}
\newcommand{\gvout}[2]{{!#1.#2}}
\newcommand{\gvin}[2]{{?#1.#2}}
\newcommand{\lto}{\ensuremath{\multimap}}
\newcommand{\uto}{\ensuremath{\rightarrow}}
\newcommand{\outterm}{\mkwd{end}_!}
\newcommand{\interm}{\mkwd{end}_?}
\newcommand{\gvserver}[1]{\flat #1}
\newcommand{\gvservice}[1]{\sharp #1}
\newcommand{\trule}[1]{(\textit{#1})}
\newcommand{\cptyp}[2]{#1 \vdash #2}
\newcommand{\gvtyp}[3]{#1 \vdash #2 : #3}

\newcommand{\mapname}{\mathsf{map}}
\newcommand{\map}[3]{\mapname^{#1}_{#2}(#3)}
\newcommand{\gvmap}[3]{\mapname^{#1}_{#2}\:#3}

\newcommand{\mkwd}[1]{\mathsf{#1}}
\newcommand{\tkwd}[1]{\textsf{#1}}
\newcommand{\link}[2]{#1 \leftrightarrow #2}
\newcommand{\cut}[4]{\mkwd{new}\:#1 \: (#3 \mid #4)}
\newcommand{\replicate}[2]{{!#1(#2)}}
\newcommand{\derelict}[2]{{?#1[#2]}}
\newcommand{\rec}[1]{\mkwd{rec}\:#1}
\newcommand{\corec}[4]{\mkwd{corec}\:{#1} \langle #2 \rangle (#3,#4)}
\newcommand{\corecf}[5]{\mkwd{corec}^{#1} #2 \langle #3 \rangle (#4,#5)}
\newcommand{\clabel}[1]{\mathit{#1}}
\renewcommand{\case}[2]{\mkwd{case}\:#1\:\{#2\}}
\newcommand{\sel}[2]{#1[\clabel{#2}]}
\newcommand{\gvsend}[2]{\mkwd{send}\:#1\:#2}
\newcommand{\gvreceive}[1]{\mkwd{receive}\:#1}
\newcommand{\gvlet}[3]{\mkwd{let}\;#1 = #2\;\mkwd{in}\;#3}
\newcommand{\gvselect}[2]{\mkwd{select}\:#1\:#2}
\newcommand{\gvcase}[2]{\mkwd{case}\:#1\:\{#2\}}
\newcommand{\gvlink}[2]{\mkwd{link}\:#1\:#2}
\newcommand{\gvfork}[2]{\mkwd{fork}\:#1.#2}
\newcommand{\lrkwd}{\mkwd{cofix}}
\newcommand{\gvfix}[3]{\lrkwd\:#1\:#2 = #3}
\newcommand{\gvletrec}[4]{\gvlet{#1}{\gvfix{#1}{#2}{#3}}{#4}}
\newcommand{\gvserve}[2]{\mkwd{serve}\:#1.#2}
\newcommand{\gvrequest}[1]{\mkwd{request}\:#1}

\newcommand{\gvifthen}[3]{\mkwd{if}\:#1\:\mkwd{then}\:#2\:\mkwd{else}\:#3}
\newcommand{\gvreceivek}[4]{\gvlet{({#1}, {#2})}{\gvreceive{#3}}{#4}}


\newcommand{\true}{\mathrm{true}}
\newcommand{\false}{\mathrm{false}}

\newcommand{\key}{\mkwd}
\newcommand{\cofix}{\lrkwd}

\newcommand{\tocpbig}[1]{\left\llbracket #1 \right\rrbracket}

\newcommand{\tocp}[1]{\llbracket #1 \rrbracket}
\newcommand{\togv}[1]{\llparenthesis #1 \rrparenthesis}


\newcommand{\topi}[1]{({#1})^\star}

\newcommand{\un}{un}
\newcommand{\lin}{lin}

\newcommand{\mucp}{$\mu\mathrm{CP}$\xspace}
\newcommand{\mugv}{$\mu\mathrm{GV}$\xspace}
\newcommand{\gvpi}{$\mu\mathrm{GV}\pi$\xspace}

\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}

\newcommand{\bl}{\ba[t]{@{}l@{}}}
\newcommand{\el}{\ea}

\newenvironment{equations}{\[\ba{@{}r@{~}c@{~}l@{}}}{\ea\]}
\newenvironment{eqs}{\ba{@{}r@{~}c@{~}l@{}}}{\ea}

\newcommand{\mcl}[2]{\multicolumn{#1}{l}{#2}}

%\newcommand{\secref}[1]{(\S\ref{sec:#1})}
\newcommand{\secref}[1]{Section~\ref{sec:#1}}

%%% grey shading
\definecolor{shade}{RGB}{223,223,223}
\newcommand\shade[1]{\setlength{\fboxsep}{0pt}\colorbox{shade}{\ensuremath{#1}}}
%\newcommand{\shade}[1]{\colorbox{shade}{\ensuremath{#1}}}

\newcommand\shaderow{\noalign{\vskip-0.4pt}\rowcolor{shade}[0.6mm]}
%%%

\title{The least must speak with the greatest\vspace{-3mm}}
\author{J. Garrett Morris \and Sam Lindley \and Philip Wadler}
\institute{The University of Edinburgh \\
           \email{\{Garrett.Morris,Sam.Lindley,Philip.Wadler\}@ed.ac.uk} \vspace{-5mm}}

\newcommand{\todo}[1]{{\noindent\small\color{red} \framebox{\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{\textbf{TODO:} #1}}}}
%\newcommand{\todo}[1]{}

\begin{document}

\maketitle

\begin{abstract}
  We extend a propositions-as-types correspondence between linear logic and session types to include
  recursive sessions.  Our extension takes least and greatest fixed points as dual, an idea well-known
  to theorists, but which has not previously appeared in the treatment of recursive sessions. We
  preserve the freedom from races, deadlock, and livelock that is a hallmark of the
  propositions-as-types approach, and avoid a problem with preservation of duality that appears in
  the standard treatment of recursive session types. We treat two systems, one based on classical
  linear logic, derived from work of Caires and Pfenning and of Wadler, and one based on a linear
  functional language, derived from work of Gay and Vasconcelos. Our treatment of recursion is
  inspired by Baelde.
\end{abstract}

\vspace{-7mm}
\section{Introduction}\label{sec:intro}

Previous work on session types suffers from a mismatch.  Session types capture communication
protocols. The two ends of a channel must be \emph{dual}, which ensures that when one end of a
channel performs output the other performs input, and when one end offers a choice of actions the
other selects from these alternatives. Session types are of limited use without \emph{recursion},
which permits defining sessions of arbitrary size. Recursion traditionally comes in two dual forms,
least fixed point and greatest fixed point. However, in previous work on session types recursion is
introduced in such a way that both ends of a channel are treated as least fixed points, a mismatch
with the treatment of the other connectives. Here, we introduce a notion of recursion for session
types that restores the traditional notion that least fixed points are dual to greatest fixed
points.

\citet{Honda93} introduced session types as a type system for process calculi, and
\citet{GayVasconcelos10} reformulated session types in the context of a functional language with
linear types. \citet{CairesPfenning10} uncovered a propositions-as-types correspondence between
session types and intuitionistic linear logic, and \citet{Wadler12} adapted the correspondence to
classical linear logic. Wadler defines two systems, a process calculus CP (inspired by Caires and
Pfenning) and a linear functional language GV (inspired by Gay and Vasconcelos), and presents a
type-preserving translation from GV to CP. Subsequently, \citet{LindleyM14} extended GV to support
translation in the other direction, giving type-preserving translations not only from GV to CP but
also from CP to GV. A hallmark of the process-as-types approach is that it yields systems guaranteed
free of races, deadlock, and livelock, and both CP and GV benefit from these properties.
\citet{Toninho13,Toninho14} also treat recursion in systems inspired by a propositions-as-types
correspondence, but they have no notion of duality for least and greatest fixed points.

There is much previous work that supports recursive session types, starting with \citet{Honda98},
and including \citet{Yoshida07} and \citet{DemangeonH11}, all of which suffer from the mismatch
mentioned above. Here, drawing on work of \citet{Baelde12}, we extend both CP and GV with recursive
session types, taking least and greatest fixed points as duals. We show that the type-preserving
translations extend to the new systems, and that the new systems are still guaranteed free of races,
deadlock, and livelock.

\citet{Bono12} and \citet{Bernardi13} indepenently observed that the standard treatment of recursive
session types fails to preserve duality in the case that the recursive variable appears within a
carried type.  Their solution relies on an unusual form of substitution that applies only to the
carried types within a session type, while ours avoids the problem while using only standard forms
of substitution.

This paper makes the following contributions.
\begin{itemize}
\item Section~\ref{sec:mugv} extends GV to support recursion, yielding \mugv; and demonstrates its
  power with a series of examples of streams and a calculator.
  %, and a translation of a bit stream example due to \citet{Toninho13}.  In \mugv, unlike in
  previous session type systems, least fixed points are dual to greatest fixed points and duality is
  preserved in all cases.
\item Section~\ref{sec:mucp} extends CP to support recursion, yielding \mucp, and present a
  translation of some of the same examples. We show \mucp is guaranteed free of races, deadlock, and
  livelock.
\item Section~\ref{sec:translation} presents type-preserving translations from \mugv into \mucp and
  inversely. The translation guarantees that GV also is free of races, deadlock, and livelock.
  As a technical aid, we also present a type-preserving translation from \mugv into a
  subset of itself, similar to one in \citet{LindleyM14}, showing how function and product
  types can be represented by session types.
\end{itemize}
Section~\ref{sec:related} surveys related work and Section~\ref{sec:future} concludes.

\section{A Session-Typed Functional Language}
\label{sec:mugv}

In this section, we present \mugv, a simple functional language with session types patterned on the
language of \citet{GayVasconcelos10} (which we call LAST) and Wadler's language GV.
%
Throughout the paper we highlight the novel parts of \mugv and \mucp by shading them in
\shade{\mathrm{gray}}.

\subsection{Types}
\label{sec:mugv-types}

Types in \mugv are given by the following grammar:
\small
\[
\begin{array}{@{}l@{~}r@{~}c@{~}l@{}}
  \text{Types}         & T,U,V & ::= & S \mid T \otimes U \mid T \lto U \mid T \uto U \\
  \text{Session Types} & S     & ::= & \gvout{T}{S} \mid \gvin{T}{S}
                                \mid   \outterm \mid \interm
                                \mid   \oplus \{ l_i : S_i \}_i \mid \with \{ l_i : S_i \}_i
                                \mid   \gvservice{S} \mid \gvserver{S} \\ \shaderow
                            & & \mid & X \mid \gvdual{X}
                                \mid   {\mu G} \mid {\nu G} \\  \shaderow
  \text{Type Operators} & G    & ::= & X.S \\
\end{array}
\]\normalsize%
%
The types comprise session types, linear pairs ($T \otimes U$), and both linear ($T \lto U$) and
unlimited ($T \uto U$) functions.
%
Session types include input ($\gvin{T}{S}$), output ($\gvout{T}{S}$), selection ($\oplus\{ l_i:S_i
\}_i$), choice ($\with\{l_i:S_i\}_i$), and closed channels ($\interm$ and $\outterm$). There are two
variations on the closed channel ($\interm$) and ($\outterm$); these arise from our interpretation
of session types in classical linear logic, where there is no self-dual proposition corresponding to
closed channels.  We include a notion of replicated sessions, corresponding to exponentials in
linear logic: a channel of type $\gvservice{S}$ is a service, offering any number of channels of
type $S$; a channel of type $\gvserver{S}$ is the server providing such channels. (We have chosen
the syntax $\gvserver{S}$ and $\gvservice{S}$ as $!$ and $?$ are already used for input and output.)
%
For simplicity, we omit polymorphism as it is an orthogonal concern.
%
We include session variables ($X$) and their duals ($\gvdual{X}$), and types corresponding to
bounded recursion ($\mu X.S$) and unbounded corecursion ($\nu X.S$). If $G$ is an operator $X.S$,
then $G(S')$ denotes the standard capture-avoiding substitution of $S'$ for $X$ in $S$, which we
write as $S[S'/X]$.

Each type $T$ is either linear ($\lin(T)$) or unlimited ($\un(T)$).
% The linearity of $T$ is determined by its top level type constructor.
All types are linear except unlimited functions $T \uto U$, replicated channels $\gvservice{S}$, and
closed input channels $\interm$.

We extend the standard duality for non-recursive session types to include recursive session types:
\small\[
%\ba{@{}c@{\quad}c@{\quad}c@{\quad}c@{\quad}c@{\quad}c@{}}
\ba{@{}c@{\qquad}c@{\qquad}c@{\qquad}c@{\qquad}c@{}}
\begin{eqs}
\gvdual{\gvout{T}{S}} &=& \gvin{T}{\gvdual{S}} \\
\gvdual{\gvin{T}{S}} &=& \gvout{T}{\gvdual{S}} \\
\end{eqs}
&
\begin{eqs}
  \gvdual{\interm} &=& \outterm \\
  \gvdual{\outterm} &=& \interm \\
\end{eqs}
&
\begin{eqs}
  \gvdual{\oplus \{ l_i: S_i \}_i} &=& \with \{ l_i : \gvdual{S_i} \}_i \\
  \gvdual{\with \{ l_i: S_i \}_i} &=& \oplus \{ l_i : \gvdual{S_i} \}_i \\
\end{eqs}
&
\begin{eqs}
  \gvdual{\gvservice{S}} &=& \gvserver{\gvdual{S}} \\
  \gvdual{\gvserver{S}} &=& \gvservice{\gvdual{S}} \\
\end{eqs}
%&
%\begin{eqs}
%  \gvdual{X} &=& \gvdual{X} \\
%  \gvdual{\gvdual{X}} &=& X
%\end{eqs}
&
\begin{eqs}
  \shaderow \gvdual{\mu G} &=& \nu \gvdual{G} \\
  \shaderow \gvdual{\nu G} &=& \mu \gvdual{G}
\end{eqs}
\ea
\]\normalsize
where $\gvdual{\gvdual{X}} = X$ and we define the dual of an operator $G = X.S$ as $\gvdual{G} =
X.\gvdual{G(\gvdual{X})}.$ Observe that $\gvdual{G(S)} = \gvdual{G}(\gvdual{S})$.  Unlike many
notions of duality for session types, our definition preserves duality when recursive session types
are unfolded, even when the recursion occurs in the carried types.  For example, consider the
operator $G = X.\gvin{X}{\interm}$, its dual $\gvdual{G} = X.\gvout{\gvdual{X}}{\outterm}$, and the
dual session types $\mu G$ and $\nu \gvdual{G}$. Unfolding $\mu G$ yields $G(\mu G) =
\gvin{\mu G}{\interm}$; unfolding $\nu \gvdual{G}$ yields
%\small\[
  $\gvdual{G}(\nu \gvdual{G}) = \gvout{\gvdual{\nu \gvdual{G}}}{\outterm} = \gvout{\mu G}{\outterm}$,
%\]\normalsize
which is the dual of $\gvin{\mu G}{\interm}$.

To ensure that fixed points exist, we require that all operators $X.S$ be \emph{monotonic}, that is,
$X$ may appear only in positive subformulas of $S$.
%%
%% The subformula $T$ is negative in types $T
%% \lto U$ and $T \uto U$ and in the session type $\gvout{T}{S}$; every other other form of subformula
%% is positive.
%%
Thus, the operator $X.\gvout{X}{\outterm}$ is not monotonic, but the operator $X.\gvout{(X \uto
  \outterm)}{\outterm}$ is.
%
Formally, $X.S$ is monotonic iff the predicate $pos_{X,S}$ holds, where $pos$ and $neg$ are defined
by the homomorphic extensions of the following equations:
\small\[
\ba{@{}c@{\qquad}c@{}}
\begin{eqs}
pos_{X,X}         &=& \true \\
pos_{X,\gvdual{X}}  &=& \false \\
pos_{X,\gvout{T}{S}} &=& neg_{X,T} \wedge pos_{X,S} \\
pos_{X,T \lto U}    &=& neg_{X,T} \wedge pos_{X,U} \\
pos_{X,T \uto U}    &=& neg_{X,T} \wedge pos_{X,U} \\
\end{eqs}
&
\begin{eqs}
neg_{X,X}          &=& \false \\
neg_{X,\gvdual{X}}   &=& \true \\
neg_{X,\gvout{T}{S}} &=& pos_{X,T} \wedge neg_{X,S} \\
neg_{X,T \lto U}    &=& pos_{X,T} \wedge neg_{X,U} \\
neg_{X,T \uto U}    &=& pos_{X,T} \wedge neg_{X,U} \\
\end{eqs}
\ea
\]\normalsize

\subsection{Typing Rules}
\label{sec:mugv-typing}

\begin{figure}[float]
\scriptsize
\[
un(T \uto U)
\qquad
un(\gvservice{S})
\qquad
un(\interm)
\]

Structural rules
\begin{mathpar}
\inferrule{ }{\gvtyp{x:T}{x}{T}}

\inferrule{\gvtyp{\Phi}{M}{U} \\
           un(T)}
          {\gvtyp{\Phi,x:T}{M}{U}}

\inferrule{\gvtyp{\Phi,x:T,x':T}{M}{U} \\
           un(T)}
          {\gvtyp{\Phi,x:T}{M[x/x']}{U}}
\end{mathpar}
Lambda Rules
\begin{mathpar}
\inferrule{\gvtyp{\Phi,x:T}{M}{U}}
          {\gvtyp{\Phi}{\lambda x.M}{T \lto U}}

\inferrule{\gvtyp{\Phi}{M}{T \lto U} \\
           \gvtyp{\Psi}{N}{T}}
          {\gvtyp{\Phi,\Psi}{M\,N}{U}}

\inferrule{\gvtyp{\Phi}{M}{T \lto U} \\
           un(\Phi)}
          {\gvtyp{\Phi}{M}{T \uto U}}

\inferrule{\gvtyp{\Phi}{M}{T \uto U}}
          {\gvtyp{\Phi}{M}{T \lto U}}

\inferrule{\gvtyp{\Phi}{M}{T} \\
           \gvtyp{\Psi}{N}{U}}
          {\gvtyp{\Phi,\Psi}{(M,N)}{T \otimes U}}

\inferrule{\gvtyp{\Phi}{M}{T \otimes U} \\
           \gvtyp{\Psi,x:T,y:U}{N}{V}}
          {\gvtyp{\Phi,\Psi}{\gvlet{(x,y)}{M}{N}}{V}}
\end{mathpar}
Session Rules
\begin{mathpar}
\inferrule{\gvtyp{\Phi}{M}{S} \\
           \gvtyp{\Psi}{N}{\gvdual{S}}}
          {\gvtyp{\Phi,\Psi}{\gvlink{M}{N}}{\outterm}}

\inferrule{\gvtyp{\Phi}{M}{T} \\
           \gvtyp{\Psi}{N}{\gvout{T}{S}}}
          {\gvtyp{\Phi,\Psi}{\gvsend{M}{N}}{S}}

\inferrule{\gvtyp{\Phi}{M}{\gvin{T}{S}}}
          {\gvtyp{\Phi}{\gvreceive{M}}{T \otimes S}}

\inferrule{\gvtyp{\Phi,x:\gvdual{S}}{M}{\outterm}}
          {\gvtyp{\Phi}{\gvfork{x}{M}}{ S}}

\inferrule{\gvtyp{\Phi}{M}{\oplus \{ l_i:S_i \}_i}}
          {\gvtyp{\Phi}{\gvselect{l_i}{M}}{S_i}}

\inferrule{\gvtyp{\Phi}{M}{\with \{ l_i:S_i \}_i} \\
           \gvtyp{\Psi,x:S_i}{N_i}{T}}
          {\gvtyp{\Phi,\Psi}{\gvcase{M}{l_i\,x.N_i}_i}{T}}

%% \end{mathpar}
%% Replicated session rules
%% \begin{mathpar}
\inferrule{\gvtyp{\Phi}{M}{\gvservice{S}}}
          {\gvtyp{\Phi}{\gvrequest{M}}{S}}

\inferrule{\gvtyp{\Phi,x:\gvdual{S}}{M}{\outterm} \\
           un(\Phi)}
          {\gvtyp{\Phi}{\gvserve{x}{M}}{\gvservice{S}}}
\\
\shade{
\inferrule{\gvtyp{\Phi}{M}{\mu G}}
          {\gvtyp{\Phi}{M}{G (\mu G)}}
}

\shade{
\inferrule{\gvtyp{f:X \uto \vec{T} \lto \outterm, c:G(X), \vec{x}:\vec{T}}{M}{\outterm}}
          {\gvtyp{}{\gvfix{f}{c\:\vec{x}}{M}}{\nu G \uto \vec{T} \lto \outterm}}
}
\end{mathpar}
Admissable Session Rules
\begin{mathpar}
\shade{
\inferrule{\gvtyp{\Phi}{M}{G(\mu G)}}
          {\gvtyp{\Phi}{M}{\mu G}}
}

\shade{
\inferrule{\gvtyp{\Phi}{M}{\nu G}}
          {\gvtyp{\Phi}{M}{G(\nu G)}}
}

\shade{
\inferrule{\gvtyp{\Phi}{M}{G(\nu G)}}
          {\gvtyp{\Phi}{M}{\nu G}}
}

\end{mathpar}

%% \todo{add definition of $un$ to this figure?}

\caption{Typing Rules for \mugv}\label{fig:gv-typing}
\end{figure}

Figure~\ref{fig:gv-typing} gives the typing rules of \mugv. The structural rules account for
variables, and for weakening and contraction of unlimited types. The rules for the functional terms
are standard; note that, to account for linearity, the context is split in the rules for application
and pair introduction and elimination, and is restricted to unlimited types in the introduction of
unlimited arrows.

The rules for input, output, choice and selection are those of \citet{GayVasconcelos10}.  Following
our earlier work~\citep{LindleyM14}, we provide a term $\gvlink{M}{N}$ to implement channel
forwarding.
%% ; while a version of \tkwd{link} exists for any session type $S$, it has no generic
%% implementation in terms of other constructs of \mugv.
The \tkwd{fork} construct provides session initiation.
% ; like Wadler's GV, but unlike LAST (and much
% other work on process calculi), \mugv is deterministic.
The rule for $\gvserve{x}{M}$ parallels that
for $\tkwd{fork}$: it defines a server which replicates $M$, and returns the channel by which it may
be used (of type $\gvdual{\gvserver{S}} = \gvservice{\gvdual{S}}$).

The novelty of \mugv is in its recursive and corecursive channels; we attempt to remain close to
existing presentations of recursive session types~\citep{Honda98}.  The construct
$\gvfix{f}{c\:\vec{x}}{M}$ is used to define corecursive sessions.  We provide for the folding and
unfolding of fixed points $\mu G$ and $\nu G$, implementing the equivalences among equirecursive
types.  As we will show in \secref{cptogvpi}, only the first of these coercion rules is necessary.
The remaining rules can be derived, albeit at the cost of introducing additional computation.


% The novelty of \mugv is in its recursive and corecursive channels. The first rule allows us to
% unroll a recursive session type.
% %% The first two typing rules allow
% %% recursive session types to be used as their unfoldings.
% % SL: possibly restore this?
% %% Previous work on recursive sessions has defined typing rules up to unfolding of recursive types. We
% %% present explicit rules in order to simplify the translation into \mucp, in which these rules will
% %% correspond to terms implementing the equivalences.
% %
%  We illustrate its
% use in the remainder of this section through a series of examples.
% %
% The remaining rules are admissable (though not all depth-preserving admissable~\cite{TroelstraBook},
% because two of them can only be defined in terms of functoriality---see \secref{mucp}---which is
% type-directed). We include them as explicit rules in an effort to remain as close as possible to the
% standard notion of equirecursive session type.

%\paragraph{Syntactic Sugar.}
%
%For multi-argument functions, we write:
%\[
%\small
%  \bl
%  (T_1, \dots, T_n) \lto U \equiv T_1 \lto \dots \lto T_n \lto U \\
%  \langle T_1, T_2, \dots, T_n \rangle \uto U \equiv T_1 \uto T_2 \lto \dots \lto T_n \lto U \\
%  \el
%\]
%Note that the right-hand side of the second equation is isomorphic to $(T_1 \otimes \dots \otimes
%T_n) \uto U$.
%%


%\paragraph{Naturals.}

The remainder of the section illustrates the use of $\lrkwd$.  We will write
$\key{let}\:x=M\:\key{in}\:N$ for $(\lambda x.M)\:N$ and assume an extension of \mugv with a type of
naturals ($Nat$), literals ($0,1,\dots$), addition ($+$), and multiplication ($\times$).

% natural number ($Nat$) and Boolean ($Bool$) base types along with constants ($0,1,\dots$),
% addition ($+$) and multiplication ($\times$), boolean constants ($True, False$), and conditionals
% ($\gvifthen{M}{N}{N'}$).
%
%% This does not change the expressivity of \mugv---we could encode each of these constructs using
%% processes, along the lines illustrated later for \mucp~\secref{peano}---but does significantly
%% streamline the presentation.

\subsection{Streams}

A canonical example of a corecursive data type is a stream. Let us consider a session type for
producing a stream of naturals.
%
\small
\[
Source = \nu X.\with \{\clabel{next}: \gvout{Nat}{X}, \clabel{stop}: \outterm \}
\]
\normalsize
%
A channel of type $Source$ can either produce the next number or stop. The dual of a source is a
sink.
\small
\[
Sink = \mu X.\oplus \{\clabel{next}: \gvin{Nat}{X}, \clabel{stop}: \interm \}
\]
\normalsize
%
%Let us define a helper macro for generating the next value in a stream:
%\[\small
%\bl
%SendNext : \with \{\clabel{next}: !Nat.X, \clabel{stop}: \outterm \} \uto Nat \lto \outterm \\
%SendNext\:v\:c = \gvcase{c}{\clabel{next}\,c.\gvlet{c}{\gvsend{v}{c}}{f\:c};
%                            \clabel{stop}\,c.c}
%\el
%\]
%%
Using $\cofix$ we can define a function that sends a stream of zeros along a corecursive channel:
\small
\[
  \bl
  MakeZeros : Source \uto \outterm \\
  MakeZeros = \cofix\:f\:c = \gvcase{c}{\clabel{next}\,c.\gvlet{c}{\gvsend{0}{c}}{f\:c};
                                        \clabel{stop}\,c.c}
  \el
\]
\normalsize
If the next number is chosen, then a zero is sent along the channel and we recurse. Otherwise we
stop.
%
%To read from a source, we can use $\key{fork}$ to create a sink:
%\[\small
%\gvfork{c}{MakeZeros\:c}
%\]
%
We define a helper macro to read the next value from a stream:
\small\[
\bl
GetNext : Sink \uto Nat \otimes Sink \\
GetNext\:c = \gvreceive{(\gvselect{\clabel{next}}{c})} \\
\el
\]\normalsize
and now:
\small\[
\bl
\key{let}\:c = \gvfork{c}{MakeZeros\:c}\:\key{in} \\
\key{let}\:(x, c) = GetNext\:c\:\key{in}\:
\key{let}\:(y, c) = GetNext\:c\:\key{in}\:
\key{let}\:(z, c) = GetNext\:c\:\key{in} \\
\key{let}\:c = \gvselect{\clabel{stop}}{c}\:\key{in}\:(x, (y, z)) \\
\el
\]\normalsize
begins by forking a stream of zeros, and then reads from the corresponding sink several times,
returning $(0, (0, 0))$.

%\paragraph{Simulating Weakening.}
%We might expect to be able to use the session type $\nu X.!Nat.X$ for streams. This does not work in
%a linear setting because in order to read from the stream we would need to use the dual session type
%$\mu X.?Nat.X$. We cannot write a program that uses this session type because it would have to
%consume an infinite amount of data in order to satisfy linearity. In essence, the $\clabel{stop}$
%case allows us to simulate weakening on such a channel.

\paragraph{Productivity.}
We might expect to assign $c$ the type $\with \{\clabel{next}:\:\gvout{Nat}{Source},
\clabel{stop}:\:\outterm \}$ and $f$ the type $Source \uto \outterm$ in the body of $MakeZeros$, but
then productivity would not be assured. For example, under those typing assumptions, the following
would also be well-typed:
%
\small\[
  \cofix\:f\:c = f\:c
\]\normalsize
%
We restrict the typing rule for $\cofix$ in order to guarantee productivity. We use a fresh type
variable $X$ to abstract the recursive behavior, so the channel $c$ has type $G(X)$ (in our example
$\with \{\clabel{next}: \gvout{Nat}{X}, \clabel{stop}: \outterm \}$) instead of $G(\nu G)$, and $f$ has type
$X \uto \outterm$ instead of $\nu G \uto \outterm$. The body of $\cofix$ is thus required to provide
precisely one iteration of the recursive behavior.

\paragraph{Coinvariants.}

We allow recursive sessions to maintain internal state (a \emph{coinvariant}). In the $\cofix$
typing rule, this is captured by the additional arguments $\vec{x}$. For example, we can construct a
stream of consecutive naturals:
\small\[
\bl
  MakeNats : Source \uto \outterm \\
  MakeNats = \cofix\:nats\:c\:x = \mkwd{case}\:c\:\{
    \ba[t]{@{}l@{}l@{}}
    \clabel{next}\,c.&\,\gvlet{c}{\gvsend{x}{c}}{nats\:c\:(x+1)} \\
    \clabel{stop}\,c.&\,c\} \\
    \ea
\el
\]\normalsize
The variable $x$ tracks the next value to send to the stream, and is accordingly incremented in the
recursive call. Now, the following:
\small\[
\bl
\key{let}\:c = \gvfork{c}{MakeNats\:c\:0\:1}\:\key{in} \\
\key{let}\:(x, c) = GetNext\:c\:\key{in}\:
\key{let}\:(y, c) = GetNext\:c\:\key{in}\:
\key{let}\:(z, c) = GetNext\:c\:\key{in} \\
\key{let}\:c = \gvselect{\clabel{stop}}{c}\:\key{in}\:(x,(y,z)) \\
\el
\]\normalsize
returns $(0, (1, 2))$.
%
We can maintain coinvariants of arbitrary complexity; for example, we can define a
stream of the Fibonacci numbers as follows:
\small\[
\bl
  MakeFibs : Source \uto \outterm \\
  MakeFibs = \cofix\:fibs\;c\:m\:n = \mkwd{case}\:c\:\{
    \ba[t]{@{}l@{}l@{}}
    \clabel{next}\,c.& \gvlet{c}{\gvsend{m}{c}}{fibs\:c\:n\:(m+n)} \\
    \clabel{stop}\,c.& c\} \\
    \ea
\el
\]\normalsize

\subsection{Multi-function Calculator}

Our next example is a simple multi-function calculator. Our goal is a session that accepts a stream
of addition and multiplication requests, and can at any time provide the accumulated result.  We can
implement the provider of this session as follows:

\small\[
\bl
MakeCalc : Calc \uto Nat \lto \outterm \\
MakeCalc = \lrkwd\:calc\:c\:accum = \\
\quad
  \bl
  \mkwd{case}\:c\;\mkwd{of}\:\{
    \ba[t]{@{}l@{}l@{}}
    \clabel{add}\:c.
      & \,\mkwd{let}\:(x,c) = \gvreceive{c} \: \mkwd{in}\:
      calc\:c\:(accum + x) \\
    \clabel{mul}\:c.
      & \,\mkwd{let}\:(x,c) = \gvreceive{c}\:\mkwd{in}\:
      calc\:c\:(accum \times x) \\
    \clabel{result}\:c.
      & \,\mkwd{let}\:c = \gvsend{accum}{c}\:\mkwd{in}\:
        calc\:c\:accum \\
    \clabel{stop}\:c.& \, c \}
    \ea \\
  \el \\
\el
\]\normalsize
The type of the recursive channel is:
\small\[
 Calc = \nu X. \with \{ \clabel{add}: \gvin{Nat}{X},
                        \clabel{mul}: \gvin{Nat}{X},
                        \clabel{result}: \gvout{Nat}{X},
                        \clabel{stop}: \outterm \}.
\]\normalsize%
Here is a consumer of the service:
\small\[
\bl
  \gvlet{c}{\gvfork{c}{MakeCalc\:c\:0}}{} \\
  \gvlet{c}{\gvsend{6}{(\gvselect{\clabel{add}}{c})}}{
  \gvlet{c}{\gvsend{7}{(\gvselect{\clabel{mul}}{c})}}{}} \\
  \gvlet{(x,c)}{\gvreceive{(\gvselect{\clabel{result}}{c})}}{
  \gvlet{c}{\gvselect{\clabel{stop}}{c}}{x}}
\el
\]\normalsize
We begin by constructing an instance of the calculator with the accumulator starting at 0. %; in the
%body of \tkwd{fork}, $c$ has the $\nu$-type given above, so the result of \tkwd{fork} (called
%$c$), has type:
%\[\small
%\mu X. \oplus \{ \clabel{add}: \gvout{Nat}{X}, \clabel{mul}: \gvout{Nat}{X}, \clabel{result}: \gvin{Nat}{X}, \clabel{stop}: \interm \}.
%\]
We perform several calculations, adding 6 to the accumulator and multiplying by 7.  Finally, we
obtain the result (42) and close the channel.

\section{A Linear Logic-Based Process Calculus}\label{sec:mucp}

% \subsection{Types and Terms}

The types of \mucp are the propositions of classical linear logic, extended with type operators $F$
and fixed points $\mu F,\nu F$.
%
\small\[\begin{array}{@{}l@{~}r@{~}c@{~}l@{}}
  \text{Types} & A,B & ::= & A \otimes B \mid A \parr B \mid 1 \mid \bot \mid A \oplus B \mid A \with B \mid 0 \mid \top
       \mid   \cpquery{A} \mid \cpbang{A} \\ \shaderow
   & & \mid & {X} \mid {\cpdual{X}}
       \mid   {\mu F} \mid {\nu F} \\ \shaderow
   \text{Type Operators} & F & ::= & X.A \\
\end{array}\]\normalsize
%
(As with \mugv, we have omitted polymorphism as it is orthogonal to the rest of the development.)
If $F = X.A$, define $F(B) = A[B/X]$. The standard notion of classical linear logic duality is
extended to fixed points in the expected fashion:
\[
\ba{c}
\ba{@{}c@{\qquad}c@{\qquad}c@{\qquad}c@{}}
\begin{eqs}
  \cpdual{(A \otimes B)} &=& \cpdual{A} \parr \cpdual{B} \\
  \cpdual{(A \parr B)} &=& \cpdual{A} \otimes \cpdual{B} \\
\end{eqs}
&
\begin{eqs}
  \cpdual{1} &=& \bot \\
  \cpdual{\bot} &=& 1 \\
\end{eqs}
&
\begin{eqs}
  \cpdual{(A \oplus B)} &=& \cpdual{A} \with \cpdual{B} \\
  \cpdual{(A \with B)} &=& \cpdual{A} \oplus \cpdual{B} \\
\end{eqs}
&
\begin{eqs}
  \cpdual{\top} &=& 0 \\
  \cpdual{0} &=& \top \\
\end{eqs}
\ea
\\
\ba{@{}c@{\qquad}c@{}}
\begin{eqs}
  \cpdual{(\cpbang{A})} &=& \cpquery{\cpdual{A}} \\
  \cpdual{(\cpquery{A})} &=& \cpbang{\cpdual{A}} \\
\end{eqs}
&
\begin{eqs}
  \shaderow \cpdual{(\nu F)} &=& \mu \cpdual{F} \\
  \shaderow \cpdual{(\mu F)} &=& \nu \cpdual{F} \\
\end{eqs} \\
\ea
\ea
\]
where $X^{\perp\perp} = X$, and we define the dual of a type operator by $\cpdual{F} =
X.\cpdual{(F(\cpdual{X}))}.$ Note that, as for type operators in \mugv, $\cpdual{F(A)} =
\cpdual{F}(\cpdual{A})$.  Typing rules for \mucp terms are given in Fig.~\ref{fig:cp-typing}.  We
write $fv(P)$ for the free variables used in process $P$; in the typing rules, new bound variables
are designated $y$.

\begin{figure}[float]
\small
\vspace{-1mm}
\begin{mathpar}
\inferrule{ }{\cptyp{\link{x}{w}}{x:A,w:\cpdual{A}}}

\inferrule{\cptyp{P}{\Gamma,y:A} \\
           \cptyp{Q}{\Delta,y:\cpdual{A}}}
          {\cptyp{\cut{y}{A}{P}{Q}}{\Gamma,\Delta}}

\inferrule{ }{\cptyp{x[].0}{x:1}}

\inferrule{\cptyp{P}{\Gamma,y:A,x:B}}
          {\cptyp{x(y).P}{\Gamma,x:A \parr B}}

\inferrule{\cptyp{P}{\Gamma,y:A} \\
           \cptyp{Q}{\Delta,x:B}}
          {\cptyp{x[y].(P \mid Q)}{\Gamma,\Delta,x:A \otimes B}}

\inferrule{\cptyp{P}{\Gamma}}
          {\cptyp{x().P}{\Gamma,x:\bot}}

\inferrule{\cptyp{P}{\Gamma,x:A_i}}
          {\cptyp{\sel{x}{in_i}.P}{\Gamma,x:A_1 \oplus A_2}}

\inferrule{\cptyp{P}{\Gamma,x:A} \\
           \cptyp{Q}{\Gamma,x:B}}
          {\cptyp{\case{x}{P;Q}}{\Gamma,x:A \with B}}

\inferrule{ }{\cptyp{\case{x}{}}{\Gamma,x:\top}}

\inferrule{\cptyp{P}{\Gamma}}{\cptyp{P}{\Gamma,x:\cpquery{A}}}

\inferrule{\cptyp{P}{y:A,\Gamma}}{\cptyp{\derelict{x}{y}.P}{\Gamma,x:\cpquery{A}}}

\inferrule{\cptyp{P}{x:\cpquery{A},x':\cpquery{A},\Gamma}}{\cptyp{P[x/x']}{\Gamma,x:\cpquery{A}}}

\inferrule{\cptyp{P}{y:A,\cpquery{\Gamma}}}{\cptyp{\replicate{x}{y}.P}{\Gamma,x:\cpbang{A}}}

\shade{\inferrule{\cptyp{P}{\Gamma,x:F(\mu F)}}
                 {\cptyp{\rec{x}.P}{\Gamma,x:\mu F}}}

\shade{\inferrule{\cptyp{P}{\Gamma,y:A} \\
                  \cptyp{Q}{y:\cpdual{A},x:F(A)}}
                 {\cptyp{\corec{x}{y}{P}{Q}}{\Gamma,x:\nu F}}}
\end{mathpar}
\vspace{-1mm}
\caption{Typing Rules for \mucp}\label{fig:cp-typing}
\end{figure}

\paragraph{Structural Rules.}

\mucp has two structural rules, axiom and cut. We interpret the axiom $\link{x}{y}$ as channel
forwarding: actions on channel $x$ are mirrored on $y$, and vice versa. Thus, $x$ and $y$ must have
dual type. Cut $\cut{y}{A}{P}{Q}$ is interpreted as commuication between processes $P$ and $Q$ on
channel $y$; the duality of the typing of $y$ assures that its uses in $P$ and $Q$ are
compatible. As usual, we identify \mucp up to structural equivalence:
%
\small\begin{equations}
  \link{x}{w} &\equiv& \link{w}{x} \\
  \cut{y}{A}{P}{Q} &\equiv& \cut{y}{\cpdual{A}}{Q}{P} \\
  \cut{y}{A}{P}{\cut{z}{B}{Q}{R}} &\equiv& \cut{z}{B}{\cut{y}{A}{P}{Q}}{R}, \quad \text{if $y \not\in fv(R)$} \\
\end{equations}\normalsize%
%% Figure~\ref{fig:equivalences} gives the structural equivalences of \mucp terms.
%% The first two capture that cut is commutative and associative, while the last captures that a cut
%% against a use of the axiom rule provides channel substitution (we write $P[x/y]$ for the substution
%% of channel $y$ for channel $x$ in process $P$).

%% \begin{figure}
%% \small
%% \begin{equations}
%%   \cut{x}{A}{P}{Q} &\equiv& \cut{x}{\cpdual{A}}{Q}{P} \\
%%   \cut{x}{A}{P}{\cut{y}{B}{Q}{R}} &\equiv& \cut{y}{B}{\cut{x}{A}{P}{Q}}{R}, \quad \text{if $x \not\in FV(R)$} \\
%%   \cut{x}{A}{P}{\link{x}{y}} &\equiv& P[y/x] \\
%% \end{equations}
%% \caption{Structural Equivalences}\label{fig:equivalences}
%% \end{figure}

\paragraph{Input and Output.}

The multiplicative connectives $\parr$ and $\otimes$ are interpreted as input and output. The
process $x(y).P$ inputs channel $y$ on channel $x$, and continues as $P$. The process $x[y].(P \mid
Q)$ is interpreted as bound output: it sends a fresh variable $y$ along $x$, spawns a process $P$ in
which $y$ is used, and continues as process $Q$ in which $x$ is used.  It amounts to the
$\pi$-calculus term $(\nu y) \overline{x}(y).(P \mid Q)$. We write $x[y].P$ as syntactic sugar for
$x[y'].(\link{y}{y'} \mid P)$. The units of $\parr$ and $\otimes$, $\bot$ and $1$, are interpreted
as nullary input and nullary output, respectively.

\paragraph{Selection and Choice.}

The additive connectives $\oplus$ and $\with$ are interpreted as selection and choice. The process
$\case{x}{P_1;P_2}$ offers a choice of processes $P_1$ and $P_2$; dually, the process
$\sel{x}{in_i}.P_i$ chooses the $i$-th alternative. The unit for choice is $0$, indicating
absurdity. Note that there is no term proving $0$. The dual of absurdity is $\top$, and provides
arbitrary behavior; as there is no term proving $0$, no term relying on $\top$ can reduce.

\paragraph{Replication and Dereliction.}

The exponential connectives $!$ and $?$ in linear logic provide restricted access to the classical
rules of weakening and contraction. We interpret them as serving ($!$) and requesting ($?$)
replicated processes.
% a process with type $\cpbang{A}$ provides arbitrarily many copies of a process providing behavior
% $A$, while a process of type $\cpquery{A}$ can choose to use one, many, or none of those copies.
For a server channel of type $\cpbang{A}$, the process $P$ proving $A$ may be replicated
arbitrarily, so each channel that $P$ uses must be replicable as well. We write $\cpquery{\Gamma}$
to assert that all types in $\Gamma$ be of the form $\cpquery{B}$. As well as the introduction rule
for a request channel of type $\cpquery{A}$, there are also implicit rules for weakening and
contraction.

\paragraph{Recursion and Corecursion.}

We introduce least fixed points $\mu F$ and greatest fixed points $\nu F$ to CP, following
Baelde's~\citeyearpar{Baelde12} proof theoretic treatment of fixed points in linear logic.  The
proof rules can be understood from traditional two-sided rules for least and greatest fixed points,
combined with the duality between the fixed points. We begin with a two-sided presentation:
%
\small\begin{mathpar}
\inferrule{F(A) \vdash A \\ \Gamma, A \vdash B}{\Gamma, \mu F \vdash B}

\inferrule{\Gamma, F (\nu F) \vdash B}{\Gamma, \nu F \vdash B}
\\
\inferrule{\Gamma \vdash F (\mu F)}{\Gamma \vdash \mu F}

\inferrule{A \vdash F(A) \\ \Gamma \vdash A}{\Gamma \vdash \nu F}
\end{mathpar}\normalsize%
Functional programmers may recognize the first as the typing rule of a fold, and the fourth as the
typing rule of an unfold. We adapt the above rules to a one sided presentation as follows.
%
(As $\Gamma$ denotes any context, we write $\Gamma$ instead of $\cpdual{\Gamma}$).
%
\small\begin{mathpar}
\inferrule{\vdash \cpdual{F}(\cpdual{A}),A \\ \vdash \Gamma,\cpdual{A},B}{\vdash \Gamma,\nu \cpdual{F},B}

\inferrule{\vdash \Gamma, \cpdual{F}(\mu \cpdual{F}), B}{\vdash \Gamma, \mu \cpdual{F}, B}
\\
\inferrule{\vdash \Gamma, F (\mu F)}{\vdash \Gamma, \mu F}

\inferrule{\vdash \cpdual{A}, F(A) \\ \vdash \Gamma, A}{\vdash \Gamma, \nu F}
\end{mathpar}\normalsize%
However, now we can observe that $\Gamma,B$ is itself an instance of a context, and $\cpdual{F}$ a
type operator, and so the top-right rule is just an instance of the bottom-left rule, and the
top-left rule is just an instance of the bottom-right rule.
%% %
%% % SL: potentially reclaim space by deleting the following two rules as they already appear above
%% %
%% \small\begin{mathpar}
%% \inferrule{\vdash \Gamma, F (\mu F)}{\vdash \Gamma, \mu F}
%%
%% \inferrule{\vdash \cpdual{A}, F(A) \\ \vdash \Gamma, A}{\vdash \Gamma, \nu F}
%% \end{mathpar}\normalsize%
The bottom rules are the typing rules for the \mucp terms $\rec{x}.P$ and $\corec{x}{y}{P}{Q}$. As
in \mugv, \tkwd{corec} terms maintain a coinvariant $y$, of type $A$. The coinvariant can be seen as
being sent from $P$ to $Q$; thus, its type is dual in $P$ and $Q$. As carried types are not dual in
\mugv, no corresponding duality appears in the typing rule for $\lrkwd$.

\subsection{Cut Elimination}

\begin{figure}[float]
\vspace{-2mm}
\small
\begin{equations}
\cut{x}{A}{\link{w}{x}}{P}
  &\Longrightarrow& P[w/x] \\
\cut{x}{A \otimes B}{x[y].(P \mid Q)}{x(y).R}
  &\Longrightarrow&
    \cut{y}{A}{Q}{\cut{x}{B}{P}{R}} \\
\cptyp{\cut{x}{1}{x[].0}{x().P}}{\Gamma}
  &\Longrightarrow&
    P \\
\cut{x}{A \oplus B}{\sel{x}{in_i}.P}{\case{x}{Q_1; Q_2}}
  &\Longrightarrow&
    \cut{x}{A}{P}{Q_i} \\
\cut{x}{\cpbang{A}}{\replicate{x}{y}.P}{\derelict{x}{y}.Q}
  &\Longrightarrow&
    \cut{y}{A}{P}{Q} \\
\cut{y}{\cpbang{A}}{\replicate{x}{y}.P}{Q}
  &\Longrightarrow&
     Q, \qquad x \notin fv(Q) \\
\cut{x}{\cpbang{A}}{\replicate{x}{y}.P}{Q[x/x']}
  &\Longrightarrow&
    \cut{x}{\cpbang{A}}{\replicate{x}{y}.P}{\cut{x'}{\cpbang{A}}{\replicate{x'}{y}.P}{Q}} \\ \shaderow
\key{new}\:x\: %{\nu F}
  (\key{corec}^F x\langle y \rangle(P, Q) \mid \rec{x}.R)
  &\Longrightarrow&
    \cut{y}{B}{P}{\cut{x}{F(B)}{Q}{\cut{x'}{F(\nu F)}{Q'}{R[x'/x]}}} \\ \shaderow
&& \hspace{-1em}\text{where }Q'\!= \map{F}{x,x'}{\key{corec}^F x'\!\langle y \rangle(\link{x}{y}, Q[x'/x])} \\
\end{equations}%
\caption{Principal Cut Elimination Rules}\label{fig:beta-reduction}
\vspace{-2mm}
\end{figure}



\begin{figure}[float]
\small
\begin{equations}
  \map{X.C}{x,y}{P} &=& \link{x}{y}, \hfill\text{if $X$ is not free in $C$} \\[1ex]
  \map{X.X}{x,y}{P} &=& P \\[1ex]
  \map{X.C_1 \otimes C_2}{x,y}{P} &=& x(x').y[y'].(\map{X.C_1}{x',y'}{P[x'/x,y'/y]} \mid \map{X.C_2}{x,y}{P}) \\[1ex]
  \map{X.C_1 \oplus C_2}{x,y}{P} &=&
    \case{x}{\sel{y}{in_1}.\map{X.C_1}{x,y}{P}; \sel{y}{in_2}.\map{X.C_2}{x,y}{P}} \\[1ex]
  \map{X.\cpquery{C}}{x,y}{P} &=& \replicate{x}{x'}.\derelict{y}{y'}.P[x'/x,y'/y] \\[1ex]
  \map{X.\mu F}{x,y}{P} &=&
    \key{corec}^F x\langle y' \rangle(\link{y}{y'}, \rec{y'}.\map{X.F (\mu F)}{x,y'}{P[y'/y]}) \\
\end{equations}%
%% \begin{equations}
%%   \map{X.C}{x,w}{Q} &=& \link{x}{w} \\
%%   \map{X.X}{x,w}{Q} &=& Q \\
%%   \map{X.C_1 \otimes C_2}{x,w}{Q} &=& w(z).x[y].(\map{X.C_1}{y,z}{Q[y/x,z/w]} \mid \map{X.C_2}{x,w}{Q}) \\
%%   \map{X.C_1 \oplus C_2}{x,w}{Q} &=&
%%     \case{w}{\sel{x}{in_1}.\map{X.C_1}{x,w}{Q}; \sel{x}{in_2}.\map{X.C_2}{x,w}{Q}} \\
%%   \map{X.\cpquery{C}}{x,w}{Q} &=& \replicate{w}{w'}.\derelict{x}{x'}.Q[x'/x,w'/w] \\
%%   \map{X.\mu F'}{x,w}{Q} &=& \corec{w}{y}{\nu(\cpdual{C}(A))}{\link{x}{y}}{\rec{y}.\map{X.F' (\mu F')}{y,w}{Q[y/x]}}
%% \end{equations}%
\vspace{-1mm}
\caption{Definition of $\mapname$ for Positive Combinators}\label{fig:map}
\end{figure}

Cut elimination corresponds to synchronous process reduction.  The principal cut reductions are
given in Fig.~\ref{fig:beta-reduction}. The majority of these are standard; for instance, cut
reduction of $\with$ against $\oplus$ corresponds to picking one of the offered alternatives.  Cut
reduction for fixed points corresponds to unrolling one iteration from the \tkwd{corec} term,
directed by the type of the fixed point operator $F$.  It depends on a proof construction known as
functoriality, which derives the following proof rule for any type operator $F$: \small\[
\inferrule{\vdash A,B}{\vdash \cpdual{F}(A),F(B)}
\]\normalsize
We call the term implementing this construction $\mapname$ by analogy with a similar construct in
functional programming.
%
%% : taking $C = \cpdual{B}$, the above proof rule gives a transformation from a
%% proof of $C \lto A$ to one of $F(C) \lto F(A)$.
%
The positive cases of $\mapname$ are given in Fig.~\ref{fig:map}; the remaining cases are obtained
by exchanging channels $x$ and $y$.

\begin{lemma}
  If $\cptyp{P}{x:A,y:B}$ then \(\cptyp{\map{F}{x,y}{P}}{x:\cpdual{F}(A),y:F(B)}.\)
\end{lemma}

\begin{figure}[float]
\small
\begin{equations}
  \cut{z}{A}{x[y].(P \mid Q)}{R} &\Longrightarrow& x[y].(\cut{z}{A}{P}{R} \mid Q), \qquad \text{if $z \not\in fv(Q)$} \\
  \cut{z}{A}{x[y].(P \mid Q)}{R} &\Longrightarrow& x[y].(P \mid \cut{z}{A}{Q}{R}), \qquad \text{if $z \not\in fv(P)$} \\
  \cut{z}{A}{x(y).P}{Q} &\Longrightarrow& x(y).\cut{z}{A}{P}{Q} \\
  \cut{z}{A}{\sel{x}{in_i}.P}{Q} &\Longrightarrow& \sel{x}{in_i}.\cut{z}{A}{P}{Q} \\
  \cut{z}{A}{\case{x}{P;Q}}{R} &\Longrightarrow& \case{x}{\cut{z}{A}{P}{R}; \cut{z}{A}{Q}{R}} \\
  \cut{z}{} {\derelict{x}{y}.P}{Q} &\Longrightarrow& \derelict{x}{y}.\cut{z}{}{P}{Q} \\
  \cut{z}{} {\replicate{x}{y}.P}{Q} &\Longrightarrow& \replicate{x}{y}.\cut{z}{}{P}{Q} \\ \shaderow
  \cut{z}{A}{\rec{x}.P}{Q} &\Longrightarrow& \rec{x}.\cut{z}{A}{P}{Q} \\ \shaderow
  \cut{z}{A}{\corec{x}{y}{P}{Q}}{R} &\Longrightarrow& \corec{x}{y}{\cut{z}{A}{P}{R}}{Q} \\
\end{equations}
\caption{Commuting Conversions}\label{fig:commuting}
\end{figure}

The commuting conversions push communication under process prefixes, and are given in
Fig.~\ref{fig:commuting}.  We can show that cut reduction preserves typing.

\begin{theorem}
  If $\cptyp{P}{\Gamma}$ and $P \Longrightarrow Q$, then $\cptyp{Q}{\Gamma}.$
\end{theorem}

Define $\Longrightarrow^\star$ to be the reflexive, transitive closure of $\equiv\Longrightarrow\equiv$.

\begin{theorem}\label{thm:cut-reduction}
  If $\cptyp{P}{\Gamma}$, then there is a $Q$ such that $P \Longrightarrow^\star Q$ and the final
  rule in the derivation of $Q$ is not an instance of cut.
\end{theorem}
As cuts are interpreted as communication, elimination of cuts corresponds to deadlock and livelock
freedom.  Note that while we commute cuts under prefixes, we do not perform cut reduction under
prefixes.  This corresponds to the usual notions of process communication.  Were we to extend our
reduction rules with congruence rules for each operator, we could then extend
Theorem~\ref{thm:cut-reduction} to show elimination of all cuts in a well-typed \mucp term.

\subsection{Streams}

As we did for \mugv, we assume that our language is extended with constants implementing unlimited
natural numbers. In particular, we will assume there is some proposition $Nat$, such that
$\cpdual{Nat}$ is subject to contraction and weakening, and terms:
%
\small\[
\begin{eqs}
Zero_x &\vdash& x:Nat \\
Inc_{y,x} &\vdash& y:\cpdual{Nat},x:Nat \\
\end{eqs}
\]\normalsize
providing zero and successor.

We can use \mucp fixed points to encode streams of naturals.
\small\begin{equations}
  Sink &=& \mu X. \oplus \{ \clabel{next}: \cpdual{Nat} \parr X, \clabel{stop}: \bot \}, \\
  Source &=& \nu X. \with \{ \clabel{next}: Nat \otimes X, \clabel{stop}: 1 \} \\
\end{equations}\normalsize%

%% Note that, following the typical treatment of duality in linear logic, we have that
%% $\cpdual{(Source(A))} = Sink(\cpdual{A})$.

We can define a process which generates a stream of zeros. In this example, we make no use of the
coinvariant, and so assign it the type $1$:
\small\[\begin{eqs}
  Zeros_y &\vdash& y:Source \\
  Zeros_y &=& \corec{y}{z}{z[].0}{z().\case{y}{\clabel{next}: y[x].(Zero_x | y[].0); \clabel{stop}: y[].0}}.
\end{eqs}\]\normalsize
Now we define a process which generates a stream of naturals. As in the corresponding \mugv example,
we use the coinvariant represent the next number in the stream.
%
\small\[
\bl
  Nats_y \vdash y:Source \\x
  Nats_y = \lrkwd \: y \langle z \rangle (Zero_z,
    \key{case}\:y \:\{
       \bl
       \clabel{next}: y[x].(\link{z}{x} \mid \cut{w}{}{Inc_{z,w}}{\link{w}{y}}) \\
       \clabel{stop}: y[].0\}) \\
       \el \\
\el
\]\normalsize
%
In the $\clabel{next}$ case, we rely on contraction to copy the coinvariant $z$.  We then send one
copy along the channel $y$ and increment the other giving $w$, which we use to re-establish the
coinvariant. In the $\clabel{stop}$ case, we rely on weakening for $\cpdual{Nat}$ to dispose of the
coinvariant.

The following receives the first three numbers from the stream of naturals and sends them on $z$;
thus, $z$ has type $\cpdual{Nat} \otimes (\cpdual{Nat} \otimes \cpdual{Nat})$.
%
\small\[
\bl
  \mkwd{new}\:y\:(Nats_y \mid \bl
    \rec{y}.\sel{y}{next}.y(a). \\
    \rec{y}.\sel{y}{next}.y(b). \\
    \rec{y}.\sel{y}{next}.y(c). \\
    \rec{y}.\sel{y}{stop}.y(). \\
    z[a].z[b].\link{z}{c}) \el
\el\]\normalsize %

\section{Relating \mugv and \mucp}\label{sec:translation}

In our previous work~\citep{LindleyM14} we give translations between CP and HGV, an extension of GV,
corresponding to \mugv without recursive session types. In this section, we extend these
translations to incorporate recursion.

\subsection{Translation from \mugv to \gvpi}\label{sec:gvtogvpi}

Following our previous work, we factor the translation of \mugv into \mucp through an intermediate
translation. The language \gvpi is the restriction of \mugv to session types; that is, \mugv without
$\lto$, $\uto$, or $\otimes$. In order to avoid $\otimes$, we permit $\gvreceive{M}$, only fused
with a pair elimination $\gvlet{(x, y)}{\gvreceive{M}}{N}$. We can simulate all non-session types as
session types via a translation from \mugv to \gvpi.  The translation on types is exactly as in our
previous work. It is given by the homomorphic extension of the following equations:
%\[
%\ba{@{}rclcl@{}}
%\topi{T \lto U}    &=& \gvdual{\gvin{\gvdual{\topi{T}}}{\topi{U}}}
%                   &=& \gvout{\topi{T}}{\gvdual{\topi{U}}} \\
%\topi{T \uto U}    &=& \gvdual{\gvserver{(\gvin{\topi{\gvdual{T}}}{\topi{U}})}}
%                   &=& \gvservice{(\gvout{\topi{T}}{\gvdual{\topi{U}}})} \\
%\topi{T \otimes U} &=& \gvdual{\gvout{\gvdual{T}}{\topi{U}}}
%                   &=& \gvin{\gvdual{\topi{T}}}{\gvdual{\topi{U}}} \\
%\ea
%\]
\small\[
\ba{@{}c@{}}
\topi{T \lto U} = \gvout{\topi{T}}{\topi{U}} \qquad
\topi{T \uto U} = \gvservice{(\gvout{\topi{T}}{\topi{U}})} \\
\topi{T \otimes U} = \gvin{\topi{T}}{\topi{U}} \\
\ea
\]\normalsize
Each target type is the interface to the simulated source type. A
linear function is simulated by input on a channel; its interface is
output on the other end of the channel. An unlimited function is
simulated by a server; its interface is the service on the other end
of that channel. A tensor is simulated by output on a channel; its
interface is input on the other end of that channel. This duality
between implementation and interface explains the dualization of types in
Wadler's original CPS translation from GV to CP.
%
To translate away the arrows in the $\lrkwd$ rule, we adopt a simplified session-oriented variant of
$\lrkwd$ for \gvpi.
%
\small\begin{mathpar}
\inferrule{\gvtyp{p:\gvservice{(\gvout{X}{\gvout{T}{\outterm}})}, c:G(X), x:T}{M}{\outterm}}
          {\gvtyp{\Phi}{\gvfix{p}{c\:x}{M}}{\gvservice{(\gvout{\nu G}{\gvout{T}{\outterm}})}}}
\end{mathpar}\normalsize%
%
This rule takes advantage of the translation of functions given by $\topi{-}$, and simulates
multiple arguments using $\otimes$.

\begin{figure}[float]
\vspace{-2mm}
\small
\begin{equations}
\topi{\lambda x.M} &=& \gvfork{z}{\gvlet{(x, z)}{\gvreceive{z}}{\gvlink{\topi{M}}{z}}} \\
\topi{L\,M} &=& \gvsend{\topi{M}}{\topi{L}} \\
\topi{M, N} &=&
  \gvfork{z}
    {\gvlink{(\gvsend{\topi{M}}{z})}{\topi{N}}} \\
\topi{\gvlet{(x, y)}{M}{N}} &=&
    \gvlet{(x, y)}{\gvreceive{\topi{M}}}{\topi{N}} \\
\topi{L : T \uto U} &=&
  \gvserve{z}{\gvlink{\topi{L}}{z}} \\
\topi{L : T \lto U} &=& \gvrequest{\topi{L}} \\
\topi{\gvreceive{M}} &=& \topi{M}
\\ \shaderow
\topi{\gvfix{f}{\!c\,\vec{x}}{M}} &=&
   \cofix\:p\:c\:z =
     \bl
     \key{let}\:f = \lambda\,c\,\vec{x}.\gvsend{\vec{x}}{(\gvsend{c}{(\gvrequest{p})})}\:\key{in} \\
     \gvlet{\vec{x}}{z}{\topi{M}} \\
     \el \\
%% \topi{\gvfix{f}{\!c\,\vec{x}}{M}} &=&
%%   \gvfix{p}{c\,z}{\gvlet{\vec{x}}{z}{\topi{M[L/f]}}} \\ \shaderow
%% && \text{where }L = \lambda\,c\,\vec{x}.\gvsend{c}{(\gvsend{\vec{x}}{(\gvrequest{p})})} \\
\end{equations}%
\vspace{-2mm}
\caption{Translation of \mugv Terms to \gvpi}\label{fig:togvpi}
\end{figure}

The translation on terms is given by the homomorphic extension of the equations in
Fig.~\ref{fig:togvpi}.  Formally, this is a translation from derivations to terms. We write type
annotations to indicate $\to$ introduction and elimination.
% For all other cases, it is unambiguous to give the translation
% on plain term syntax. Each introduction form translates to an interface $\gvfork{z}{M}$ of type
% $\gvdual{S}$, where $M : \outterm$ provides the implementation, with $z : S$ bound in $M$.
%
The only new case is that for $\key{corec}$. We collect the arguments into a tuple, and simulate the
interface to the arrows using session operations as in the rest of the $\topi{-}$ translation.
%
We use the obvious encodings for $n$-ary let binding, lambdas, and send.
%
We write $\topi{\Phi}$ for the pointwise extension of $\topi{T}$.
%% It is straightforward to verify that our translation preserves typing.
\begin{theorem}
If $\gvtyp{\Phi}{M}{T}$ then $\gvtyp{\topi{\Phi}}{\topi{M}}{\topi{T}}$.
\end{theorem}

\subsection{Translation from \gvpi to \mucp}\label{sec:gvpitocp}

\begin{figure}[float]
\vspace{-2ex}
\small
\begin{equations}
%% \left\llbracket \inferrule{\gvtyp{\Phi}{N}{S}}{\gvtyp{\Phi,x:\interm}{N}{S}} \right\rrbracket\!\!z &=&
%%   \inferrule
%%     {\cptyp{\tocp{N}z}{\tocp{\Phi},z:\cpdual{\tocp{S}}}}
%%     {\cptyp{x().\tocp{N}z}{\tocp{\Phi},x:\bot,z:\cpdual{\tocp{S}}}}
%% \\[3ex]
%% \left\llbracket \inferrule{\gvtyp{\Phi,x:\interm,x':\interm}{N}{S}}
%%                           {\gvtyp{\Phi,x:\interm}{N[x/x']}{S}} \right\rrbracket \!\!z &=&
%%   \inferrule
%%     {\cptyp{\tocp{N}z}{\tocp{\Phi},x:\bot,x':\bot,z:\cpdual{\tocp{S}}}}
%%     {\cptyp{\cut{x'}{}{\tocp{N}z}{x'[].0}}{\tocp{\Phi},x:\bot,z:\cpdual{\tocp{S}}}}
%% \\[3ex]
%% \tocp{\gvtyp{\Phi,x:\interm}{N}{S}}z &=& x().\tocp{N}z
%%   \quad \hspace{17mm} \text{($\interm$ weakening)} \\
%% \tocp{\gvtyp{\Phi,x:\interm}{N[x/x']}{S}}z &=& \cut{x'}{}{\tocp{N}z}{x'[].0}
%%   \quad \text{($\interm$ contraction)} \\
\tocp{\gvtyp{\Phi,x:\interm}{N}{S}}z &=& x().\tocp{\gvtyp{\Phi}{N}{S}}z \\
\tocp{\gvtyp{\Phi,x:\interm}{N[x/x']}{S}}z &=&
  \cut{x'}{}{\tocp{\gvtyp{\Phi,x:\interm,x':\interm}{N}{S}}z}{x'[].0} \\
\tocp{x}z &=& \link{x}{z} \\
\tocp{\gvfork{x}{M}}z &=& \cut{x}{}{\cut{y}{}{\tocp{M}y}{y[].0}}{\link{x}{z}} \\
\tocp{\gvlink{M}{N}}z &=& z().\cut{x}{}{\tocp{M}x}{\tocp{N}x} \\
\tocp{\gvsend{M}{N}}z &=& \cut{x}{}{x[y].(\tocp{M}y \mid \link{x}{z})}{\tocp{N}x} \\
\tocp{\gvlet{(x,y)}{\gvreceive{M}}{M}}z &=& \cut{y}{}{\tocp{M}y}{y(x).\tocp{N}z} \\
\tocp{\gvselect{l}{M}}z &=& \cut{x}{}{\tocp{M}x}{x[l].\link{x}{z}} \\
\tocp{\gvcase{M}{l_i\,x.N_i}_i}z &=&  \cut{x}{}{\tocp{M}x}{\case{x}{l_i.\tocp{N_i}z}_i} \\
\tocp{\gvrequest{M}}z &=& \cut{x}{}{\tocp{M}x}{\derelict{x}{y}.\link{y}{z}} \\
\tocp{\gvserve{y}{M}}z &=& \replicate{z}{y}.\cut{x}{}{\tocp{M}x}{x[].0} \\[1ex] \shaderow
\tocp{\gvtyp{\Phi}{M}{G(\mu G)}}z &=&
  \cut{y}{\nu \tocp{G}}{\tocp{\gvtyp{\Phi}{M}{\mu G}}y}{\rec{y}.\link{y}{z}} \\ \shaderow
\tocp{\gvfix{p}{c\:x}{M}}z &=&
\replicate{z}{y}.y(c).y(x).y().
 \corec{c}{w}{w[x].w[].0}{\\ \shaderow
&& \quad \cut{p}{}{\replicate{p}{y}.y(c).y(x).y().c[x].c[].0}{w(x).\tocp{M}w}} \\[1ex]
%%\end{equations}%
%%\vspace{-2ex}
%% \[
%% \shade{
%% \tocpbig{\inferrule{\gvtyp{\Phi}{M}{\mu G}}{\gvtyp{\Phi}{M}{G (\mu G)}}}\!\!z =
%%   \cut{y}{\nu \tocp{G}}{\tocp{\gvtyp{\Phi}{M}{\mu G}}y}{\rec{y}.\link{y}{z}}
%% }
%% \]
%% \[
%% \shade{
%% \bl
%% \tocp{\gvfix{p}{c\:x}{M}}z =
%% \replicate{z}{y}.y(c).y(x).y(). \\
%% \quad \corec{c}{w}{w[x].w[].0}{\cut{p}{}{\replicate{p}{y}.y(c).y(x).y().c[x].c[].0}{w(x).\tocp{M}w}} \\
%% \el
%% }
%% \]
%%\begin{equations}
\shaderow
\tocp{\gvtyp{\Phi}{M}{\mu G}}z &=&
\key{new}\:y\:
  \bl
  (
       \tocp{\gvtyp{\Phi}{M}{G(\mu G)}}y \\
  \mid \corec{z}{x}
             {\link{y}{x}}
             {\map{G}{z,x}{\rec{x}.\link{x}{z}}}) \\
  \el \\ \shaderow
\tocp{\gvtyp{\Phi}{M}{G(\nu G)}}z &=&
\key{new}\:y\:
  \bl
  (
       \tocp{\gvtyp{\Phi}{M}{\nu G}}y \\
  \mid \corec{y}{x}
             {\link{y}{x}}
             {\map{G}{z,x}{\rec{x}.\link{x}{z}}}) \\
  \el \\ \shaderow
\tocp{\gvtyp{\Phi}{M}{\nu G}} &=&
  \cut{y}{\nu \tocp{G}}{\tocp{\gvtyp{\Phi}{M}{G(\nu G)}}y}{\rec{z}.\link{y}{z}} \\
\end{equations}%
%% \[
%% \shade{
%% \tocpbig{\inferrule{\gvtyp{\Phi}{M}{G(\mu G)}}{\gvtyp{\Phi}{M}{\mu G}}}\!\!z =
%% \key{new}\:y\:
%%   \bl
%%   (    %{\tocp{G}(\mu \tocp{G})}
%%        {\tocp{\gvtyp{\Phi}{M}{G (\mu G)}}}y \\
%%   \mid \corec{z}{x}{\tocp{G}(\mu \tocp{G})}
%%              {\link{y}{x}}
%%              {\map{G}{x,z}{\rec{x}.\link{x}{z}}}) \\
%%   \el \\[-1ex]}
%% \]
%% \[
%% \shade{
%% \tocpbig{\inferrule{\gvtyp{\Phi}{M}{\nu G}}{\gvtyp{\Phi}{M}{G(\nu G)}}}\!\!z =
%% \key{new}\:y\:
%%   \bl
%%   (    %{\tocp{G}(\mu \tocp{G})}
%%        {\tocp{\gvtyp{\Phi}{M}{\nu G}}}y \\
%%   \mid \corec{y}{x}{\tocp{\nu G}}
%%              {\link{y}{x}}
%%              {\map{G}{x,z}{\rec{x}.\link{x}{z}}}) \\
%%   \el \\[-1ex]}
%% \]
%% \[
%% \shade{
%% \tocpbig{\inferrule{\gvtyp{\Phi}{M}{G (\nu G)}}{\gvtyp{\Phi}{M}{\nu G}}}\!\!z =
%%   \cut{y}{\nu \tocp{G}}{\tocp{\gvtyp{\Phi}{M}{G (\nu G)}}y}{\rec{z}.\link{y}{z}}
%% }
%% \]
%% \[
%% \shade{
%% \bl
%% \left\llbracket
%% \inferrule{\gvtyp{p:\gvservice{(\gvout{T}{\gvout{X}{\outterm}})},c:G(X),x:T}{M}{\outterm}}
%%           {\gvtyp{}{\gvfix{p}{c\:x}{M}}{\gvservice{(\gvout{\nu G}{\gvout{T}{\outterm}})}}}
%% \right\rrbracket\!\!z = \\
%% \replicate{z}{y}.y(c).y(x).y(). \\
%% \quad \corec{c}{w}{}{w[x].w[].0}{\cut{p}{}{\replicate{p}{y}.y(c).y(x).y().c[x].c[].0}{w(x).\tocp{M}w}} \\
%% \el}
%% \]
\vspace{-2ex}
\caption{Translation of \gvpi Terms into \mucp}\label{fig:tomucp}
\end{figure}

We now give a translation from \gvpi to CP. Post composing this with the embedding of \mugv in \gvpi
yields a semantics for \mugv. For uniformity, we assume the obvious encodings of $n$-ary $\oplus$,
$\with$, and $\key{case}$ in CP. The translation on session types is as follows:
\small\[
\ba{@{}c@{\qquad}c@{\qquad}c@{}}
\begin{eqs}
\tocp{\gvout{T}{S}}        &=& \cpdual{\tocp{T}} \otimes \tocp{S} \\
\tocp{\gvin{T}{S}}         &=& \tocp{T} \parr \tocp{S} \\
\tocp{\outterm}            &=& 1 \\
\tocp{\interm}             &=& \bot \\
\end{eqs}
&
\begin{eqs}
\tocp{\oplus \{l_i:S_i \}_i} &=& \oplus \{l_i:\tocp{S_i}\}_i \\
\tocp{\with \{l_i:S_i \}_i}  &=& \with \{l_i:\tocp{S_i}\}_i \\
\tocp{\gvservice{S}}       &=& \cpquery{\tocp{S}} \\
\tocp{\gvserver{S}}        &=& \cpbang{\tocp{S}} \\
\end{eqs}
&
\begin{eqs}\shaderow
\tocp{X}                   &=& X \\ \shaderow
\tocp{\gvdual{X}}          &=& \cpdual{X} \\ \shaderow
\tocp{\nu G}                &=& \nu\tocp{G} \\ \shaderow
\tocp{\mu G}                &=& \mu\tocp{G} \\ \shaderow
\tocp{X.S}                  &=& X.\tocp{S} \\
\end{eqs}\\
\ea
\]\normalsize
The translation is homomorphic except for output, where the argument type is dualised. This accounts
for the discrepancy between $\gvdual{\gvout{T}{S}} = \gvin{T}{\gvdual{S}}$ and $\cpdual{(A \otimes
  B)} = \cpdual{A} \parr \cpdual{B}.$
%
The translation on terms (Fig.~\ref{fig:tomucp}) is formally specified as a CPS translation on
derivations as in Wadler's work. We abbreviate the derviation by its final judgement in the
translations of weakening and contraction for $\interm$, and for rolling and unrolling of recursive
session types $\nu G$ and $\mu G$, as these steps are implicit in the syntax of \mugv terms, but
explicit in \mucp. The other constructs depend only on the immediate syntactic structure, so we
abbreviate their translations as mappings on plain terms. The majority of translations are as in our
previous work. The folding and unfolding of least fixed points in GV can be translated to cuts
against the CP proofs of the corresponding equivalences.  Note that only one of the unfoldings (that
from $\mu G$ to $G (\mu G)$) corresponds directly to a term of \mucp; the remainder correspond to
derivations in \mucp, an observation that motivates our argument (in \secref{cptogvpi}) that they
are also derivable in \mugv. The translation of $\cofix$ is a corecursive process in which the \mugv
coinvariant of type $T$ is represented as a \mucp coinvariant of type $\tocp{T} \otimes 1$.  We
initially read the coinvariant $x$ from a channel $w$, and provide a channel $p$ which abstracts
re-establishing the coinvariant at the end of each iteration.

%% SL: now mention this earlier
%%
%% In both, we rely on syntactic sugar for output: $x[y].P \equiv x[y'].(\link{y}{y'} \mid P)$.

% ; for example, unfolding the GV session type $\mu G$ to $G
% (\mu G)$ corresponds to the CP proof that $\nu F \lto F(\mu F)$.
%% The folding and unfolding of recursive session types in GV can be translated to cuts against the CP
%% proofs of the corresponding equivalences; for example, unfolding the GV session type $\mu G$ to $G
%% (\mu G)$ corresponds to the CP proof that $\nu F \lto F(\mu F)$. Note the parallels between the
%% first two and last two cases: this aligns with the derivation of the rules for $\mu$ and $\nu$ in
%% \mucp.
%% \begin{gather*}
%% \tocpbig{\inferrule{\gvtyp{\Phi}{M}{\mu G}}{\gvtyp{\Phi}{M}{G (\mu G)}}} z =
%%   \cut{y}{\nu \tocp{G}}{\tocp{\gvtyp{\Phi}{M}{\mu G}}y}{\rec{y}.\link{y}{z}} \\[3ex]
%% \tocpbig{\inferrule{\gvtyp{\Phi}{M}{G(\nu G)}}{\gvtyp{\Phi}{M}{\nu G}}} z =
%%   \cut{y}{\nu \tocp{G}}{\tocp{\gvtyp{\Phi}{M}{G(\nu G)}}y}{\rec{z}.\link{y}{z}} \\[3ex]
%% \tocpbig{\inferrule{\gvtyp{\Phi}{M}{G(\mu G)}}{\gvtyp{\Phi}{M}{\mu G}}} z =
%% \cut{y}{\tocp{G}(\mu \tocp{G})}{\tocp{\gvtyp{\Phi}{M}{G (\mu G)}}}
%%        {\corec{z}{x}{\tocp{G}(\mu \tocp{G})}
%%               {\link{y}{x}}
%%               {\map{G}{x,z}{\rec{x}.\link{x}{z}}}}
%% \\[3ex]
%% \tocpbig{\inferrule{\gvtyp{\Phi}{M}{\nu G}}{\gvtyp{\Phi}{M}{G (\nu G)}}} z =
%% \cut{y}{\mu \tocp{G}}{\tocp{\gvtyp{\Phi}{M}{\nu G}}}
%%        {\corec{y}{x}{\cpdual{\tocp{G}}(\nu \cpdual{\tocp{G}})}
%%               {\link{z}{x}}
%%               {\map{G}{x,y}{\rec{x}.\link{x}{y}}}}
%% \end{gather*}
%
%

\begin{theorem}
  If $\gvtyp{\Phi}{M}{T}$, then $\cptyp{\tocp{M}z}{\tocp{\Phi},z:\cpdual{\tocp{T}}}$.
\end{theorem}
As we have already concluded that \mucp is deadlock and livelock free
(Theorem~\ref{thm:cut-reduction}), and we now have that all \mugv terms correspond to \mcup
derivations, we can also conclude that \mugv is deadlock and livelock free.  Note that the type
environment $\Phi$ is not dual in the result of the translation.  This reflects the different
interpretations of types in \mucp and \mugv: a \mugv type $\gvout{T}{S}$ designates a channel that
expects output, whereas the \mucp type $T \otimes S$ designates a process that performs output.

\subsection{Translating from \mucp to \gvpi}\label{sec:cptogvpi}

\begin{figure}[float]
\small
\begin{equations}
  \togv{\cut{x}{}{P}{Q}} &=&
    \gvlet{x}{\gvfork{x}{\togv{P}}}{\togv{Q}} \\
  \togv{\link{x}{y}} &=& \gvlink{x}{y} \\
  \togv{x[y].(P \mid Q)} &=&
    \gvlet{x}{\gvsend{(\gvfork{y}{\togv{P}})}{x}}{\togv{Q}} \\
  \togv{x(y).P} &=&
    \gvlet{(y,x)}{\gvreceive{x}}{\togv{P}} \\
  \togv{x[].0} &=& x \\
  \togv{x().P} &=& \togv{P} \\
  \togv{\sel{x}{\mathit{l}}.P} &=&
    \gvlet{x}{\gvselect{l}{x}}{\togv{P}} \\
  \togv{\case{x}{l_i.P_i}_i} &=&
    \gvcase{x}{l_i.\togv{P_i}}_i \\
  \togv{\derelict{s}{x}.P} &=&
    \gvlet{x}{\gvrequest{s}}{\togv{P}} \\
  \togv{\replicate{s}{x}.P} &=&
    \gvlink{s}{(\gvserve{x}{\togv{P}})} \\  \shaderow
  \togv{\rec{x}.P} &=& \togv{P} \\ \shaderow
  \togv{\corecf{F}{c}{x}{P}{Q}} &=&
    \key{send}\:c\:(
      \key{send}\:
         \bl
         (\gvfork{x}{\togv{P}}) \\
         (\gvrequest{(\gvfix{p}{c\,x}{Q_{F,p,c,x}})})) \\
         \el \\ \shaderow
\multicolumn{3}{@{}l@{}}
{\qquad\text{where }
  Q_{F,p,c,x} =
    \gvlet{c'}{\gvfork{c}{\togv{Q}}}
          {\togv{\map{F}{c',c}{\derelict{p}{z}.z[c].z[c'].z[].0}}}}
\end{equations}%
\caption{Translation of \mucp Terms into \gvpi}\label{fig:fromcp}
\end{figure}

We now present the translation $\togv{-}$ from CP to \gvpi. On types:
\small\[
\ba{@{}c@{\qquad}c@{\qquad}c@{}}
\begin{eqs}
\togv{A \otimes B} &=& \gvout{\gvdual{\togv{A}}}{\togv{B}} \\
\togv{A \parr B}   &=& \gvin{\togv{A}}{\togv{B}} \\
\togv{1}           &=& \outterm \\
\togv{\bot}        &=& \interm \\
\end{eqs}
&
\begin{eqs}
\togv{+\{l_i:A_i\}_i}     &=& +\{l_i:\togv{A_i}\}_i  \\
\togv{\with\{l_i:A_i\}_i} &=& \with\{l_i:\togv{A_i}\}_i \\
\togv{\cpquery{A}}  &=& \gvservice{\togv{A}} \\
\togv{\cpbang{A}}   &=& \gvserver{\togv{A}} \\
\end{eqs}
&
\begin{eqs}\shaderow
\togv{X}           &=& X \\ \shaderow
\togv{\cpdual{X}}  &=& \gvdual{X} \\ \shaderow
\togv{\nu F} &=& \nu \togv{F} \\ \shaderow
\togv{\mu F} &=& \mu \togv{F} \\ \shaderow
\togv{X.A} &=& X.\togv{A} \\
\end{eqs}
\ea
\]\normalsize
The translation on terms makes use of $\key{let}$ expressions to simplify the presentation; these
are expanded to \gvpi as follows:
\small\[
\gvlet{x}{M}{N} \mapsto
  \topi{(\lambda x.N) M} =
  \gvsend{M}{(\gvfork{z}{\gvreceivek{x}{z}{z}{\gvlink{N}{z}}})}
\]\normalsize%
The translation on terms is given in Fig.~\ref{fig:fromcp}. The interesting cases are for \tkwd{rec}
and \tkwd{corec}.  A \tkwd{rec} term is always translated to a use of the unfolding from $\mu F$ to
$F (\mu F)$; none of the remaining unfoldings are used in the typing derivation of $\togv{P}$.  The
translation of \tkwd{corec} must simulate the expansion of the term $Q$, using $p$ to re-establish
the coinvariant after each expansion, and thus depends on the translation of functoriality from
\mucp to \mugv.

\begin{theorem}
  If $\cptyp{P}{\Gamma}$, then $\gvtyp{\togv{\Gamma}}{\togv{P}}{\outterm}$.
\end{theorem}
%
%% The key soundness property of our translations is that if we translate a process from \mucp to \mugv
%% and back, then we obtain a process equivalent to the original.
%
%% The following theorem is the key soundness property of our translations.
As the semantics of \mugv is defined by translation to \mucp, the following soundness theorem tells
us that \mugv and \mucp are equally expressive.
\begin{theorem}
\label{th:soundness}
If $\cptyp{P}{\Gamma}$ then $\cut{z}{}{z[].0}{\tocp{\togv{P}}z} \Longrightarrow^* P$.
\end{theorem}
%
Finally, we return to the rules for recursive session types.
\begin{theorem}\label{th:admissible}
  The final 3 rules in Fig.~\ref{fig:gv-typing} are admissible.
\end{theorem}
We can see this from the composition of the $\tocp{-}$ and $\togv{-}$ translations, as the result
does not use any of the rules in question.  Note, however, that the translation of the unfolding of
$\nu G$ into $G (\nu G)$ and the folding of $G (\mu G)$ into $\mu G$ introduces additional term
structure (with depth bounded by the depth of $G$).

\section{Related Work}\label{sec:related}

Session types were originally introduced by \citet{Honda93}, and were further extended by
\citet{Takeuchi94}, \citet{Honda98}, and \citet{Yoshida07}. The systems of \citet{Honda98} and
\citet{Yoshida07} include recursive session types. They do not distinguish between recursion and
corecursion, and do not exhibit deadlock freedom. \citet{Bono12} and \citet{Bernardi13}
independently observed that duality in those systems was not preserved under unfolding of recursive
types; \citet{Bernardi14} studies the role of duality in session types, including those with
recursion.  This work adopts a different solution from ours, however, and we hope to investigate the
consequences of these different approaches in future work.

\citet{CairesPfenning10} showed the first complete propositions-as-types correspondence between
intuitionistic linear logic (ILL) and session types. Their work shows both an interpretation of
session types as ILL propositions, and a computational interpretation of ILL proofs as
$\pi$-calculus processes. As a result, they are able to show that well-typed processes are free of
races, dealock, and livelock, by analogy with corresponding cut-elimination results for
ILL. \citet{Toninho13} demonstrate an embedding of their calculus within a functional language; the
resulting system admits unrestricted recursion in the functional setting, and can thus provide
recursive communication behavior, but does not guarantee that the evaluation of function terms
terminates.

\citet{Girard87} speculated that linear logic would be well-suited to reasoning about concurrency.
\citet{Abramsky92} and \citet{BellinScott94} explored the interpretation of linear logic proofs as
concurrent programs. \citet{Kobayashi96} introduced the use of linear typing to the $\pi$-calculus,
and demonstrated a form of linear channels similar in usage to session-typed channels; Dardha et
al.'s~\citeyearpar{Dardha12} extensions to this work include full session types.

\section{Conclusion and Future Work}\label{sec:future}

We have demonstrated a propositions-as-types correspondence linking recursive session types and
fixed points in linear logic. Unlike previous work on recursive session types, our presentation
distinguishes between (bounded) recursive processes and (unbounded) corecursive processes. As a
consequence of cut elimination in linear logic, all well-typed processes are free of races,
deadlock, and livelock. We conclude by identifying several areas of future work. First, we would
like to give an asynchronous semantics to \mugv, following the original presentation of LAST by
\citet{GayVasconcelos10}, and show that it is equivalent to the synchronous semantics provided by
cut elimination in \mucp. Second, we would like to extend our treatment of recursive sessions to
encode arbitrary recursive types in \mugv, similarly to our encoding of function and pair types in
terms of input and output on channels. Finally, we would like to explore further extensions of \mucp
and their consequences for \mugv, including: the addition of second-order polymorphism, as explored
by \citet{Wadler12} for CP and \citet{LindleyM14} for GV; the addition of the MIX$_0$ and MIX$_2$
rules, providing additional notions of parallel composition and unifying the types $\outterm$ and
$\interm$; and, finally, further exploration of concurrency and non-determinism in a
logically-founded setting.

\label{sect:bib}
\bibliographystyle{abbrvnat}
\bibliography{main}

\end{document}
\newpage
\appendix

\section{Cut Elimination for \mucp}

\begin{multline*}
\inferrule
  {\inferrule*
     {\cptyp{P}{y:A,\Gamma} \\
      \cptyp{Q}{x:B,\Gamma'}}
     {\cptyp{x[y].(P \mid Q)}{\Gamma,\Gamma',x: A \otimes B}} \\
   \inferrule*
     {\cptyp{R}{\Delta,x:\cpdual{B},y:\cpdual{A}}}
     {\cptyp{x(y).R}{\Delta,x:\cpdual{A} \parr \cpdual{B}}}}
  {\cptyp{\cut{x}{A \otimes B}{x[y].(P \mid Q)}{x(y).R}}{\Gamma,\Gamma',\Delta}}
\Longrightarrow \\
\inferrule
  {\cptyp{Q}{\Gamma,y:A} \\
   \inferrule*
     {\cptyp{P}{\Gamma',x:B} \\
      \cptyp{R}{\Delta,x:\cpdual{B},y:\cpdual{A}}}
     {{\cptyp{\cut{x}{B}{P}{R}}{\Gamma',\Delta,y:\cpdual{A}}}}}
  {\cptyp{\cut{y}{A}{Q}{\cut{x}{B}{P}{R}}}{\Gamma,\Gamma',\Delta}}
\end{multline*}
\[
\inferrule
  {\inferrule*
     { }{\cptyp{x[].0}{x:1}} \\
   \inferrule*
     {\cptyp{P}{\Gamma}}
     {\cptyp{x().P}{\Gamma,x:\bot}}}
  {\cptyp{\cut{x}{1}{x[].0}{x().P}}{\Gamma}}
\Longrightarrow
\cptyp{P}{\Gamma}
\]
\begin{multline*}
\inferrule
  {\inferrule*
     {\cptyp{P}{x:A,\Gamma}}
     {\cptyp{\sel{x}{inl}.P}{ \Gamma,x:A \oplus B}} \\
   \inferrule*
     {\cptyp{Q}{\Delta,x:\cpdual{A}} \\
      \cptyp{R}{\Delta,x:\cpdual{B}}}
     {\cptyp{\case{x}{Q;R}}{\Delta,x:\cpdual{A} \with \cpdual{B}}}}
  {\cptyp{\cut{x}{A \oplus B}{\sel{x}{inl}.P}{\case{x}{Q;R}}}{\Gamma,\Delta}}
\Longrightarrow \\
\inferrule
  {\cptyp{P}{\Gamma,x:A} \\
   \cptyp{Q}{\Delta,x:\cpdual{A}}}
  {\cptyp{\cut{x}{A}{P}{Q}}{\Gamma,\Delta}}
\end{multline*}
\[
\inferrule
  {\inferrule*
     {\cptyp{P}{\cpquery{\Gamma},y:A}}
     {\cptyp{\replicate{x}{y}.P}{\Gamma,x:\cpbang{A}}} \\
   \inferrule*
     {\cptyp{Q}{\Delta,y:\cpdual{A}}}
     {\cptyp{\derelict{x}{y}.Q}{\Delta,x:\cpquery{\cpdual{A}}}}}
  {\cptyp{\cut{x}{\cpbang{A}}{\replicate{x}{y}.P}{\derelict{x}{y}.Q}}{\Gamma,\Delta}}
\Longrightarrow
\inferrule
  {\cptyp{P}{\Gamma,x:A} \\
   \cptyp{Q}{\Delta,y:\cpdual{A}}}
  {\cptyp{\cut{y}{A}{P}{Q}}{\Gamma,\Delta}}
\]
\[
\inferrule
  {\inferrule*
     {\cptyp{P}{\cpquery{\Gamma},y:A}}
     {\cptyp{\replicate{x}{y}.P}{\Gamma,x:\cpbang{A}}} \\
   \inferrule*
     {\cptyp{Q}{\Delta} \\ un(\cpquery{\cpdual{A}})}
     {\cptyp{Q}{y:\cpquery{\cpdual{A}}}}}
  {\cptyp{\cut{y}{\cpbang{A}}{\replicate{x}{y}.P}{Q}}{\Gamma,\Delta}}
\Longrightarrow
\inferrule
  {\cptyp{Q}{\Delta}}
  {\cptyp{Q}{\Gamma,\Delta}}
\]
\begin{multline*}
\inferrule
  {\inferrule*
     {\cptyp{P}{\cpquery{\Gamma},y:A}}
     {\cptyp{\replicate{x}{y}.P}{\Gamma,x:\cpbang{A}}} \\
   \inferrule*
     {\cptyp{Q}{x:\cpquery{\Delta,\cpdual{A}},x':\cpquery{\cpdual{A}}}}
     {\cptyp{Q[x/x']}{\Delta,x:\cpquery{\cpdual{A}}}}}
  {\cptyp{\cut{x}{\cpbang{A}}{\replicate{x}{y}.P}{Q[x/x']}}{\Gamma,\Delta}}
\Longrightarrow \\
\inferrule
  {\inferrule*
     {\cptyp{P}{\cpquery{\Gamma},y:A}}
     {\cptyp{\replicate{x}{y}.P}{\Gamma,x:\cpbang{A}}} \\
   \inferrule*
     {\inferrule*
         {\cptyp{P}{\cpquery{\Gamma},y:A}}
         {\cptyp{\replicate{x'}{y}.P}{\Gamma,x':\cpbang{A}}} \\
      \cptyp{Q}{\Delta,x:\cpquery{\cpdual{A}},x':\cpquery{\cpdual{A}}}}
     {\cptyp{\cut{x'}{\cpbang{A}}{\replicate{x'}{y}.P}{Q}}{\Gamma,\Delta}}}
  {\cptyp{\cut{x}{\cpbang{A}}{\replicate{x}{y}.P}{\cut{x'}{\cpbang{A}}{\replicate{x'}{y}.P}{Q}}}{\Gamma,\Delta}}
\end{multline*}
\[
\bl
\inferrule
  {\inferrule*
     {\cptyp{P}{\Gamma,y:B} \\
      \cptyp{Q}{y:\cpdual{B},x:F(B)}}
     {\cptyp{\corec{x}{y}{P}{Q}}{\Gamma,x:\nu F}} \\
   \inferrule*
     {\cptyp{R}{\Delta,x:\cpdual{F}(\mu (\cpdual{F}))}}
     {\cptyp{\rec{x}.R}{\Delta,x:\mu (\cpdual{F})}}}
  {\cptyp{\cut{x}{\nu F}{}{\rec{x}.R}}{\Gamma,\Delta}}
\Longrightarrow \\
\inferrule
  {\cptyp{P}{\Gamma,y:B} \\
   \inferrule*
     {\cptyp{Q}{y:\cpdual{B},x:F(B)} \\
      \inferrule*
          {\cptyp{E}{x:\cpdual{F}(\cpdual{B}),z:F(\nu F)} \\\\
         \cptyp{R[z/x]}{\Delta,z:\cpdual{F}(\mu \cpdual{F})}}
        {\cptyp{\cut{z}{F(\nu F)}{E}{R[z/x]}}{\Delta,x:\cpdual{F}(\cpdual{B})}}}
     {\cptyp{\cut{x}{F(B)}{Q}{\cut{z}{F(\nu F)}{E}{R[z/x]}}}{\Delta,y:\cpdual{B}}}}
  {\cptyp{\cut{y}{B}{P}{\cut{x}{F(B)}{Q}{\cut{z}{F(\nu F)}{E}{R[z/x]}}}}{\Gamma,\Delta}}
\el
\]
where $E = \map{F}{x,z}{\corec{z}{y}{\link{x}{y}}{Q[z/x]}}$.


TODO:

* Example of using Nats paralleling corresponding mugv example.

* Make last part of conclusion a little more interesting.

* Crisper characterisation of difference between corec and cofix, if possible.

* Better title?

* should we mention the slightly more general version of cofix which allows an additional unlimited
type environment?

* observe that cofix p can be implemented using cofix f?

  cofix f c x = let p = fork p.let (c, p) = receive p in
                               let (x, p) = receive p in
                               f c x
                in M

* remark that corecursion (and in particular making a careful distinction between programs over data
and programs over codata) is an active area in programming languages research (e.g. Atkey and
McBride, Abel and Pientka, both ICFP 2013, Kozen et al ESOP 2013)

* mention that we've implemented everything in the paper and more and the code is on github

* mention that we've reimplemented all of Toninho et al's examples in mucp and mugv

* fill in Troelstra reference


NOT TODO

(adjusted the translation to mucp to use judgements)
* consider adding explicit syntax for all typing rules in order to allow all of the term
translations to be completely syntax-directed:

  muGV:
    relax L               (T -> U)
    restrict L            (T -o U)
    weaken? M with x      (end?)
    contract? M with x/x' (end?)
    unroll M              (G(mu G))

  muCP:
   corec^F c<x>(P, Q)
