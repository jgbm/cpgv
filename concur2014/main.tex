% -*- fill-column: 100 -*-

\documentclass[orivec,envcountsame]{llncs}

\usepackage{amsmath,amssymb,mathwidth,stmaryrd,xspace}
\usepackage[table]{xcolor}
\usepackage{colortbl}
\addtolength{\jot}{-3px}

% Attempt to duplicate Springer's style of references
\usepackage[authoryear,compress,round]{natbib}
\renewcommand{\bibsection}{\section*{References}}
\renewcommand{\bibpreamble}{\scriptsize}

\usepackage{mathpartir}
\mprset{sep=1em}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

\newcommand{\with}{\mathbin\binampersand}
\newcommand{\parr}{\mathbin\bindnasrepma}
\newcommand{\cpdual}[1]{#1^\perp}
\newcommand{\cpbang}[1]{{! #1}}
\newcommand{\cpquery}[1]{{? #1}}
\newcommand{\gvdual}[1]{\overline{#1}}
\newcommand{\gvout}[2]{{!#1.#2}}
\newcommand{\gvin}[2]{{?#1.#2}}
\newcommand{\lto}{\ensuremath{\multimap}}
\newcommand{\uto}{\ensuremath{\rightarrow}}
\newcommand{\outterm}{\mkwd{end}_!}
\newcommand{\interm}{\mkwd{end}_?}
\newcommand{\gvserver}[1]{\flat #1}
\newcommand{\gvservice}[1]{\sharp #1}
\newcommand{\trule}[1]{(\textit{#1})}
\newcommand{\cptyp}[2]{#1 \vdash #2}
\newcommand{\gvtyp}[3]{#1 \vdash #2 : #3}

\newcommand{\mapname}{\mathsf{map}}
\newcommand{\map}[3]{\mapname^{#1}_{#2}(#3)}
\newcommand{\gvmap}[3]{\mapname^{#1}_{#2}\:#3}

\newcommand{\mkwd}[1]{\mathsf{#1}}
\newcommand{\tkwd}[1]{\textsf{#1}}
\newcommand{\link}[2]{#1 \leftrightarrow #2}
\newcommand{\cut}[4]{\mkwd{new}\:#1 \: (#3 \mid #4)}
\newcommand{\replicate}[2]{{!#1(#2)}}
\newcommand{\derelict}[2]{{?#1[#2]}}
\newcommand{\rec}[1]{\mkwd{rec}\:#1}
\newcommand{\corec}[5]{\mkwd{corec}\:#1 \langle #2 \rangle (#4,#5)}
\newcommand{\clabel}[1]{\mathit{#1}}
\renewcommand{\case}[2]{\mkwd{case}\:#1\:\{#2\}}
\newcommand{\sel}[2]{#1[\clabel{#2}]}
\newcommand{\gvsend}[2]{\mkwd{send}\:#1\:#2}
\newcommand{\gvreceive}[1]{\mkwd{receive}\:#1}
\newcommand{\gvlet}[3]{\mkwd{let}\;#1 = #2\;\mkwd{in}\;#3}
\newcommand{\gvselect}[2]{\mkwd{select}\:#1\:#2}
\newcommand{\gvcase}[2]{\mkwd{case}\:#1\:\{#2\}}
\newcommand{\gvlink}[2]{\mkwd{link}\:#1\:#2}
\newcommand{\gvfork}[2]{\mkwd{fork}\:#1.#2}
\newcommand{\lrkwd}{\mkwd{cofix}}
\newcommand{\gvfix}[3]{\lrkwd\:#1\:#2 = #3}
\newcommand{\gvletrec}[4]{\gvlet{#1}{\gvfix{#1}{#2}{#3}}{#4}}
\newcommand{\gvserve}[2]{\mkwd{serve}\:#1.#2}
\newcommand{\gvrequest}[1]{\mkwd{request}\:#1}

\newcommand{\gvifthen}[3]{\mkwd{if}\:#1\:\mkwd{then}\:#2\:\mkwd{else}\:#3}
\newcommand{\gvreceivek}[4]{\gvlet{({#1}, {#2})}{\gvreceive{#3}}{#4}}


\newcommand{\key}{\mkwd}
\newcommand{\cofix}{\lrkwd}

\newcommand{\tocpbig}[1]{\left\llbracket #1 \right\rrbracket}

\newcommand{\tocp}[1]{\llbracket #1 \rrbracket}
\newcommand{\togv}[1]{\llparenthesis #1 \rrparenthesis}


\newcommand{\topi}[1]{({#1})^\star}

\newcommand{\un}{un}
\newcommand{\lin}{lin}

\newcommand{\mucp}{$\mu\mathrm{CP}$\xspace}
\newcommand{\mugv}{$\mu\mathrm{GV}$\xspace}
\newcommand{\gvpi}{$\mu\mathrm{GV}\pi$\xspace}

\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}

\newcommand{\bl}{\ba[t]{@{}l@{}}}
\newcommand{\el}{\ea}

\newenvironment{equations}{\[\ba{@{}r@{~}c@{~}l@{}}}{\ea\]}
\newenvironment{eqs}{\ba{@{}r@{~}c@{~}l@{}}}{\ea}

\newcommand{\mcl}[2]{\multicolumn{#1}{l}{#2}}

\newcommand{\secref}[1]{(\S\ref{sec:#1})}

%%% grey shading
\definecolor{shade}{RGB}{223,223,223}
\newcommand\shade[1]{\setlength{\fboxsep}{0pt}\colorbox{shade}{\ensuremath{#1}}}
%\newcommand{\shade}[1]{\colorbox{shade}{\ensuremath{#1}}}

\newcommand\shaderow{\noalign{\vskip-0.4pt}\rowcolor{shade}[0.6mm]}
%%%

\title{Recursive Session Types and Linear Logic}
\author{J. Garrett Morris \and Sam Lindley}
\institute{University of Edinburgh \\
           \email{\{Garrett.Morris,Sam.Lindley\}@ed.ac.uk}}

\newcommand{\todo}[1]{{\noindent\small\color{red} \framebox{\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{\textbf{TODO:} #1}}}}
%\newcommand{\todo}[1]{}

\begin{document}

\maketitle

\begin{abstract}
  We extend a propositions-as-types correspondence between linear logic and session types to include
  recursive sessions.  Our extension takes least and greatest fixpoints as dual, an idea well-known
  to theorists, but which has not previously appeared in the treatment of recursive sessions. We
  preserve the race freedom and deadlock freedom that are a hallmark of linear logic-based session
  types, and avoid some problems with recursion that appear in other systems.  We treat two systems,
  one based on classical linear logic, derived from work of Caires and Pfenning and of Wadler, and
  one based on a linear functional language, derived from work of Gay and Vasconcelos. Our treatment
  of recursion is inspired by Baelde.

  % A Curry-Howard correspondence between session types and linear logic was first demonstrated by
  % Caires and Pfenning for intuitionistic linear logic, and later adapted to the classical setting by
  % Wadler. These correspondences give both a logical interpretation of session types and a
  % computational interpretation of linear logic proofs, and ensure race freedom, deadlock freedom,
  % and termination of well-typed processes. However, neither system accomodates recursive sessions,
  % as might be used to represent stateful servers or inductive data types.

  % We extend Wadler's correspondence to recursive processes and sessions using equirecursive session
  % types. We show that the resulting types and processes are in correspondence with the propositions
  % and proofs of Baelde's extension of linear logic with greatest and least fixed points. Unlike
  % prior accounts of recursive session typing, our system distinguishes recursive and corecursive
  % processes, and exploits their duality to maintain race freedom, deadlock freedom, and termination,
  % even in the presence of unbounded corecursive processes.
\end{abstract}

\section{Introduction}\label{sec:intro}

Previous work on session types suffers from a mismatch.  Session types capture communication
protocols.  The two ends of a channel must be \emph{dual}, which ensures that when one end of a
channel performs output the other performs input, and when one end offers a choice of actions the
other selects from these alternatives.  Session types are of limited use without \emph{recursion},
which permits defining sessions of arbitrary size.  Recursion traditionally comes in two dual forms,
least fixpoint and greatest fixpoint.  However, in previous work on session types recursion was
introduced in a way where both ends of a channel are treated as least fixpoints.  Here, we introduce
a notion of recursion for session types that restores the traditional notion that least fixpoints
are dual to greatest fixpoints.

%%% PHIL TO CONTINUE FROM HERE %%%


Session types provide a type-based approach to structuring communication among concurrent or
distributed processes.  In this approach, types are used to describe communication protocols, and
type checking guarantees that processes observe these protocols.  Session types have been applied in
a variety of languages, including process calculi~\citep{Honda93,Honda98} and functional
languages~\citep{GayVasconcelos10}.

\citet{CairesPfenning10} first demonstrated a Curry-Howard correspondence between session-typed
process calculi and intuitionistic linear logic (ILL).  Their correspondence gives both an
interpretation of session types as ILL propositions, and a computational interpretation of ILL
proofs as $\pi$-calculus processes.  As a result, they are able to show that well-typed processes
are terminating, race-free, and deadlock-free, by analogy with corresponding cut-elimination results
for ILL.  \citet{Wadler12} adapted their approach to classical linear logic (CLL).  In doing so, he
presented two languages, CP and GV.  CP is a process calculus-like term-assignment for the proof
rules of CLL.  GV is a session-typed functional language, based on the language of
\citet{GayVasconcelos10}.  He shows that all GV typing derivations correspond to well-typed CP
terms; subsequently, \cite{LindleyM14} extended GV such that all CP derivations correspond to GV
terms as well.

Most work on session-typed systems permit recursive processes and recursive session types.  However,
neither of the correspondences between session types and linear logic include recursive sessions.
This work extends Wadler's approach to include recursive sessions.  We extend CP to include notions
of greatest and least fixed point, drawing on Baelde's~\citeyearpar{Baelde12} proof-theoretic study of
fixed points in linear logic.  Likewise, we extend GV with recursive and corecursive sessions,
providing bounded and unbounded iteration respectively.  Finally, we show that the resulting
languages are still interconvertible.  We preserve the significant results of the existing
correspondence (race freedom, deadlock freedom, and termination).

The paper proceeds as follows. We begin by presenting a simple, session-typed functional
language~\secref{mugv}, which includes support for recursive session types.  We next extend Wadler's
CP language to include terms corresponding to recursion and corecursion~\secref{mucp}, based on
Baelde's proof rules for fixed points in linear logic, and demonstrate their use.  We show that the
languages \mugv and \mucp are equally expressive, by showing that \mugv can be reduced to its
session-typed features~\secref{gvtogvpi}, and that terms in that reduced language are
interconvertible with terms in \mucp~(\S\S\ref{sec:gvpitocp},\ref{sec:cptogvpi}).  We conclude with
surveys of related~\secref{related} and future~\secref{future} work.

%\todo{Full list of examples: \begin{enumerate}
%\item Stream of zeros (no use of coinvariant);
%\item Stream of naturals (simple coinvariant);
%\item Stream of Fibonacci numbers (slightly less simple coinvariant);
%\item Calculator (recursion and choice)
%\item Bit strings (correspondence to Toninho et al.)
%\item Church numerals
%\item Peano numerals
%\item Simulating exponentials with fixed points
%\end{enumerate}}

\section{A Session-Typed Functional Language}
\label{sec:mugv}

In this section, we present \mugv, a simple functional language with session types patterned on the
language of \citet{GayVasconcelos10} (which we call LAST) and Wadler's language GV.
%
Throughout the paper we highlight the novel parts of \mugv and \mucp by shading them in
\shade{\mathrm{gray}}.

\subsection{Types}
\label{sec:mugv-types}

Types in \mugv are given by the following grammar:
\[
\small
\begin{array}{@{}l@{~}r@{~}c@{~}l@{}}
  \text{Types}         & T,U,V & ::= & S \mid T \otimes U \mid T \lto U \mid T \uto U \\
  \text{Session Types} & S     & ::= & \gvout{T}{S} \mid \gvin{T}{S}
                                \mid   \oplus \{ l_i : S_i \} \mid \with \{ l_i : S_i \}
                                \mid   \outterm \mid \interm \\
                            & & \mid & \gvservice{S} \mid \gvserver{S}
                                \mid   X \mid \gvdual{X}
                                \mid   \shade{\mu G} \mid \shade{\nu G} \\  \shaderow
  \text{Type Operators} & G    & ::= & X.S \\
\end{array}
\]%
%
The types comprise session types, linear pairs ($T \otimes U$), and both linear ($T \lto U$) and
unlimited ($T \uto U$) functions.
%
Session types include input ($\gvin{T}{S}$), output ($\gvout{T}{S}$), selection ($\oplus\{ l_i:S_i
\}$), choice ($\with\{l_i:S_i\}$), and closed channels ($\interm$ and $\outterm$).  There are two
variations on the closed channel ($\interm$) and ($\outterm$); these arise from our interpretation
of session types in classical linear logic, where there is no self-dual proposition corresponding to
closed channels.  We include a notion of replicated sessions, corresponding to exponentials in
linear logic: a channel of type $\gvservice{S}$ is a service, offering any number of channels of
type $S$; a channel of type $\gvserver{S}$ is the server providing such channels. (We have chosen
the syntax $\gvserver{S}$ and $\gvservice{S}$ as $!$ and $?$ are already used for input and output.)
Finally, we include session variables and their duals ($X$) and ($\gvdual{X}$), and types
corresponding to bounded ($\mu X.S$) and unbounded ($\nu X.S$) recursion. If $G$ is an operator
$X.S$, we write $G(S')$ for the substitution instance $S[S'/X]$.

Each type $T$ is either linear ($\lin(T)$) or unlimited ($\un(T)$).
% The linearity of $T$ is determined by its top level type constructor.
All types are linear except unlimited functions $T \uto U$, replicated channels $\gvservice{S}$, and
closed input channels $\interm$.

We extend the standard duality for non-recursive session types to include recursive session types:
\[
\small
%\ba{@{}c@{\quad}c@{\quad}c@{\quad}c@{\quad}c@{\quad}c@{}}
\ba{@{}c@{\quad}c@{\quad}c@{\quad}c@{\quad}c@{}}
\begin{eqs}
\gvdual{\gvout{T}{S}} &=& \gvin{T}{\gvdual{S}} \\
\gvdual{\gvin{T}{S}} &=& \gvout{T}{\gvdual{S}} \\
\end{eqs}
&
\begin{eqs}
  \gvdual{\oplus \{ l_i: S_i \}} &=& \with \{ l_i : \gvdual{S_i} \} \\
  \gvdual{\with \{ l_i: S_i \}} &=& \oplus \{ l_i : \gvdual{S_i} \} \\
\end{eqs}
&
\begin{eqs}
  \gvdual{\interm} &=& \outterm \\
  \gvdual{\outterm} &=& \interm \\
\end{eqs}
&
\begin{eqs}
  \gvdual{\gvserver{S}} &=& \gvservice{\gvdual{S}} \\
  \gvdual{\gvservice{S}} &=& \gvserver{\gvdual{S}} \\
\end{eqs}
%&
%\begin{eqs}
%  \gvdual{X} &=& \gvdual{X} \\
%  \gvdual{\gvdual{X}} &=& X
%\end{eqs}
&
\begin{eqs}
  \shaderow \gvdual{\mu G} &=& \nu \gvdual{G} \\
  \shaderow \gvdual{\nu G} &=& \mu \gvdual{G}
\end{eqs}
\ea
\]
where $\gvdual{\gvdual{X}} = X$ and we define the dual of an operator $G = X.S$ as $\gvdual{G} =
X.\gvdual{G(\gvdual{X})}.$ Observe that $\gvdual{G(S)} = \gvdual{G}(\gvdual{S})$.  Unlike many
notions of duality for session types, our definition preserves duality when recursive session types
are unfolded, even when the recursion occurs in messages.  For example, consider the operator $G =
X.\gvin{X}{\interm}$, its dual $\gvdual{G} = X.\gvout{\gvdual{X}}{\outterm}$, and the dual session
types $\mu G$ and $\nu \gvdual{G}$.  Unfolding the first type yields $G(\mu G)$, or $\gvin{\mu
  G}{\interm}$; unfolding the second yields
\[
\small
  \gvdual{G}(\nu \gvdual{G}) = \gvout{\gvdual{\nu \gvdual{G}}}{\outterm} = \gvout{\mu G}{\outterm},
\]
which is the dual of $\gvin{\mu G}{\interm}$.

To ensure that fixed points exist, we require that all operators $X.S$ be monotonic; that is,
variables may appear only as positive subformulas of $S$, and negated variables only as negative
subformulas.  The subformula $T$ is negative in types $T \lto U$ and $T \uto U$ and in the session
type $\gvout{T}{S}$; all other subformulae are positive.  Thus, the operator $X.\gvout{X}{\outterm}$
is not monotonic, but the operator $X.\gvout{(X \uto \outterm)}{\outterm}$ is.
%
Formally, $X.S$ is monotonic iff the predicate $pos_{X,S}$ holds, where $pos$ and $neg$ are defined
by the homomorphic extensions of the following implications:
\[
\small
\ba{@{}c@{\qquad}c@{}}
\begin{eqs}
pos_{X,X} \\
\neg pos_{X,\gvdual{X}} \\
pos_{X,!T.S} &\iff& neg_{X,T} \wedge pos_{X,S} \\
pos_{X,T \lto U} &\iff& neg_{X,T} \wedge pos_{X,U} \\
pos_{X,T \uto U} &\iff& neg_{X,T} \wedge pos_{X,U} \\
\end{eqs}
&
\begin{eqs}
\neg neg_{X,X} \\
neg_{X,\gvdual{X}} \\
neg_{X,!T.S} &\iff& pos_{X,T} \wedge neg_{X,S} \\
neg_{X,T \lto U} &\iff& pos_{X,T} \wedge neg_{X,U} \\
neg_{X,T \uto U} &\iff& pos_{X,T} \wedge neg_{X,U} \\
\end{eqs}
\ea
\]

%% \[
%% \ba{@{}cc@{}}
%% \begin{eqs}
%% pos_X(!T.S) &=& neg_X(T) \wedge pos_X(S) \\
%% pos_X(?T.S) &=& pos_X(T) \wedge pos_X(S) \\
%% pos_X(+\{l_i:S_i\}_i) &=& \forall i.pos(S_i) \\
%% pos_X(\with\{l_i:S_i\}_i) &=& \forall i.pos(S_i) \\
%% pos_X(\outterm) \\
%% pos_X(\interm) \\
%% pos_X(X) \\
%% \neg pos_X(\gvdual{X}) \\
%% pos_X(\mu G) &=& pos_X(G) \\
%% pos_X(\nu G) &=& pos_X(G) \\
%% pos_X(X.S) \\
%% pos_X(Y.S) &=& pos_X(S), \text{ if }X \neq Y \\
%% pos_X(T \otimes  U) &=& pos_X(T) \wedge pos_X(U) \\
%% pos_X(T \lto U) &=& neg_X(T) \wedge pos_X(U) \\
%% pos_X(T \uto U) &=& neg_X(T) \wedge pos_X(U) \\
%% \end{eqs}
%% &
%% \begin{eqs}
%% neg_X(!T.S) &=& pos_X(T) \wedge neg_X(S) \\
%% neg_X(?T.S) &=& neg_X(T) \wedge neg_X(S) \\
%% neg_X(+\{l_i:S_i\}_i) &=& \forall i.neg(S_i) \\
%% neg_X(\with\{l_i:S_i\}_i) &=& \forall i.neg(S_i) \\
%% neg_X(\outterm) \\
%% neg_X(\interm) \\
%% \neg neg_X(X) \\
%% neg_X(\gvdual{X}) \\
%% neg_X(\mu G) &=& neg_X(G) \\
%% neg_X(\nu G) &=& neg_X(G) \\
%% neg_X(X.S) \\
%% neg_X(Y.S) &=& neg_X(S), \text{ if }X \neq Y \\
%% neg_X(T \otimes  U) &=& neg_X(T) \wedge neg_X(U) \\
%% neg_X(T \lto U) &=& pos_X(T) \wedge neg_X(U) \\
%% neg_X(T \uto U) &=& pos_X(T) \wedge neg_X(U) \\
%% \end{eqs}
%% \ea
%% \]

%% \todo{Formally define monotonicity of operators}

%% pos(X, !T.S) = neg(X, T) /\ pos(X, S)
%% pos(X, ?T.S) = pos(X, T) /\ pos(X, S)
%% pos(X, +{li:Si}i) = forall i.pos(Si)
%% pos(X, &{li:Si}i) = forall i.pos(Si)
%% pos(X, end!)
%% pos(X, end!)
%% pos(X, X)
%% ¬pos(X, ~X)
%% pos(X, mu G) = pos(X, G)
%% pos(X, nu G) = pos(X, G)
%% pos(X, X.S)
%% pos(X, Y.S) = pos(X, S), if X =/= Y
%% pos(X, T *  U) = pos(X, T) /\ pos(X, U)
%% pos(X, T -o U) = neg(X, T) /\ pos(X, U)
%% pos(X, T -> U) = neg(X, T) /\ pos(X, U)

%% neg(X, !T.S) = pos(X, T) /\ neg(X, S)
%% neg(X, ?T.S) = neg(X, T) /\ neg(X, S)
%% neg(X, +{li:Si}i) = forall i.neg(Si)
%% neg(X, &{li:Si}i) = forall i.neg(Si)
%% neg(X, end!)
%% neg(X, end!)
%% ¬neg(X, X)
%% neg(X, ~X)
%% neg(X, mu G) = neg(X, G)
%% neg(X, nu G) = neg(X, G)
%% neg(X, X.S)
%% neg(X, Y.S) = neg(X, S), if X =/= Y
%% neg(X, T *  U) = neg(X, T) /\ neg(X, U)
%% neg(X, T -o U) = pos(X, T) /\ neg(X, U)
%% neg(X, T -> U) = pos(X, T) /\ neg(X, U)


\subsection{Typing Rules}
\label{sec:mugv-typing}

\begin{figure}[float]
\scriptsize
\[
un(T \lto U)
\qquad
un(\gvservice{S})
\qquad
un(\interm)
\]

Structural rules
\begin{mathpar}
\inferrule{ }{\gvtyp{x:T}{x}{T}}

\inferrule{\gvtyp{\Phi}{M}{U} \\
           un(T)}
          {\gvtyp{\Phi,x:T}{M}{U}}

\inferrule{\gvtyp{\Phi,x:T,x':T}{M}{U} \\
           un(T)}
          {\gvtyp{\Phi,x:T}{M[x/x']}{U}}
\end{mathpar}
Lambda Rules
\begin{mathpar}
\inferrule{\gvtyp{\Phi,x:T}{M}{U}}
          {\gvtyp{\Phi}{\lambda x.M}{T \lto U}}

\inferrule{\gvtyp{\Phi}{M}{T \lto U} \\
           \gvtyp{\Psi}{N}{T}}
          {\gvtyp{\Phi,\Psi}{M\,N}{U}}

\inferrule{\gvtyp{\Phi}{M}{T \lto U} \\
           un(\Phi)}
          {\gvtyp{\Phi}{M}{T \uto U}}

\inferrule{\gvtyp{\Phi}{M}{T \uto U}}
          {\gvtyp{\Phi}{M}{T \lto U}}

\inferrule{\gvtyp{\Phi}{M}{T} \\
           \gvtyp{\Psi}{N}{U}}
          {\gvtyp{\Phi,\Psi}{(M,N)}{T \otimes U}}

\inferrule{\gvtyp{\Phi}{M}{T \otimes U} \\
           \gvtyp{\Psi,x:T,y:U}{N}{V}}
          {\gvtyp{\Phi,\Psi}{\gvlet{(x,y)}{M}{N}}{V}}
\end{mathpar}
Session Rules
\begin{mathpar}
\inferrule{\gvtyp{\Phi}{M}{S} \\
           \gvtyp{\Psi}{N}{\gvdual{S}}}
          {\gvtyp{\Phi,\Psi}{\gvlink{M}{N}}{\outterm}}

\inferrule{\gvtyp{\Phi}{M}{T} \\
           \gvtyp{\Psi}{N}{\gvout{T}{S}}}
          {\gvtyp{\Phi,\Psi}{\gvsend{M}{N}}{S}}

\inferrule{\gvtyp{\Phi}{M}{\gvin{T}{S}}}
          {\gvtyp{\Phi}{\gvreceive{M}}{T \otimes S}}

\inferrule{\gvtyp{\Phi,x:\gvdual{S}}{M}{\outterm}}
          {\gvtyp{\Phi}{\gvfork{x}{M}}{ S}}

\inferrule{\gvtyp{\Phi}{M}{\oplus \{ l_i:S_i \}}}
          {\gvtyp{\Phi}{\gvselect{l_i}{M}}{S_i}}

\inferrule{\gvtyp{\Phi}{M}{\with \{ l_i:S_i \}} \\
           \gvtyp{\Psi,x:S_i}{N_i}{T}}
          {\gvtyp{\Phi,\Psi}{\gvcase{M}{l_i\,x.N_i}}{T}}

%% \end{mathpar}
%% Replicated session rules
%% \begin{mathpar}
\inferrule{\gvtyp{\Phi,x:\gvdual{S}}{M}{\outterm} \\
           un(\Phi)}
          {\gvtyp{\Phi}{\gvserve{x}{M}}{\gvservice{S}}}

\inferrule{\gvtyp{\Phi}{M}{\gvservice{S}}}
          {\gvtyp{\Phi}{\gvrequest{M}}{S}}
\\
\shade{
\inferrule{\gvtyp{\Phi}{M}{G(\mu G)}}
          {\gvtyp{\Phi}{M}{\mu G}}
}

\shade{
\inferrule{\gvtyp{\Phi}{M}{\mu G}}
          {\gvtyp{\Phi}{M}{G (\mu G)}}
}

%% \inferrule{\gvtyp{\Phi}{M}{G(\nu G)}}
%%           {\gvtyp{\Phi}{M}{\nu G}}
%%
%% \inferrule{\gvtyp{\Phi}{M}{\nu G}}
%%           {\gvtyp{\Phi}{M}{G(\nu G)}}
%%
\shade{
\inferrule{\gvtyp{f:X \uto \vec{T} \lto \outterm, c:G(X), \vec{x}:\vec{T}}{M}{\outterm}}
          {\gvtyp{}{\gvfix{f}{c\:\vec{x}}{M}}{\nu G \uto \vec{T} \lto \outterm}}
}
\end{mathpar}

%% \todo{add definition of $un$ to this figure?}

\caption{Typing Rules for \mugv}\label{fig:gv-typing}
\end{figure}

Figure~\ref{fig:gv-typing} gives the typing rules of \mugv. The structural rules account for
variables, and for weakening and contraction of unlimited types. The rules for the functional terms
are standard; note that, to account for linearity, the context is split in the rules for application
and pair introduction and elimination, and is restricted to unlimited types in the introduction of
unlimited arrows.

The rules for input, output, choice and selection are those of \citet{GayVasconcelos10}.  Following
our earlier work~\citep{LindleyM14}, we provide a term $\gvlink{M}{N}$ to implement channel
forwarding.
%% ; while a version of \tkwd{link} exists for any session type $S$, it has no generic
%% implementation in terms of other constructs of \mugv.
The \tkwd{fork} construct provides session initiation; like Wadler's GV, but unlike LAST (and much
other work on process calculi), \mugv is deterministic. The rule for $\gvserve{x}{M}$ parallels that
for $\tkwd{fork}$: it defines a server which replicates $M$, and returns the channel by which it may
be used (of type $\gvdual{\gvserver{S}} = \gvservice{\gvdual{S}}$).

The novelty of \mugv is in its recursive and corecursive channels. The first two typing rules allow
recursive session types to be used as their unfoldings.
% SL: possibly restore this?
%% Previous work on recursive sessions has defined typing rules up to unfolding of recursive types. We
%% present explicit rules in order to simplify the translation into \mucp, in which these rules will
%% correspond to terms implementing the equivalences.
%
The construct $\gvfix{f}{c\,\vec{x}}{M}$ is used to define corecursive sessions. We illustrate its
use in the remainder of this section through a series of examples.

\paragraph{Syntactic Sugar.}
%
%For multi-argument functions, we write:
%\[
%\small
%  \bl
%  (T_1, \dots, T_n) \lto U \equiv T_1 \lto \dots \lto T_n \lto U \\
%  \langle T_1, T_2, \dots, T_n \rangle \uto U \equiv T_1 \uto T_2 \lto \dots \lto T_n \lto U \\
%  \el
%\]
%Note that the right-hand side of the second equation is isomorphic to $(T_1 \otimes \dots \otimes
%T_n) \uto U$.
%%
We write $\key{let}\:x=M\:\key{in}\:N$ for $(\lambda x.M)\:N$.


\paragraph{Base Types.}

For the purposes of our examples, we assume an extension of \mugv with a type of naturals ($Nat$),
suitable constants ($0,1,\dots$), addition ($+$), and multiplication ($\times$).

% natural number ($Nat$) and Boolean ($Bool$) base types along with constants ($0,1,\dots$),
% addition ($+$) and multiplication ($\times$), boolean constants ($True, False$), and conditionals
% ($\gvifthen{M}{N}{N'}$).
%
%% This does not change the expressivity of \mugv---we could encode each of these constructs using
%% processes, along the lines illustrated later for \mucp~\secref{peano}---but does significantly
%% streamline the presentation.

\subsection{Streams}

A canonical example of a corecursive data type is a stream. Let us consider a session type for
producing a stream of naturals.
%
\[\small
Source = \nu X.\with \{\clabel{next}: !Nat.X, \clabel{stop}: \outterm \}
\]
%
A channel of type $Source$ can either produce the next number or stop. The dual of a source is a
sink.
\[\small
Sink = \mu X.\oplus \{\clabel{next}: ?Nat.X, \clabel{stop}: \interm \}
\]
%
%Let us define a helper macro for generating the next value in a stream:
%\[\small
%\bl
%SendNext : \with \{\clabel{next}: !Nat.X, \clabel{stop}: \outterm \} \uto Nat \lto \outterm \\
%SendNext\:v\:c = \gvcase{c}{\clabel{next}\,c.\gvlet{c}{\gvsend{v}{c}}{f\:c};
%                            \clabel{stop}\,c.c}
%\el
%\]
%%
Using $\cofix$ we can define a function that sends a stream of zeros along a corecursive channel:
\[\small
  \bl
  MakeZeros : Source \uto \outterm \\
  MakeZeros = \cofix\:f\:c = \gvcase{c}{\clabel{next}\,c.\gvlet{c}{\gvsend{0}{c}}{f\:c};
                                        \clabel{stop}\,c.c}
  \el
\]
If the next number is chosen, then a zero is sent along the channel and we recurse. Otherwise we
stop.
%
%To read from a source, we can use $\key{fork}$ to create a sink:
%\[\small
%\gvfork{c}{MakeZeros\:c}
%\]
%
We define a helper macro to read the next value from a stream:
\[\small
\bl
GetNext : Sink \uto Nat \otimes Sink \\
GetNext\:c = \gvreceive{(\gvselect{\clabel{next}}{c})} \\
\el
\]
and now:
\[\small
\bl
\key{let}\:c = \gvfork{c}{MakeZeros\:c}\:\key{in} \\
\key{let}\:(x, c) = GetNext\:c\:\key{in}\:
\key{let}\:(y, c) = GetNext\:c\:\key{in}\:
\key{let}\:(z, c) = GetNext\:c\:\key{in} \\
\key{let}\:c = \gvselect{\clabel{stop}}{c}\:\key{in}\:(x, (y, z)) \\
\el
\]
begins by forking a stream of zeros, and then reads from the corresponding sink several times,
returning $(0, (0, 0))$.

%\paragraph{Simulating Weakening.}
%We might expect to be able to use the session type $\nu X.!Nat.X$ for streams. This does not work in
%a linear setting because in order to read from the stream we would need to use the dual session type
%$\mu X.?Nat.X$. We cannot write a program that uses this session type because it would have to
%consume an infinite amount of data in order to satisfy linearity. In essence, the $\clabel{stop}$
%case allows us to simulate weakening on such a channel.

\paragraph{Productivity.}
We might expect to assign $c$ the type $\with \{\clabel{next}:\:!Nat.Source, \clabel{stop}:\:\outterm
\}$ in the body of $MakeZeros$, but then productivity would not be assured. For example, under the
same typing assumptions for $f$ and $c$ we could write:
\[\small
\cofix\:f\:c = f\:c
\]
%
We restrict the typing rule for $\cofix$ in order to guarantee productivity. We use a fresh type
variable $X$ to abstract the recursive behavior, so the channel $c$ has type $G(X)$ (in our example
$\with \{\clabel{next}: !Nat.X, \clabel{stop}: \outterm \}$) instead of $G(\nu G)$, and $f$ has type
$X \uto \outterm$ instead of $\nu G \uto \outterm$. The body of $\cofix$ is thus required to provide
precisely one iteration of the recursive behavior.

\paragraph{Coinvariants.}

We allow recursive sessions to maintain internal state (a \emph{coinvariant}). In the $\cofix$
typing rule, this is captured by the additional arguments $\vec{x}$. For example, we can construct a
stream of consecutive naturals:
\[\small
\begin{array}{ll}
  \mcl{2}{MakeNats : Source \uto \outterm} \\
  MakeNats = \gvfix{nats}{c\:x}{\mkwd{case}\:c\:\{ &\clabel{next}\,c.\gvlet{c}{\gvsend{x}{c}}{nats\:c\:(x+1)}; \\
                                &\clabel{stop}\,c.c\}}
\end{array}
\]
The variable $x$ tracks the next value to send to the stream, and is accordingly incremented in the
recursive call. Now, the following:
\[\small
\bl
\key{let}\:c = \gvfork{c}{MakeNats\:c\:0\:1}\:\key{in} \\
\key{let}\:(x, c) = GetNext\:c\:\key{in}\:
\key{let}\:(y, c) = GetNext\:c\:\key{in}\:
\key{let}\:(z, c) = GetNext\:c\:\key{in} \\
\key{let}\:c = \gvselect{\clabel{stop}}{c}\:\key{in}\:(x,(y,z)) \\
\el
\]
returns $(0, (1, 2))$.
%
We can maintain coinvariants of arbitrary complexity; for example, we can define a
stream of the Fibonacci numbers as follows:
\[\small
\begin{array}{ll}
  \mcl{2}{MakeFibs : Source \uto \outterm} \\
  MakeFibs = \gvfix{fibs}{c\:m\:n}{\mkwd{case}\:c\:\{ &\clabel{next}\,c.\gvlet{c}{\gvsend{m}{c}}{fibs\:c\:n\:(m+n)}; \\
    &\clabel{stop}\,c.c\}}
\end{array}
\]

\subsection{Multi-function calculator}

Our next example is a simple multi-function calculator. Our goal is a session that accepts an
arbitrary stream of addition and multiplication requests, and can at any time provide the
accumulated result.  We can implement the provider of this session as follows:

\[\small
\bl
MakeCalc : Calc \uto Nat \lto \outterm \\
MakeCalc = \lrkwd\:calc\:c\:accum = \\
\quad
  \bl
  \mkwd{case}\:c\;\mkwd{of}\:\{
    \bl
    \clabel{add}\:c.
      \bl
      \mkwd{let}\:(x,c) = \gvreceive{c} \: \mkwd{in}\:
      calc\:c\:(accum + x) \\
      \el \\
    \clabel{mul}\:c.
      \bl
      \mkwd{let}\:(x,c) = \gvreceive{c}\:\mkwd{in}\:
      calc\:c\:(accum \times x) \\
      \el \\
    \clabel{result}\:c.
      \bl
      \mkwd{let}\:c = \gvsend{accum}{c}\:\mkwd{in}\:
      calc\:c\:accum \\
      \el \\
    \clabel{stop}\:c.c \; \}
    \el \\
  \el \\
\el
\]
The type of the recursive channel is:
\[\small
 Calc = \nu X. \with \{ \clabel{add}: \gvin{Nat}{X},
                        \clabel{mul}: \gvin{Nat}{X},
                        \clabel{result}: \gvout{Nat}{X},
                        \clabel{stop}: \outterm \}.
\]%
Here is a consumer of the service:
\[\small
\bl
  \gvlet{c}{\gvfork{c}{MakeCalc\:c\:0}}{} \\
  \gvlet{c}{\gvsend{6}{(\gvselect{\clabel{add}}{c})}}{
  \gvlet{c}{\gvsend{7}{(\gvselect{\clabel{mul}}{c})}}{}} \\
  \gvlet{(x,c)}{\gvreceive{(\gvselect{\clabel{result}}{c})}}{
  \gvlet{c}{\gvselect{\clabel{stop}}{c}}{x}}
\el
\]
We begin by constructing an instance of the calculator with the accumulator starting at 0. %; in the
%body of \tkwd{fork}, $c$ has the $\nu$-type given above, so the result of \tkwd{fork} (called
%$c$), has type:
%\[\small
%\mu X. \oplus \{ \clabel{add}: \gvout{Nat}{X}, \clabel{mul}: \gvout{Nat}{X}, \clabel{result}: \gvin{Nat}{X}, \clabel{stop}: \interm \}.
%\]
We perform several calculations, adding 6 to the accumulator and multiplying by 7.  Finally, we
obtain the result (42) and close the channel.

%\subsection{Bit Strings}
%%
%%\todo{Validating the translation requires extending the GV interpreter with Booleans, addition and
%%  multiplication.}
%
%We now adapt an example of \citet{Toninho13}, in which a string of bits (0 or 1) is represented by a
%chain of processes, each storing one bit. The chain supports operations to increment and retrieve
%the stored value as a natural encoded by the bit string. Each link in the chain functions as a
%one-bit adder.
%
%We begin with the type $Link$ of the links in the chain. Each is a recursive process supporting
%three operations: compute the natural value encoded by the chain, increment the chain, and dispose
%of the chain.
%%
%\[\small
% Link = \nu X. \with \{ \clabel{val}: \gvin{Nat}{\gvout{Nat}{X}},
%                        \clabel{inc}: \oplus \{ \clabel{carry}: X,
%                                                \clabel{done}: X \},
%                        \clabel{stop}: \outterm \}
%\]
%Choosing $\clabel{val}$ or $\clabel{inc}$ cascades down the chain from most- to least-significant
%bit. The former returns the computed value; the latter returns the carry bit.
%
%The simplest node is the terminator $Epsilon$. It adds nothing to the value, and cannot store a
%responds to increment requests with a carry.
%\[\small
%\bl
%Epsilon : Link \to \outterm \\
%Epsilon = \lrkwd\:c\:epsilon = \\
%\quad \mkwd{case}\:c\:\mkwd{of}\:\{
%  \bl
%  \clabel{val}\:c.
%    \bl
%    \gvlet{(n,c)}{\gvreceive{c}}{
%    \gvlet{c}{\gvsend{n}{c}}{
%    epsilon\:c}} \\
%    \el \\
%  \clabel{inc}\:c.
%    \bl
%    \gvlet{c}{\gvselect{\clabel{carry}}{c}}{
%    epsilon\:c} \\
%    \el \\
%  \clabel{stop}\:c. c\}  \\
%  \el \\
%\el
%\]
%
%We can now define internal nodes. In response to a value request, an internal node adds its value to
%the value accumulated so far, and passes the result to the next node in the chain; the response is
%passed up the chain unchanged. In response to an increment request, the bit flips, passing on a
%carry option if needed. Internal nodes require two state components: the represented bit ($b$) and
%the remainder of the chain ($d$).
%%
%\[\small
%\bl
%Node : Link \uto Bool \lto \gvdual{Link} \lto \outterm \\
%Node = \lrkwd\:node\:c\:b\:d = \\
%\quad
%  \bl
%  \mkwd{case}\:c\:\mkwd{of}\:\{
%      \bl
%      \clabel{val}\:c.
%        \bl
%        \gvlet{(m,c)}{\gvreceive{c}}{} \\
%        \gvlet{d}{\gvsend{(\gvifthen{b}{2 \times m + 1}{2 \times m})}{(\gvselect{\clabel{val}}{d})}}{} \\
%        \gvlet{(n,d)}{\gvreceive{d}}{
%        \gvlet{c}{\gvsend{n}{c}}{
%        node\:c\:b\:d}} \\
%        \el \\
%      \clabel{inc}\:c.
%        \bl
%        \mkwd{case}\:(\gvselect{\clabel{inc}}{d})\:\mkwd{of}\:\{ \\
%        \quad
%          \bl
%          \clabel{done}\:d. node\:(\gvselect{\clabel{done}}{c})\:b\:d \\
%          \clabel{carry}\:d.
%            \bl
%            \gvlet{c}{\gvifthen{b}{\gvselect{\clabel{carry}}{c}}{\gvselect{\clabel{done}}{c}}}{} \\
%            node\:c\:(not\:b)\:d \} \\
%            \el \\
%          \el \\
%        \el \\
%      \clabel{stop}\:c.\gvlet{d}{\gvselect{\clabel{stop}}{d}}{c} \} \\
%      \el \\
%  \el \\
%\el
%\]
%
%Now we can define the top level interface to a bit string. The interface supports the same three
%operations as the links---increment, retrieve value, and disposal---but with simpler behavior:
%\[\small
%  Count = \nu X. \with \{ \clabel{val}: \gvout{Nat}{X}, \clabel{inc}: X, \clabel{stop}: \outterm \}
%\]
%The implementation requires one state component, the first link of the chain (called $d$).
%\[\small
%\bl
%CounterImpl : Count \uto \gvdual{Link} \lto \outterm \\
%CounterImpl = \lrkwd\:counterImpl\:c\:d = \\
%\quad \mkwd{case}\:c\:\mkwd{of}\:\{
%  \bl
%  \clabel{val}\:c.
%     \bl
%     \gvlet{(n,d)}{\gvreceive{(\gvsend{0}{(\gvselect{\clabel{val}}{d})})}}
%     {counterImpl\:(\gvsend{n}{c})}\:d \\
%     \el \\
%  \clabel{inc}\:c.
%    \bl
%    \mkwd{case}\:\gvselect{\clabel{inc}}{d}\:\mkwd{of}\:\{ \\
%    \quad
%      \bl
%      \clabel{carry}\:d.
%         \bl
%         \gvlet{e}{\gvfork{e}{Node\:True\:d\:e}}{
%         counterImpl\:c\:e} \\
%         \el \\
%      \clabel{done}\:d.counterImpl\:c\:d\:\} \\
%      \el \\
%    \el \\
%  \clabel{stop}\:c.\gvlet{d}{\gvselect{\clabel{stop}}{d}}{c}\:\}
%  \el \\
%\el
%\]
%The value case uses the value behavior of the links, providing the initial value 0.  The increment
%option adds a new link to the chain if incrementing the existing chain requires
%carrying. $CounterImpl$ takes an initial chain as an argument. For a counter, we initialise this to
%the empty chain (encoding $0$):
%\[\small\bl
%  Counter : Count \uto \outterm \\
%  Counter = \lambda c.CounterImpl\:c\:(\gvfork{x}{Epsilon\:x}) \\
%\el\]
%Here is a simple example of using the counter:
%\[\small
%\bl
%\gvlet{c}{\gvfork{c}{Counter\:c}}{} \\
%\gvlet{(i,c)}{\gvreceive{(\gvselect{\clabel{val}}{c})}}{} \\
%\gvlet{(j,c)}{\gvreceive{(\gvselect{\clabel{val}}{(\gvselect{\clabel{inc}}{c})})}}{} \\
%\gvlet{(k,c)}{\gvreceive{(\gvselect{\clabel{val}}{(\gvselect{\clabel{inc}}{(\gvselect{\clabel{inc}}{c})})})}}{} \\
%\gvlet{c}{\gvselect{\clabel{stop}}{c}}{(i,j,k)}
%\el
%\]
%We begin by creating a new counter on channel $c$; we then perform a mixture of increment and value
%operations before closing the $c$ channel. The whole expression evaluates to $(0,1,3)$.
%

\section{A Linear Logic-Based Process Calculus}\label{sec:mucp}

\subsection{Types and Terms}

The types of \mucp are the propositions of CLL, extended with type operators $F$ and fixed points
$\mu F,\nu F$.
\[\small\begin{array}{@{}l@{~}r@{~}c@{~}l@{}}
  \text{Types} & A,B & ::= & A \otimes B \mid A \parr B \mid \bot \mid 1 \mid A \oplus B \mid A \with B \mid 0 \mid \top \\
   & & \mid & \cpbang{A} \mid \cpquery{A} \mid X \mid \cpdual{X} \mid \shade{\mu F} \mid \shade{\nu F} \\ \shaderow
   \text{Type Operators} & F & ::= & X.A \\
\end{array}\]
If $F = X.A$, define $F(B) = A[B/X]$.  The standard notion of CLL duality is extended to fixed
points in the expected fashion:
\[
\ba{@{}c@{\quad}c@{\quad}c@{\quad}c@{}}
\begin{eqs}
  \cpdual{(A \otimes B)} &=& \cpdual{A} \parr \cpdual{B} \\
  \cpdual{(A \parr B)} &=& \cpdual{A} \otimes \cpdual{B} \\
  \cpdual{(\cpbang{A})} &=& \cpquery{\cpdual{A}} \\
\end{eqs}
&
\begin{eqs}
  \cpdual{1} &=& \bot \\
  \cpdual{\bot} &=& 1 \\
  \cpdual{(\cpquery{A})} &=& \cpbang{\cpdual{A}} \\
\end{eqs}
&
\begin{eqs}
  \cpdual{(A \oplus B)} &=& \cpdual{A} \with \cpdual{B} \\
  \cpdual{(A \with B)} &=& \cpdual{A} \oplus \cpdual{B} \\ \shaderow
  \cpdual{(\nu F)} &=& \mu \cpdual{F} \\
\end{eqs}
&
\begin{eqs}
  \cpdual{\top} &=& 0 \\
  \cpdual{0} &=& \top \\ \shaderow
  \cpdual{(\mu F)} &=& \nu \cpdual{F} \\
\end{eqs} \\
\ea
\]
where $X^{\perp\perp}  = X$, and we define the dual of a type operator by $\cpdual{F} =
X.\cpdual{(F(\cpdual{X}))}.$ Note that, as for type operators in \mugv, $\cpdual{F(A)} =
\cpdual{F}(\cpdual{A})$.

\begin{figure}[float]
\small
\begin{mathpar}
\inferrule{ }{\cptyp{\link{x}{y}}{x:A,y:\cpdual{A}}}

\inferrule{\cptyp{P}{\Gamma,x:A} \\
           \cptyp{Q}{x:\cpdual{A},\Delta}}
          {\cptyp{\cut{x}{A}{P}{Q}}{\Gamma,\Delta}}

\inferrule{ }{\cptyp{x[].0}{x:1}}

\inferrule{\cptyp{P}{y:A,x:B,\Gamma}}
          {\cptyp{x(y).P}{x:A \parr B,\Gamma}}

\inferrule{\cptyp{P}{y:A,\Gamma} \\
           \cptyp{Q}{x:B,\Delta}}
          {\cptyp{x[y].(P \mid Q)}{x:A \otimes B,\Gamma,\Delta}}

\inferrule{\cptyp{P}{\Gamma}}
          {\cptyp{x().P}{x:\bot,\Gamma}}

\inferrule{\cptyp{P}{x:A_i,\Gamma}}
          {\cptyp{\sel{x}{in_i}.P}{x:A_1 \oplus A_2,\Gamma}}

\inferrule{\cptyp{P}{x:A,\Gamma} \\
           \cptyp{Q}{x:B,\Gamma}}
          {\cptyp{\case{x}{P;Q}}{x:A \with B,\Gamma}}

\inferrule{ }{\cptyp{\case{x}{}}{x:\top,\Gamma}}

\inferrule{\cptyp{P}{\Gamma}}{\cptyp{P}{x:\cpquery{A},\Gamma}}

\inferrule{\cptyp{P}{y:A,\Gamma}}{\cptyp{\derelict{x}{y}.P}{x:\cpquery{A},\Gamma}}

\inferrule{\cptyp{P}{x:\cpquery{A},x':\cpquery{A},\Gamma}}{\cptyp{P[x/x']}{x:\cpquery{A},\Gamma}}

\inferrule{\cptyp{P}{y:A,\cpquery{\Gamma}}}{\cptyp{\replicate{x}{y}.P}{x:\cpbang{A}, \Gamma}}

\shade{\inferrule{\cptyp{P}{x:F(\mu F), \Gamma}}
                 {\cptyp{\rec{x}.P}{x:\mu F,\Gamma}}}

\shade{\inferrule{\cptyp{P}{y:A,\Gamma} \\
                  \cptyp{Q}{y:\cpdual{A},x:F(A)}}
                 {\cptyp{\corec{x}{y}{A}{P}{Q}}{x:\nu F,\Gamma}}}
\end{mathpar}
\caption{Typing Rules for \mucp}\label{fig:cp-typing}
\end{figure}

\paragraph{Structural Rules.}

\mucp has two structural rules, axiom and cut.  We interpret the axiom $\link{x}{y}$ as channel
forwarding: actions on channel $x$ are mirrored on $y$, and vice versa.  Thus, $x$ and $y$ must have
dual type.  Cut $\cut{x}{A}{P}{Q}$ is interpreted as commuication between processes $P$ and $Q$ on
channel $x$; the duality of the typing of $x$ assures that the uses of the $x$ in $P$ and $Q$ are
compatible. As usual, we identify \mucp up to structural equivalence:
\begin{equations}
\small
  \cut{x}{A}{P}{Q} &\equiv& \cut{x}{\cpdual{A}}{Q}{P} \\
  \cut{x}{A}{P}{\cut{y}{B}{Q}{R}} &\equiv& \cut{y}{B}{\cut{x}{A}{P}{Q}}{R}, \quad \text{if $x \not\in fn(R)$} \\
\end{equations}%
%% Figure~\ref{fig:equivalences} gives the structural equivalences of \mucp terms.
%% The first two capture that cut is commutative and associative, while the last captures that a cut
%% against a use of the axiom rule provides channel substitution (we write $P[x/y]$ for the substution
%% of channel $y$ for channel $x$ in process $P$).

%% \begin{figure}
%% \small
%% \begin{equations}
%%   \cut{x}{A}{P}{Q} &\equiv& \cut{x}{\cpdual{A}}{Q}{P} \\
%%   \cut{x}{A}{P}{\cut{y}{B}{Q}{R}} &\equiv& \cut{y}{B}{\cut{x}{A}{P}{Q}}{R}, \quad \text{if $x \not\in fn(R)$} \\
%%   \cut{x}{A}{P}{\link{x}{y}} &\equiv& P[y/x] \\
%% \end{equations}
%% \caption{Structural Equivalences}\label{fig:equivalences}
%% \end{figure}

\paragraph{Input and Output.}

The multiplicative connectives $\parr$ and $\otimes$ are interpreted as input and output. The
process $x(y).P$ inputs channel $y$ on channel $x$, and continues as $P$. The process $x[y].(P \mid
Q)$ is interpreted as bound output: it sends a fresh name $y$ along $x$, spawns a process $P$ in
which $y$ is used, and continues as process $Q$ in which $x$ is used.  It amounts to the
$\pi$-calculus term $(\nu y) \overline{x}(y).(P \mid Q)$. We write $x[y].P$ as syntactic sugar for
$x[y'].(\link{y}{y'} \mid P)$. The units of $\parr$ and $\otimes$, $\bot$ and $1$ are interpreted as
nullary input and nullary output, respectively.

\paragraph{Selection and Choice.}

The additive connectives $\oplus$ and $\with$ are interpreted as selection and choice. The process
$\case{x}{P_1;P_2}$ offers a choice of processes $P_1$ and $P_2$; dually, the process
$\sel{x}{in_i}.P_i$ chooses the $i$-th alternative. The unit for choice is $0$, indicating
absurdity. Note that there is no term proving $0$. The dual of absurdity is $\top$, and provides
arbitrary behavior; as there is no term proving $0$, no term relying on $\top$ can reduce.

\paragraph{Replication and Dereliction.}

The exponential connectives $!$ and $?$ in linear logic provide limited access to the classical
rules of weakening and contraction.  We interpret them as providing replicated processes.
% a process with type $\cpbang{A}$ provides arbitrarily many copies of a process providing behavior
% $A$, while a process of type $\cpquery{A}$ can choose to use one, many, or none of those copies.
There are three rules for types $\cpquery{A}$; uses of weakening and contraction implicit in \mucp
terms. Since the process $P$ proving $A$ may be replicated arbitrarily, each channel that $P$ uses
must be replicatable as well.  We write $\cpquery{\Gamma}$ to require that all types in $\Gamma$ be
of the form $\cpquery{B}$.

\paragraph{Recursion and Corecursion.}

We introduce least fixed points $\mu F$ and greatest fixed points $\mu F$ to CP, following
Baelde's~\citeyearpar{Baelde12} proof theoretic treatment of fixed points in linear logic.  The
proof rules can be understood from traditional two-sided rules for least and greated fixed points,
combined with the duality between the fixed points. We begin with a two-sided presentation:
%
{\small
\begin{mathpar}
\inferrule{F(A) \vdash A \\ \Gamma, A \vdash B}{\Gamma, \mu F \vdash B}

\inferrule{\Gamma \vdash F (\mu F)}{\Gamma \vdash \mu F}

\inferrule{\Gamma, F (\nu F) \vdash B}{\Gamma, \nu F \vdash B}

\inferrule{A \vdash F(A) \\ \Gamma \vdash A}{\Gamma \vdash \nu F}
\end{mathpar}}%
Functional programmers may recognize the first as the typing rule of a fold, and the fourth as the
typing rule of an unfold. We adapt the above rules to a one sided presentation as follows. (As
$\Gamma$ denotes any context, we write $\Gamma$ instead of $\cpdual{\Gamma}$).
%
{\small
\begin{mathpar}
\inferrule{\vdash \cpdual{F}(\cpdual{A}),A \\ \vdash \Gamma,\cpdual{A},B}{\vdash \Gamma,\nu \cpdual{F},B}

\inferrule{\vdash \Gamma, F (\mu F)}{\vdash \Gamma, \mu F}
\\

\inferrule{\vdash \Gamma, \cpdual{F}(\mu \cpdual{F}), B}{\vdash \Gamma, \mu \cpdual{F}, B}

\inferrule{\vdash \cpdual{A}, F(A) \\ \vdash \Gamma, A}{\vdash \Gamma, \nu F}
\end{mathpar}
}%
However, now we can observe that $\Gamma,B$ is itself an instance of a context, and $\cpdual{F}$ a
type operator, and so the four rules above are just two instances each of the two rules below.
{\small
\begin{mathpar}
\inferrule{\vdash \Gamma, F (\mu F)}{\vdash \Gamma, \mu F}

\inferrule{\vdash \cpdual{A}, F(A) \\ \vdash \Gamma, A}{\vdash \Gamma, \nu F}
\end{mathpar}}%
These are the typing rules for the \mucp terms $\rec{x}.P$ and $\corec{x}{y}{}{P}{Q}$.  As in \mugv,
\tkwd{corec} terms maintain a coinvariant, of type $A$.  The coinvariant can be seen as being
received on $y$ and sent on $x$; thus, its type is dual in $y$ and $x$. As messages are not dual in
\mugv sessions, no corresponding duality appears the typing rule for $\lrkwd$.

\subsection{Cut Elimination}

\begin{figure}[float]\small
\begin{equations}
\cut{x}{A}{\link{w}{x}}{P}
  &\Longrightarrow& P[w/x] \\
\cut{x}{A \otimes B}{x[y].(P \mid Q)}{x(y).R}
  &\Longrightarrow&
    \cut{y}{A}{Q}{\cut{x}{B}{P}{R}} \\
\cptyp{\cut{x}{1}{x[].0}{x().P}}{\Gamma}
  &\Longrightarrow&
    P \\
\cut{x}{A \oplus B}{\sel{x}{in_i}.P}{\case{x}{Q_1; Q_2}}
  &\Longrightarrow&
    \cut{x}{A}{P}{Q_i} \\
\cut{x}{\cpbang{A}}{\replicate{x}{y}.P}{\derelict{x}{y}.Q}
  &\Longrightarrow&
    \cut{y}{A}{P}{Q} \\
\cut{y}{\cpbang{A}}{\replicate{x}{y}.P}{Q}
  &\Longrightarrow&
     Q, \qquad x \notin FV(Q) \\
\cut{x}{\cpbang{A}}{\replicate{x}{y}.P}{Q[x/x']}
  &\Longrightarrow&
    \cut{x}{\cpbang{A}}{\replicate{x}{y}.P}{\cut{x'}{\cpbang{A}}{\replicate{x'}{y}.P}{Q}} \\ \shaderow
\key{new}\:x^{\nu F} %{\nu F}
  (\corec{x}{y}{B}{P}{Q} \mid \rec{x}.R)
  &\Longrightarrow&
    \cut{y}{B}{P}{\cut{x}{F(B)}{Q}{\cut{z}{F(\nu F)}{E}{R[z/x]}}} \\ \shaderow
&& \text{where }E = \map{F}{z,x}{\corec{z}{y}{B}{\link{x}{y}}{Q[z/x]}}
\end{equations}%
\caption{Principal Cut Elimination Rules}\label{fig:beta-reduction}
\end{figure}



\begin{figure}[float]
\small
\begin{equations}
  \map{X.C}{x,w}{Q} &=& \link{x}{w} \\
  \map{X.X}{x,w}{Q} &=& Q \\
  \map{X.C_1 \otimes C_2}{x,w}{Q} &=& w(z).x[y].(\map{X.C_1}{y,z}{Q[y/x,z/w]} \mid \map{X.C_2}{x,w}{Q}) \\
  \map{X.C_1 \oplus C_2}{x,w}{Q} &=&
    \case{w}{\sel{x}{in_1}.\map{X.C_1}{x,w}{Q}; \sel{x}{in_2}.\map{X.C_2}{x,w}{Q}} \\
  \map{X.\cpquery{C}}{x,w}{Q} &=& \replicate{w}{w'}.\derelict{x}{x'}.Q[x'/x,w'/x] \\ \shaderow
  \map{X.\mu F'}{x,w}{Q} &=& \corec{w}{y}{\nu(\cpdual{C}(A))}{\link{x}{y}}{\rec{y}.\map{X.F' (\mu F')}{y,w}{Q[y/x]}}
\end{equations}
\caption{Definition of $\mapname$ for positive combinators.}\label{fig:map}
\end{figure}

Cut elimination corresponds to process reduction.  The principal cut reductions are given in
Fig.~\ref{fig:beta-reduction}. The majority of these are standard; for instance, cut reduction of
$\with$ against $\oplus$ corresponds to picking one of the offered alternatives.  Cut reduction for
fixed points corresponds to unrolling one iteration from the \tkwd{corec} term, directed by the type
of the fixed point operator $F$.  It depends on a proof construction known as functoriality, which
derives the following proof rule for any type operator $F$:
\[\small
\inferrule{\vdash A,B}{\vdash F(A),\cpdual{F}(B)}
\]
We call the term implementing this construction $\mapname$ by analogy with a similar construct in
functional programming: taking $C = \cpdual{B}$, the above proof rule gives a transformation from a
proof of $C \lto A$ to one of $F(C) \lto F(A)$.  The positive cases of $\mapname$ are given in
Fig.~\ref{fig:map}; the remaining cases are obtained by exchanging channels $x$ and $w$.

\begin{lemma}
  If $\cptyp{Q}{x:A,w:B}$ then \(\cptyp{\map{F}{x,w}{Q}}{x:F(A), w:\cpdual{F}(B)}.\)
\end{lemma}

\begin{figure}[float]
\small
\begin{equations}
  \cut{x}{A}{z(y).P}{Q} &\Longrightarrow& z(y).\cut{x}{A}{P}{Q} \\
  \cut{x}{A}{z[y].(P \mid Q)}{R} &\Longrightarrow& z[y].(\cut{x}{A}{P}{R} \mid Q) \text{\quad \quad if $x \not\in fn(Q)$} \\
  \cut{x}{A}{z[y].(P \mid Q)}{R} &\Longrightarrow& z[y].(P \mid \cut{x}{A}{Q}{R}) \text{\quad \quad if $x \not\in fn(P)$} \\
  \cut{x}{A}{\sel{z}{in_i}.P}{Q} &\Longrightarrow& \sel{z}{in_i}.\cut{x}{A}{P}{Q} \\
  \cut{x}{A}{\case{z}{P;Q}}{R} &\Longrightarrow& \case{z}{\cut{x}{A}{P}{R}; \cut{x}{A}{Q}{R}} \\ \shaderow
  \cut{x}{A}{\rec{z}.P}{Q} &\Longrightarrow& \rec{z}.\cut{x}{A}{P}{Q} \\ \shaderow
  \cut{x}{A}{\corec{z}{y}{B}{P}{Q}}{R} &\Longrightarrow& \corec{z}{y}{B}{\cut{x}{A}{P}{R}}{Q} \\
\end{equations}
\caption{Commuting conversions}\label{fig:commuting}
\end{figure}

The commuting conversions push communication under process prefixes, and are given in
Fig.~\ref{fig:commuting}.  We can show that cut reduction preserves typing.

\begin{theorem}
  If $\cptyp{P}{\Gamma}$ and $P \Longrightarrow Q$, then $\cptyp{Q}{\Gamma}.$
\end{theorem}

Define $\Longrightarrow^\star$ to be the reflexive, transitive closure of $\equiv\Longrightarrow\equiv$.

\begin{theorem}\label{thm:cut-reduction}
  If $\cptyp{P}{\Gamma}$, then there is a $Q$ such that $P \Longrightarrow^\star Q$ and the final
  rule in the derivation of $Q$ is not an instance of cut.
\end{theorem}

Note that while we commute cuts under prefixes, we do not perform cut reduction under prefixes.
This corresponds to the usual notions of process communication.  Were we to extend our reduction
rules with congruence rules for each operator, we could then extend Theorem~\ref{thm:cut-reduction}
to show elimination of all cuts in a well-typed \mucp term.

\subsection{Streams}

We can use \mucp fixed points to encode streams of naturals.
\begin{equations}
  Sink &=& \mu X. \oplus \{ \clabel{next}: Nat \parr X, \clabel{stop}: \bot \}, \\
  Source &=& \nu X. \with \{ \clabel{next}: Nat \otimes X, \clabel{stop}: 1 \} \\
\end{equations}%
As in \mugv, we assume that our language is extended with constants implementing unlimited
natural numbers. In particular, we will assume there is some proposition $Nat$ and terms:
\[\small
\begin{eqs}
Zero_x &\vdash& x:\cpquery{Nat} \\
Inc_{y,x} &\vdash& y:\cpbang{\cpdual{Nat}},x:\cpquery{Nat} \\
\end{eqs}
\]
providing zero and successor.

%% Note that, following the typical treatment of duality in linear logic, we have that
%% $\cpdual{(Source(A))} = Sink(\cpdual{A})$.

We can define a process which generates a stream of zeros. In this example, we make no use of the
coinvariant, and so assign it the type $1$:
\[\small\begin{eqs}
  Zeros_y &\vdash& y:Stream(\cpquery{Nat}) \\
  Zeros_y &=& \corec{y}{z}{1}{z[].0}{z().\case{y}{\clabel{next}: y[x].(Zero_x | y[].0); \clabel{stop}: y[].0}}.
\end{eqs}\]
Now we define a process which generates a stream of naturals. As in the corresponding \mugv example,
we use the coinvariant represent the next number in the stream.
%
\[\small
\bl
  Nats_y \vdash y:Stream(\cpquery{Nat}) \\
  Nats_y = \lrkwd \: y \langle z \rangle (Zero_z,
    \key{case}\:y \:\{
       \bl
       \clabel{next}: y[x].(\link{z}{x} \mid \cut{w}{}{Inc_{z,w}}{\link{w}{y}}) \\
       \clabel{stop}: y[].0\}) \\
       \el \\
\el
\]
%
In the $\clabel{stop}$ case, we rely on weakening for $\cpquery{Nat}$ to dispose of the coinvariant.
In the $\clabel{next}$ case, we rely on contraction to copy the coinvariant $z$.  We then send one
copy along the channel $y$ and increment the other giving $w$, which we use to re-establish the
coinvariant.

\section{Relating \mugv and \mucp}\label{sec:translation}

In our previous work~\citep{LindleyM14} we give translations between CP and HGV, an extension of GV,
corresponding to \mugv without recursive session types. In this section, we extend these
translations to incorporate recursion.

\subsection{Translation from \mugv to \gvpi}\label{sec:gvtogvpi}

Following our previous work, we factor the translation of \mugv into \mucp through an intermediate
translation. The language \gvpi is the restriction of \mugv to session types; that is, \mugv without
$\lto$, $\uto$, or $\otimes$. In order to avoid $\otimes$, we permit $\gvreceive{M}$, only fused
with a pair elimination $\gvlet{(x, y)}{\gvreceive{M}}{N}$. We can simulate all non-session types as
session types via a translation from \mugv to \gvpi.  The translation on types is exactly as in our
previous work. It is given by the homomorphic extension of the following equations:
%\[
%\ba{@{}rclcl@{}}
%\topi{T \lto U}    &=& \gvdual{\gvin{\gvdual{\topi{T}}}{\topi{U}}}
%                   &=& \gvout{\topi{T}}{\gvdual{\topi{U}}} \\
%\topi{T \uto U}    &=& \gvdual{\gvserver{(\gvin{\topi{\gvdual{T}}}{\topi{U}})}}
%                   &=& \gvservice{(\gvout{\topi{T}}{\gvdual{\topi{U}}})} \\
%\topi{T \otimes U} &=& \gvdual{\gvout{\gvdual{T}}{\topi{U}}}
%                   &=& \gvin{\gvdual{\topi{T}}}{\gvdual{\topi{U}}} \\
%\ea
%\]
\[\small
\ba{@{}c@{}}
\topi{T \lto U} = \gvout{\topi{T}}{\topi{U}} \qquad
\topi{T \uto U} = \gvservice{(\gvout{\topi{T}}{\topi{U}})} \\
\topi{T \otimes U} = \gvin{\topi{T}}{\topi{U}} \\
\ea
\]
Each target type is the interface to the simulated source type. A
linear function is simulated by input on a channel; its interface is
output on the other end of the channel. An unlimited function is
simulated by a server; its interface is the service on the other end
of that channel. A tensor is simulated by output on a channel; its
interface is input on the other end of that channel. This duality
between implementation and interface explains the flipping of types in
Wadler's original CPS translation from GV to CP.

In order to translate away the arrows in the $\lrkwd$ rule, we
adopt a simplified session-oriented variant of the $\lrkwd$ rule
for \gvpi.
%
{\small
\begin{mathpar}
\inferrule{\gvtyp{p:\gvservice{(\gvout{X}{\gvout{T}{\outterm}})}, c:G(X), x:T}{M}{\outterm}}
          {\gvtyp{\Phi}{\gvfix{p}{c\:x}{M}}{\gvservice{(\gvout{\nu G}{\gvout{T}{\outterm}})}}}
\end{mathpar}}%
%
This rule takes advantage of the translation of functions given by $\topi{-}$, and simulates
multiple arguments using $\otimes$.

\begin{figure}[float]\small
\begin{equations}
\topi{\lambda x.M} &=& \gvfork{z}{\gvlet{(x, z)}{\gvreceive{z}}{\gvlink{\topi{M}}{z}}} \\
\topi{L\,M} &=& \gvsend{\topi{M}}{\topi{L}} \\
\topi{M, N} &=&
  \gvfork{z}
    {\gvlink{(\gvsend{\topi{M}}{z})}{\topi{N}}} \\
\topi{\gvlet{(x, y)}{M}{N}} &=&
    \gvlet{(x, y)}{\gvreceive{\topi{M}}}{\topi{N}} \\
\topi{L : T \uto U} &=&
  \gvserve{z}{\gvlink{\topi{L}}{z}} \\
\topi{L : T \lto U} &=& \gvrequest{\topi{L}} \\
\topi{\gvreceive{M}} &=& \topi{M}
\\ \shaderow
\topi{\gvfix{f}{c\,\vec{x}}{M}} &=&
  \gvfix{p}{z\,c}{\gvlet{\vec{x}}{z}{\topi{M[L/f]}}} \\ \shaderow
&& \text{where }L = \lambda\,c\,\vec{x}.\gvsend{\vec{x}}{(\gvsend{c}{(\gvrequest{p})})} \\
\end{equations}%
\caption{Translation of \mugv terms to \gvpi.}\label{fig:togvpi}
\end{figure}

The translation on terms is given by the homomorphic extension of the equations in
Fig.~\ref{fig:togvpi}.  Formally, this is a translation from derivations to terms. We write type
annotations to indicate $\to$ introduction and elimination.
% For all other cases, it is unambiguous to give the translation
% on plain term syntax. Each introduction form translates to an interface $\gvfork{z}{M}$ of type
% $\gvdual{S}$, where $M : \outterm$ provides the implementation, with $z : S$ bound in $M$.
%
The only new case is that for $\key{corec}$. We collect the arguments into a tuple, and simulate the
interface to the arrows using session operations as in the rest of the $\topi{-}$ translation.

Let $\topi{\Phi}$ be the pointwise extension of $\topi{T}$. It is straightforward to verify that our
translation preserves typing.
\begin{theorem}
If $\gvtyp{\Phi}{M}{T}$ then $\gvtyp{\topi{\Phi}}{\topi{M}}{\topi{T}}$.
\end{theorem}

\subsection{Translation from \gvpi to \mucp}\label{sec:gvpitocp}

\begin{figure}[float]\small
\begin{equations}
\small
\left\llbracket \inferrule{\gvtyp{\Phi}{N}{S}}{\gvtyp{\Phi,x:\interm}{N}{S}} \right\rrbracket\!\!z &=&
  \inferrule
    {\cptyp{\tocp{N}z}{\tocp{\Phi},z:\cpdual{\tocp{S}}}}
    {\cptyp{x().\tocp{N}z}{\tocp{\Phi},x:\bot,z:\cpdual{\tocp{S}}}}
\\[3ex]
\left\llbracket \inferrule{\gvtyp{\Phi,x:\interm,x':\interm}{N}{S}}
                          {\gvtyp{\Phi,x:\interm}{N[x/x']}{S}} \right\rrbracket \!\!z &=&
  \inferrule
    {\cptyp{\tocp{N}z}{\tocp{\Phi},x:\bot,x':\bot,z:\cpdual{\tocp{S}}}}
    {\cptyp{\cut{x'}{}{\tocp{N}z}{x'[].0}}{\tocp{\Phi},x:\bot,z:\cpdual{\tocp{S}}}}
\\[3ex]
\tocp{x}z &=& \link{x}{z} \\
\tocp{\gvsend{M}{N}}z &=& \cut{x}{}{x[y].(\tocp{M}y \mid \link{x}{z})}{\tocp{N}x} \\
\tocp{\gvlet{(x,y)}{\gvreceive{M}}{M}}z &=& \cut{y}{}{\tocp{M}y}{y(x).\tocp{N}z} \\
\tocp{\gvselect{l}{M}}z &=& \cut{x}{}{\tocp{M}x}{x[l].\link{x}{z}} \\
\tocp{\gvcase{M}{l_n\,x.N_i}}z &=&  \cut{x}{}{\tocp{M}x}{\case{x}{l_i.\tocp{N_i}z}} \\
\tocp{\gvfork{x}{M}}z &=& \cut{x}{}{\cut{y}{}{\tocp{M}y}{y[].0}}{\link{x}{z}} \\
\tocp{\gvlink{M}{N}}z &=& z().\cut{x}{}{\tocp{M}x}{\tocp{N}x} \\
\tocp{\gvserve{y}{M}}z &=& \replicate{z}{y}.\cut{x}{}{\tocp{M}x}{x[].0} \\
\tocp{\gvrequest{M}}z &=& \cut{x}{}{\tocp{M}x}{\derelict{x}{y}.\link{y}{z}} \\[3ex] \shaderow
\tocpbig{\inferrule{\gvtyp{\Phi}{M}{\mu G}}{\gvtyp{\Phi}{M}{G (\mu G)}}}\!\!z &=&
  \cut{y}{\nu \tocp{G}}{\tocp{\gvtyp{\Phi}{M}{\mu G}}y}{\rec{y}.\link{y}{z}} \\[3ex] \shaderow
\tocpbig{\inferrule{\gvtyp{\Phi}{M}{G(\mu G)}}{\gvtyp{\Phi}{M}{\mu G}}}\!\!z &=&
\key{new}\:y\:
  \bl
  (    %{\tocp{G}(\mu \tocp{G})}
       {\tocp{\gvtyp{\Phi}{M}{G (\mu G)}}}y \\
  \mid \corec{z}{x}{\tocp{G}(\mu \tocp{G})}
             {\link{y}{x}}
             {\map{G}{x,z}{\rec{x}.\link{x}{z}}}) \\
  \el \\
\end{equations}%
\[\small
\shade{
\bl
\left\llbracket
\inferrule{\gvtyp{p:\gvservice{(\gvout{T}{\gvout{X}{\outterm}})},c:G(X),x:T}{M}{\outterm}}
          {\gvtyp{}{\gvfix{p}{c\,x}{M}}{\gvservice{(\gvout{\nu G}{\gvout{T}{\outterm}})}}}
\right\rrbracket\!\!z = \\
\replicate{z}{y}.y(c).y(x).y(). \\
\quad \corec{c}{w}{}{w[x].w[].0}{\cut{p}{}{\replicate{p}{y}.y(c).y(x).y().c[x].c[].0}{w(x).\tocp{M}w}} \\
\el}
\]
\caption{Translation of \gvpi terms into \mucp.}\label{fig:tomucp}
\end{figure}

We now give a translation from \gvpi to CP. Post composing this with the embedding of \mugv in \gvpi
yields a semantics for \mugv. The translation on session types is as follows:
\[\small
\ba{@{}c@{\qquad}c@{\qquad}c@{}}
\begin{eqs}
\tocp{\gvout{T}{S}}        &=& \cpdual{\tocp{T}} \otimes \tocp{S} \\
\tocp{\gvin{T}{S}}         &=& \tocp{T} \parr \tocp{S} \\
\tocp{\gvservice{S}}       &=& \cpquery{\tocp{S}} \\
\tocp{\gvserver{S}}        &=& \cpbang{\tocp{S}} \\
\end{eqs}
&
\begin{eqs}
\tocp{\oplus \{l_i:S_i \}} &=& \oplus \{l_i:\tocp{S_i}\} \\
\tocp{\with \{l_i:S_i \}}  &=& \with \{l_i:\tocp{S_i}\} \\ \shaderow
\tocp{\nu G}               &=& \nu\tocp{G} \\ \shaderow
\tocp{\mu G}               &=& \mu\tocp{G} \\ \shaderow
\tocp{X.S}                 &=& X.\tocp{S} \\
\end{eqs}
&
\begin{eqs}
\tocp{\outterm}            &=& 1 \\
\tocp{\interm}             &=& \bot \\
\tocp{X}                   &=& X \\
\tocp{\gvdual{X}}          &=& \cpdual{X} \\
\end{eqs}\\
\ea
\]
The translation is homomorphic except for output, where the argument type is dualised. This accounts
for the discrepancy between $\gvdual{\gvout{T}{S}} = \gvin{T}{\gvdual{S}}$ and $\cpdual{(A \otimes
  B)} = \cpdual{A} \parr \cpdual{B}.$
%
The translation on terms (Fig.~\ref{fig:tomucp}) is formally specified as a CPS translation on
derivations as in Wadler's presentation. We provide the full translations of weakening and
contraction for $\interm$, and for rolling and unrolling of recursive session types $\nu G$ and $\mu
G$, as these steps are implicit in the syntax of \mugv terms. The other constructs depend only on
the immediate syntactic structure, so we abbreviate their translations as mappings on plain
terms. The majority of translations are as in our previous work.  The folding and unfolding of least
fixed points in GV can be translated to cuts against the CP proofs of the corresponding
equivalences. The translation of $\cofix$ is a corecursive process in which the \mugv coinvariant of
type $T$ is represented as a \mucp coinvariant of type $\tocp{T} \otimes 1$.  We initially read the
coinvariant $x$ from a channel $w$, and provide a channel $p$ which abstracts re-establishing the
coinvariant at the end of each iteration.

%% SL: now mention this earlier
%%
%% In both, we rely on syntactic sugar for output: $x[y].P \equiv x[y'].(\link{y}{y'} \mid P)$.

% ; for example, unfolding the GV session type $\mu G$ to $G
% (\mu G)$ corresponds to the CP proof that $\nu F \lto F(\mu F)$.
%% The folding and unfolding of recursive session types in GV can be translated to cuts against the CP
%% proofs of the corresponding equivalences; for example, unfolding the GV session type $\mu G$ to $G
%% (\mu G)$ corresponds to the CP proof that $\nu F \lto F(\mu F)$. Note the parallels between the
%% first two and last two cases: this aligns with the derivation of the rules for $\mu$ and $\nu$ in
%% \mucp.
%% \begin{gather*}
%% \tocpbig{\inferrule{\gvtyp{\Phi}{M}{\mu G}}{\gvtyp{\Phi}{M}{G (\mu G)}}} z =
%%   \cut{y}{\nu \tocp{G}}{\tocp{\gvtyp{\Phi}{M}{\mu G}}y}{\rec{y}.\link{y}{z}} \\[3ex]
%% \tocpbig{\inferrule{\gvtyp{\Phi}{M}{G(\nu G)}}{\gvtyp{\Phi}{M}{\nu G}}} z =
%%   \cut{y}{\nu \tocp{G}}{\tocp{\gvtyp{\Phi}{M}{G(\nu G)}}y}{\rec{z}.\link{y}{z}} \\[3ex]
%% \tocpbig{\inferrule{\gvtyp{\Phi}{M}{G(\mu G)}}{\gvtyp{\Phi}{M}{\mu G}}} z =
%% \cut{y}{\tocp{G}(\mu \tocp{G})}{\tocp{\gvtyp{\Phi}{M}{G (\mu G)}}}
%%        {\corec{z}{x}{\tocp{G}(\mu \tocp{G})}
%%               {\link{y}{x}}
%%               {\map{G}{x,z}{\rec{x}.\link{x}{z}}}}
%% \\[3ex]
%% \tocpbig{\inferrule{\gvtyp{\Phi}{M}{\nu G}}{\gvtyp{\Phi}{M}{G (\nu G)}}} z =
%% \cut{y}{\mu \tocp{G}}{\tocp{\gvtyp{\Phi}{M}{\nu G}}}
%%        {\corec{y}{x}{\cpdual{\tocp{G}}(\nu \cpdual{\tocp{G}})}
%%               {\link{z}{x}}
%%               {\map{G}{x,y}{\rec{x}.\link{x}{y}}}}
%% \end{gather*}
%
%

\begin{theorem}
  If $\gvtyp{\Phi}{M}{T}$, then $\cptyp{\tocp{M}z}{\tocp{\Phi},z:\cpdual{\tocp{T}}}$.
\end{theorem}

Note that the type environment $\Phi$ is not dual in the result of the translation.  This reflects
the different interpretations of types in \mucp and \mugv: a \mugv type $\gvout{T}{S}$ designates a
channel that expects output, whereas the \mucp type $T \otimes S$ designates a process that performs
output.

\subsection{Translating from \mucp to \gvpi}\label{sec:cptogvpi}

\begin{figure}[float]\small
\begin{equations}
\small
  \togv{x[y].(P \mid Q)} &=&
    \gvlet{x}{\gvsend{(\gvfork{y}{\togv{P}})}{x}}{\togv{Q}} \\
  \togv{x(y).P} &=&
    \gvlet{(y,x)}{\gvreceive{x}}{\togv{P}} \\
  \togv{\sel{x}{\mathit{l}}.P} &=&
    \gvlet{x}{\gvselect{l}{x}}{\togv{P}} \\
  \togv{\case{x}{l_i.P_i}} &=&
    \gvcase{x}{l_i.\togv{P_i}} \\
  \togv{x[].0} &=& x \\
  \togv{x().P} &=& \togv{P} \\
  \togv{\cut{x}{}{P}{Q}} &=&
    \gvlet{x}{\gvfork{x}{\togv{P}}}{\togv{Q}} \\
  \togv{\link{x}{y}} &=& \gvlink{x}{y} \\
  \togv{\replicate{s}{x}.P} &=&
    \gvlink{s}{(\gvserve{x}{\togv{P}})} \\
  \togv{\derelict{s}{x}.P} &=&
    \gvlet{x}{\gvrequest{s}}{\togv{P}} \\ \shaderow
  \togv{\rec{x}.P} &=& \togv{P} \\ \shaderow
  \togv{\cptyp{\corec{c}{x}{}{P}{Q}}{\Gamma, c:\nu F}} &=&
    \key{send}\:c\:(
      \key{send}\:
         \bl
         (\gvfork{x}{\togv{P}}) \\
         (\gvrequest{(\gvfix{p}{c\,x}{Q_{F,p,c,x}})})) \\
         \el \\ \shaderow
\multicolumn{3}{@{}l@{}}
{\qquad\text{where }
  Q_{F,p,c,x} =
    \gvlet{c'}{\gvfork{c}{\togv{Q}}}
          {\togv{\map{F}{c,c'}{\derelict{p}{z}.z[c].z[c'].z[].0}}}}
\end{equations}%
\caption{Translation of \mucp terms into \gvpi.}\label{fig:fromcp}
\end{figure}

We now present the translation $\togv{-}$ from CP to \gvpi. The translation on types is as follows:
\[\small
\ba{@{}c@{\qquad}c@{\qquad}c@{}}
\begin{eqs}
\togv{A \otimes B} &=& \gvout{\gvdual{\togv{A}}}{\togv{B}} \\
\togv{A \parr B}   &=& \gvin{\togv{A}}{\togv{B}} \\
\togv{\cpbang{A}}   &=& \gvservice{\togv{A}} \\
\togv{\cpquery{A}}  &=& \gvserver{\togv{A}} \\
\end{eqs}
&
\begin{eqs}
\togv{+\{l_i:A_i\}_i}     &=& +\{l_i:\togv{A_i}\}_i  \\
\togv{\with\{l_i:A_i\}_i} &=& \with\{l_i:\togv{A_i}\}_i \\ \shaderow
\togv{\nu F} &=& \nu \togv{F} \\ \shaderow
\togv{\mu F} &=& \mu \togv{F} \\ \shaderow
\togv{X.A} &=& X.\togv{A} \\
\end{eqs}
&
\begin{eqs}
\togv{1}           &=& \outterm \\
\togv{\bot}              &=& \interm \\
\togv{X}            &=& X \\
\togv{\cpdual{X}}   &=& \gvdual{X} \\
\end{eqs}
\ea
\]
The translation on terms makes use of $\key{let}$ expressions to simplify the presentation; these
are expanded to \gvpi as follows:
\[\small
\gvlet{x}{M}{N} \equiv
  \topi{(\lambda x.N) M} \equiv
  \gvsend{M}{(\gvfork{z}{\gvreceivek{x}{z}{z}{\gvlink{N}{z}}})}
\]%
The translation on terms is given in Fig.~\ref{fig:fromcp}. Formally, the translation is actually
from derivations to terms. The interesting case, which is the only one to use the type environment,
is $\key{corec}$. The translation must simulate the expansion of the term $Q$, using $p$ to
re-establish the coinvariant after each expansion, and thus depends on the translation of
functoriality from \mucp to \mugv.


%% % \[
%% %   Q^\dagger =
%% %     \gvlet{c}
%% %           {\gvfork{x}{\togv{Q}}}
%% %           {\gvmap{\togv{F}}{x,c}{(\gvsend{c}{(\gvsend{x}{p})})}}
%% % \]%
%% % \[
%% %   Q^\dagger =
%% %     \gvlet{y'}
%% %           {\gvfork{y}{\togv{Q}}}
%% %           {\togv{\map{F}{x,c}{p[x].p[c].p[].0}}}
%% % \]%

%% The translation is the same as in our previous work~\cite{LindleyM14} except for recursion and
%% corecursion. Formally, it is a translation from judgements to terms (as we need to know the type
%% operator in the case of $\key{corec}$).

%
%% \[
%%   Q^\dagger = \gvlet{d}{\gvfork{x}{\togv{Q}}}{\gvmap{\togv{F}}{c,d}{(\gvsend{c}{(\gvsend{d}{p})})}}.
%% \]


%% We can transfer the functoriality result from \mucp to \mugv:

%% \begin{lemma}
%%   If $\cptyp{Q}{y:\cpdual{A},x:F(A)}$, then
%%   \[
%%     \gvtyp{x:\gvdual{\togv{A}},p:\gvservice{(\gvout{\gvdual{\togv{A}}}{\gvout{X}{\outterm}})},c:\togv{F}(X)}{Q^\dagger}{\outterm}
%%   \]
%% \end{lemma}

%% Since $\mapname$ is defined in \mucp by cases, we can get $\mapname$ in \mugv by applying our
%% existing translation to each case.  Define
%% \[
%%   Q^\dagger = \gvlet{d}{\gvfork{x}{\togv{Q}}}{\gvmap{\togv{F}}{c,d}{(\gvsend{c}{(\gvsend{d}{p})})}}.
%% \]

%% \begin{lemma}
%%   If $\cptyp{Q}{y:\cpdual{A},x:F(A)}$, then
%%   \[
%%     \gvtyp{x:\gvdual{\togv{A}},p:\gvservice{(\gvout{\gvdual{\togv{A}}}{\gvout{X}{\outterm}})},c:\togv{F}(X)}{Q^\dagger}{\outterm}
%%   \]
%% \end{lemma}

%% \begin{theorem}
%%   If $\cptyp{Q}{y:\cpdual{A},x:F(A)}$, then $\gvtyp{}{\gvfix{p}{y\,c}{Q^\dagger}}{\gvservice{(\gvout{\gvdual{\togv{A}}}{\gvout{\nu \togv{F}}{\outterm}})}}$.
%% \end{theorem}

\begin{theorem}
  If $\cptyp{P}{\Gamma}$, then $\gvtyp{\togv{\Gamma}}{\togv{P}}{\outterm}$.
\end{theorem}

\section{Related Work}\label{sec:related}

Session types were originally introduced by \citet{Honda93}, and were further extended by
\citet{Takeuchi94}, \citet{Honda98}, and \citet{Yoshida07}. The systems of \citet{Honda98} and
\citet{Yoshida07} include recursive session types. They do not distinguish between recursion and
corecursion, and do not exhibit deadlock freedom. \citet{Bernardi13} demonstrated that duality in
those systems was not preserved under unfolding of recursive types. Our approach avoids this
difficulty. They propose a different solution from ours, however, and we hope to investigate the
consequences of these different approaches in future work.

\citet{CairesPfenning10} showed the first complete propositions-as-types correspondence between
intuitionistic linear logic (ILL) and session types. Their work shows both an interpretation of
session types as ILL propositions, and a computational interpretation of ILL proofs as
$\pi$-calculus processes. As a result, they are able to show that well-typed processes are race free
and deadlock free, by analogy with corresponding cut-elimination results for ILL. \citet{Toninho13}
demonstrate an embedding of their calculus within a functional language; the resulting system admits
unrestricted recursion in the functional setting, and can thus provide recursive communication
behavior, but does not guarantee that the evaluation of function terms terminates.

\citet{Girard87} speculated that linear logic would be well-suited to reasoning about concurrency.
\citet{Abramsky92} and \citet{BellinScott94} explored the interpretation of linear logic proofs as
concurrent programs. \citet{Kobayashi96} introduced the use of linear typing to the $\pi$-calculus,
and demonstrated a form of linear channels similar in usage to session-typed channels; Dardha et
al.'s~\citeyearpar{Dardha12} extensions to this work include full session types.

\section{Conclusion and Future Work}\label{sec:future}

We have demonstrated a propositions-as-types correspondence linking recursive session types and
fixed points in linear logic. Unlike previous work on recursive session types, our presentation
distinguishes between (bounded) recursive processes and (unbounded) corecursive processes. As a
consequence of cut elimination in linear logic, all well-typed processes are terminating, race-free,
and deadlock-free. We conclude by identifying several areas of future work. First, we would like to
give an asynchronous semantics to \mugv, following the original presentation of LAST by
\citet{GayVasconcelos10}, and show that it is equivalent to the synchronous semantics provided by
cut elimination in \mucp. Second, we would like to extend our treatment of recursive sessions to
encode arbitrary recursive types in \mugv, similarly to our encoding of function and pair types in
terms of input and output on channels. Finally, we would like to explore further extensions of \mucp
and their consequences for \mugv; in particular, the addition of the MIX$_0$ and MIX$_2$ rules would
provide additional notions of parallel composition, and could provide a way of unifying the types
$\outterm$ and $\interm$.

\label{sect:bib}
\bibliographystyle{abbrvnat}
\bibliography{main}

\newpage
\appendix

\begin{figure}
\begin{multline*}
\inferrule
  {\inferrule*
     {\cptyp{P}{y:A,\Gamma} \\
      \cptyp{Q}{x:B,\Gamma'}}
     {\cptyp{x[y].(P \mid Q)}{x: A \otimes B,\Gamma,\Gamma'}} \\
   \inferrule*
     {\cptyp{R}{x:\cpdual{B},y:\cpdual{A},\Delta}}
     {\cptyp{x(y).R}{x:\cpdual{A} \parr \cpdual{B},\Delta}}}
  {\cptyp{\cut{x}{A \otimes B}{x[y].(P \mid Q)}{x(y).R}}{\Gamma,\Gamma',\Delta}}
\Longrightarrow \\
\inferrule
  {\cptyp{Q}{y:A,\Gamma} \\
   \inferrule*
     {\cptyp{P}{x:B,\Gamma'} \\
      \cptyp{R}{x:\cpdual{B},y:\cpdual{A},\Delta}}
     {{\cptyp{\cut{x}{B}{P}{R}}{y:\cpdual{A},\Gamma',\Delta}}}}
  {\cptyp{\cut{y}{A}{Q}{\cut{x}{B}{P}{R}}}{\Gamma,\Gamma',\Delta}}
\end{multline*}
\[
\inferrule
  {\inferrule*
     { }{\cptyp{x[].0}{x:1}} \\
   \inferrule*
     {\cptyp{P}{\Gamma}}
     {\cptyp{x().P}{x:\bot,\Gamma}}}
  {\cptyp{\cut{x}{1}{x[].0}{x().P}}{\Gamma}}
\Longrightarrow
\cptyp{P}{\Gamma}
\]
\begin{multline*}
\inferrule
  {\inferrule*
     {\cptyp{P}{x:A,\Gamma}}
     {\cptyp{\sel{x}{inl}.P}{x:A \oplus B, \Gamma}} \\
   \inferrule*
     {\cptyp{Q}{x:\cpdual{A},\Delta} \\
      \cptyp{R}{x:\cpdual{B},\Delta}}
     {\cptyp{\case{x}{Q;R}}{x:\cpdual{A} \with \cpdual{B},\Delta}}}
  {\cptyp{\cut{x}{A \oplus B}{\sel{x}{inl}.P}{\case{x}{Q;R}}}{\Gamma,\Delta}}
\Longrightarrow \\
\inferrule
  {\cptyp{P}{x:A,\Gamma} \\
   \cptyp{Q}{x:\cpdual{A},\Delta}}
  {\cptyp{\cut{x}{A}{P}{Q}}{\Gamma,\Delta}}
\end{multline*}
\[
\inferrule
  {\inferrule*
     {\cptyp{P}{y:A,\cpquery{\Gamma}}}
     {\cptyp{\replicate{x}{y}.P}{x:\cpbang{A},\Gamma}} \\
   \inferrule*
     {\cptyp{Q}{y:\cpdual{A},\Delta}}
     {\cptyp{\derelict{x}{y}.Q}{x:\cpquery{\cpdual{A}},\Delta}}}
  {\cptyp{\cut{x}{\cpbang{A}}{\replicate{x}{y}.P}{\derelict{x}{y}.Q}}{\Gamma,\Delta}}
\Longrightarrow
\inferrule
  {\cptyp{P}{x:A,\Gamma} \\
   \cptyp{Q}{y:\cpdual{A},\Delta}}
  {\cptyp{\cut{y}{A}{P}{Q}}{\Gamma,\Delta}}
\]
\[
\inferrule
  {\inferrule*
     {\cptyp{P}{y:A,?\Gamma}}
     {\cptyp{\replicate{x}{y}.P}{x:\cpbang{A},\Gamma}} \\
   \inferrule*
     {\cptyp{Q}{\Delta} \\ un(\cpquery{\cpdual{A}})}
     {\cptyp{Q}{y:\cpquery{\cpdual{A}}}}}
  {\cptyp{\cut{y}{\cpbang{A}}{\replicate{x}{y}.P}{Q}}{\Gamma,\Delta}}
\Longrightarrow
\inferrule
  {\cptyp{Q}{\Delta}}
  {\cptyp{Q}{\Gamma,\Delta}}
\]
\begin{multline*}
\inferrule
  {\inferrule*
     {\cptyp{P}{y:A,\cpquery{\Gamma}}}
     {\cptyp{\replicate{x}{y}.P}{x:\cpbang{A},\Gamma}} \\
   \inferrule*
     {\cptyp{Q}{x:\cpquery{\cpdual{A}},x':\cpquery{\cpdual{A}},\Delta}}
     {\cptyp{Q[x/x']}{x:\cpquery{\cpdual{A}},\Delta}}}
  {\cptyp{\cut{x}{\cpbang{A}}{\replicate{x}{y}.P}{Q[x/x']}}{\Gamma,\Delta}}
\Longrightarrow \\
\inferrule
  {\inferrule*
     {\cptyp{P}{y:A,\cpquery{\Gamma}}}
     {\cptyp{\replicate{x}{y}.P}{x:\cpbang{A},\Gamma}} \\
   \inferrule*
     {\inferrule*
         {\cptyp{P}{y:A,\cpquery{\Gamma}}}
         {\cptyp{\replicate{x'}{y}.P}{x':\cpbang{A},\Gamma}} \\
      \cptyp{Q}{x:\cpquery{\cpdual{A}},x':\cpquery{\cpdual{A}},\Delta}}
     {\cptyp{\cut{x'}{\cpbang{A}}{\replicate{x'}{y}.P}{Q}}{\Gamma,\Delta}}}
  {\cptyp{\cut{x}{\cpbang{A}}{\replicate{x}{y}.P}{\cut{x'}{\cpbang{A}}{\replicate{x'}{y}.P}{Q}}}{\Gamma,\Delta}}
\end{multline*}
\[
\bl
\inferrule
  {\inferrule*
     {\cptyp{P}{y:B,\Gamma} \\
      \cptyp{Q}{y:\cpdual{B},x:F(B)}}
     {\cptyp{\corec{x}{y}{B}{P}{Q}}{x:\nu F,\Gamma}} \\
   \inferrule*
     {\cptyp{R}{x:\cpdual{F}(\mu (\cpdual{F})),\Delta}}
     {\cptyp{\rec{x}.R}{x:\mu (\cpdual{F}),\Delta}}}
  {\cptyp{\cut{x}{\nu F}{\corec{x}{y}{B}{P}{Q}}{\rec{x}.R}}{\Gamma,\Delta}}
\Longrightarrow \\
\inferrule
  {\cptyp{P}{y:B,\Gamma} \\
   \inferrule*
     {\cptyp{Q}{y:\cpdual{B},x:F(B)} \\
      \inferrule*
          {\cptyp{E}{x:\cpdual{F}(\cpdual{B}),z:F(\nu F)} \\\\
         \cptyp{R[z/x]}{z:\cpdual{F}(\mu \cpdual{F}),\Delta}}
        {\cptyp{\cut{z}{F(\nu F)}{E}{R[z/x]}}{x:\cpdual{F}(\cpdual{B}),\Delta}}}
     {\cptyp{\cut{x}{F(B)}{Q}{\cut{z}{F(\nu F)}{E}{R[z/x]}}}{y:\cpdual{B},\Delta}}}
  {\cptyp{\cut{y}{B}{P}{\cut{x}{F(B)}{Q}{\cut{z}{F(\nu F)}{E}{R[z/x]}}}}{\Gamma,\Delta}}
\el
\]
where $E = \map{F}{z,x}{\corec{z}{y}{B}{\link{x}{y}}{Q[z/x]}}$.

\caption{Principal Cut Elimination Rules}\label{fig:beta-reduction}
\end{figure}

\end{document}
