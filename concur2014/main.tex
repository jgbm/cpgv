\documentclass[orivec,envcountsame]{llncs}

\usepackage{amsmath,amssymb,mathwidth,stmaryrd,xcolor,xspace}
\addtolength{\jot}{-3px}

\usepackage{mathpartir}
\mprset{sep=1em}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

\newcommand{\with}{\mathbin\binampersand}
\newcommand{\parr}{\mathbin\bindnasrepma}
\newcommand{\cpdual}[1]{#1^\perp}
\newcommand{\cpbang}[1]{{! #1}}
\newcommand{\cpquery}[1]{{? #1}}
\newcommand{\gvdual}[1]{\overline{#1}}
\newcommand{\gvout}[2]{{!#1.#2}}
\newcommand{\gvin}[2]{{?#1.#2}}
\newcommand{\lto}{\ensuremath{\multimap}}
\newcommand{\uto}{\ensuremath{\rightarrow}}
\newcommand{\outterm}{\mathrm{end}_!}
\newcommand{\interm}{\mathrm{end}_?}
\newcommand{\gvserver}[1]{\flat #1}
\newcommand{\gvservice}[1]{\sharp #1}
\newcommand{\trule}[1]{(\textit{#1})}
\newcommand{\cptyp}[2]{#1 \vdash #2}
\newcommand{\gvtyp}[3]{#1 \vdash #2 : #3}

\newcommand{\expand}[3]{\mathbf{map}^{#1}_{#2}(#3)}

\newcommand{\mkwd}[1]{\mathsf{#1}}
\newcommand{\tkwd}[1]{\textsf{#1}}
\newcommand{\link}[2]{#1 \leftrightarrow #2}
\newcommand{\cut}[4]{\mkwd{new}\:#1 \: (#3 \mid #4)}
\newcommand{\rec}[1]{\mkwd{rec}\:#1}
\newcommand{\corec}[5]{\mkwd{corec}\:#1 \langle #2 \rangle (#4,#5)}
\newcommand{\clabel}[1]{\mathrm{#1}}
\renewcommand{\case}[2]{\mkwd{case}\:#1\:\{#2\}}
\newcommand{\sel}[2]{#1[\clabel{#2}]}
\newcommand{\gvsend}[2]{\mkwd{send}\:#1\:#2}
\newcommand{\gvreceive}[1]{\mkwd{receive}\:#1}
\newcommand{\gvlet}[3]{\mkwd{let}\;#1 = #2\;\mkwd{in}\;#3}
\newcommand{\gvselect}[2]{\mkwd{select}\:#1\:#2}
\newcommand{\gvcase}[2]{\mkwd{case}\:#1\:\{#2\}}
\newcommand{\gvlink}[2]{\mkwd{link}\:#1\:#2}
\newcommand{\gvfork}[2]{\mkwd{fork}\:#1.#2}
\newcommand{\lrkwd}{\mkwd{fix}}
\newcommand{\gvfix}[3]{\lrkwd\:#1\:#2 = #3}
\newcommand{\gvletrec}[4]{\gvlet{#1}{\gvfix{#1}{#2}{#3}}{#4}}
\newcommand{\gvserve}[2]{\mkwd{serve}\:#1.#2}
\newcommand{\gvrequest}[1]{\mkwd{request}\:#1}

\newcommand{\key}{\mkwd}

\newcommand{\tocp}[1]{\llbracket #1 \rrbracket}
\newcommand{\De}{\mathcal{D}}

\newcommand{\topi}[1]{({#1})^\star}

\newcommand{\mucp}{$\mu\mathrm{CP}$\xspace}
\newcommand{\mugv}{$\mu\mathrm{GV}$\xspace}
\newcommand{\gvpi}{$\mu\mathrm{GV}\pi$\xspace}

\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}

\newcommand{\bl}{\ba[t]{@{}l@{}}}
\newcommand{\el}{\ea}

\newenvironment{equations}{\[\ba{@{}r@{~}c@{~}l@{}}}{\ea\]}
\newenvironment{eqs}{\ba{@{}r@{~}c@{~}l@{}}}{\ea}

\newcommand{\secref}[1]{(\S\ref{sec:#1})}

\title{Recursive Sessions and Linear Logic}
\author{J. Garrett Morris \and Sam Lindley \and Philip Wadler}
\institute{University of Edinburgh \\
           \email{Garrett.Morris@ed.ac.uk,\{slindley,wadler\}@inf.ed.ac.uk}}

\newcommand{\todo}[1]{{\noindent\small\color{red} \framebox{\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{\textbf{TODO:} #1}}}}

\begin{document}

\maketitle

\begin{abstract}
  Pants! (This is a test. This is only a test.)
\end{abstract}

\section{Introduction}\label{sec:intro}

\todo{\begin{itemize}
\item History of session types;
\item Curry-Howard correspondence developed by Caires and Pfenning~\cite{CairesPfenning10};
\item Wadler's adaptation of Caires and Pfenning's correspondence to classical setting~\cite{Wadler12};
\item Recursion in process calculi; and,
\item Recursion in LL.
\end{itemize}}

The primary contribution of this paper is the extension of Wadler's Curry-Howard correspondence to
recursive session types, while preserving the significant results of the existing correspondence
(race and deadlock freedom and termination).  To this end:
\begin{itemize}
\item We begin by presenting a simple, session-typed functional language~\secref{mugv}, which
  includes support for recursive session types.  In contrast to existing approaches to recursive
  session types, we distinguish between the greatest and least fixed points of recursive equations.
  We give several examples of recursive processes and their use.
\item We next review Baelde's combinators for recursion in Girard's LL, and extend Wadler's term
  assignment for LL to include terms corresponding to recursion and corecursion~\secref{mucp}.  We
  demonstrate the use of these combinators both to code traditional recursive data types and
  infinite streams~\secref{mucp-examples}.
\item Finally, we show that programs in \mugv correspond to proofs in \mucp, in two stages.  First,
  we show a translation of the functional features of \mugv into its process oriented
  features~\secref{gvtogvpi}; we call the resulting restricted language \gvpi.  Second, we show
  that programs in \gvpi can be translated to terms of \mucp~\secref{gvpitocp}.
\end{itemize}
We conclude with a survey of related~\secref{related} and future~\secref{future} work.

\todo{Full list of examples: \begin{enumerate}
\item Stream of zeros (no use of coinvariant);
\item Stream of naturals (simple coinvariant);
\item Stream of Fibonacci numbers (slightly less simple coinvariant);
\item Calculator (recursion and choice)
\item Bit strings (correspondence to Toninho et al.)
\item Church numerals
\item Peano numerals
\item Simulating exponentials with fixed points
\end{enumerate}}

\section{A Session-Typed Functional Language}\label{sec:mugv}

\subsection{Types and Terms of \mugv}

\begin{figure}\small
\[\begin{array}{l@{\hspace{1mm}}r@{\hspace{2mm}}c@{\hspace{2mm}}l}
  \text{Types} & T,U,V & ::= & S \mid T \otimes U \mid T \lto U \mid T \uto U \\
  \text{Session types} & S & ::= & \gvout{T}{S} \mid \gvin{T}{S} \mid \oplus \{ l_i : S_i \} \mid \with \{ l_i : S_i \} \mid \outterm \mid \interm \\
   & & \mid & X \mid \gvdual{X} \mid \mu G \mid \nu G \mid \gvservice{S} \mid \gvserver{S} \\
  \text{Type operators} & G & ::= & X.S % \\
%  \text{Terms} & M,N & ::= & x \mid \lambda x.N \mid M\,N \mid (M,N) \mid \gvlet{(x,y)}{M}{N} \\
%   & & \mid & \gvsend{M}{N} \mid \gvreceive{M} \mid \gvselect{l_i}{M} \mid \gvcase{M}{l_i : N_i} \\
%   & & \mid & \gvlink{M}{N} \mid \gvfork{x}{M} \mid \gvletrec{x}{M}{N}
\end{array}\]
\caption{\mugv Types and Session Types}\label{fig:gv-syntax}
\end{figure}

In this section, we present \mugv, a simple functional language with session types patterned on the
language of Gay and Vasconcelos~\cite{GayVasconcelos10} (which we term LAST) and Wadler's language GV.
Figure~\ref{fig:gv-syntax} gives the syntax of \mugv terms and types.  Among the types, we include
linear pairs ($T \otimes U$), and both linear ($T \lto U$) and unlimited ($T \uto U$) function
spaces.  The session types include input ($\gvin{T}{S}$), output ($\gvout{T}{S}$), selection
($\oplus\{ l_i:S_i \}$) and choice ($\with\{l_i:S_i\}$).  We include two variations on the closed
channel ($\interm$ and $\outterm$); this is forced by our interpretation of session types in LL,
where there is no self-dual proposition to implement closed channels.  $\gvservice{S}$ represents
replication of a channel the behaves like $S$; a channel of type $\gvserver{S}$ is the corresponding
provider of a replicated channel.  Finally, we include session variables and their duals
($X,\gvdual{X}$), and two forms of recursive session types, corresponding to least ($\mu X.S$) and
greatest ($\nu X.S$) fixed points.  If $G$ is an operator $X.S$, we write $G(S')$ for the
substitution instance $S[S'/X]$.  All types are linear except for unlimited functions $T \uto U$,
replicated channels $\gvservice{S}$, and closed channels $\interm$; we write $un(T)$ if $T$ is
unlimited.

The notions of duality are standard for input, output, selection, choice, and closed and replicated
channels:
{\small\begin{align*}
\gvdual{\gvout{T}{S}} &= \gvin{T}{\gvdual{S}} &
  \gvdual{\oplus \{ l_i: S_i \}} &= \with \{ l_i : \gvdual{S_i} \} &
  \gvdual{\interm} &= \outterm &
  \gvdual{\gvservice{S}} &= \gvserver{\gvdual{S}} &
  \gvdual{X} &= \gvdual{X} \\
\gvdual{\gvin{T}{S}} &= \gvout{T}{\gvdual{S}} &
  \gvdual{\with \{ l_i: S_i \}} &= \oplus \{ l_i : \gvdual{S_i} \} &
  \gvdual{\outterm} &= \interm &
  \gvdual{\gvserver{S}} &= \gvservice{\gvdual{S}} &
  \gvdual{\gvdual{X}} &= X
\end{align*}}
We introduce a notion of the dual of an operator: if $G = X.S$, then $\gvdual{G} =
X.\gvdual{G(\gvdual{X})}$.  Note that $\gvdual{G}(\gvdual{S}) = \gvdual{G(S)}$. This allows us to
give a natural definition of duality for fixed points:
%
{\small\begin{align*}
\gvdual{\mu G} &= \nu \gvdual{G} & \gvdual{\nu G} = \mu \gvdual{G}
\end{align*}}
Unlike many notions of duality for session types, our definition preserves duality when recursive
session types are unfolded, even when the recursion occurs in messages.  For example, consider the
operator $G = X.\gvin{X}{\interm}$, with its dual $\gvdual{G} = X.\gvout{\gvdual{X}}{\outterm}$, and
the (dual) session types $\mu G$ and $\nu \gvdual{G}$.  Unfolding the first type gives $G(\mu G)$, or
$\gvin{\mu G}{\interm}$.  Unfolding the second gives
{\small\[
\gvdual{G}(\nu \gvdual{G})
  = \gvout{\gvdual{\nu \gvdual{G}}}{\outterm}
  = \gvout{\mu G}{\outterm},
\]}
which is the dual of $\gvin{\mu G}{\interm}$.  Finally, to assure that the fixed points exist, we
require that all operators $X.S$ be monotonic, that is, that variables appear only as positive
subformulae of $S$, and negated variables only as negative subformulae.  The definition of positive
subformulae is slightly unusual: we have that the argument $T$ in $\gvout{T}{S}$ and the arguments
$T$ and $U$ in $T \otimes U, T \lto U, T \uto U$ are negative, and all other subformulae are
positive.  Thus, the operator $X.\gvout{X}{\outterm}$ is not monotonic, but the operators
$X.\gvout{\gvdual{X}}{\outterm}$ and $X.\gvout{X \otimes X}{\outterm}$ are.

\todo{The definition of monotonic is deranged.}

\begin{figure}\small
Structural rules
\begin{mathpar}
\inferrule{ }{\gvtyp{x:T}{x}{T}}

\inferrule{\gvtyp{\Phi}{M}{U} \\
           un(T)}
          {\gvtyp{\Phi,x:T}{M}{U}}

\inferrule{\gvtyp{\Phi,x:T,x':T}{M}{U} \\
           un(T)}
          {\gvtyp{\Phi,x:T}{M[x/x']}{U}}
\end{mathpar}
Lambda rules
\begin{mathpar}
\inferrule{\gvtyp{\Phi,x:T}{M}{U}}
          {\gvtyp{\Phi}{\lambda x.M}{T \lto U}}

\inferrule{\gvtyp{\Phi}{M}{T \lto U} \\
           \gvtyp{\Psi}{N}{T}}
          {\gvtyp{\Phi,\Psi}{M\,N}{U}}

\inferrule{\gvtyp{\Phi}{M}{T \lto U} \\
           un(\Phi)}
          {\gvtyp{\Phi}{M}{T \uto U}}

\inferrule{\gvtyp{\Phi}{M}{T \uto U}}
          {\gvtyp{\Phi}{M}{T \lto U}}

\inferrule{\gvtyp{\Phi}{M}{T} \\
           \gvtyp{\Psi}{N}{U}}
          {\gvtyp{\Phi,\Psi}{(M,N)}{T \otimes U}}

\inferrule{\gvtyp{\Phi}{M}{T \otimes U} \\
           \gvtyp{\Psi,x:T,y:U}{N}{V}}
          {\gvtyp{\Phi,\Psi}{\gvlet{(x,y)}{M}{N}}{V}}
\end{mathpar}
Session rules
\begin{mathpar}
\inferrule{\gvtyp{\Phi}{M}{S} \\
           \gvtyp{\Psi}{N}{\gvdual{S}}}
          {\gvtyp{\Phi,\Psi}{\gvlink{M}{N}}{\outterm}}

\inferrule{\gvtyp{\Phi}{M}{T} \\
           \gvtyp{\Psi}{N}{\gvout{T}{S}}}
          {\gvtyp{\Phi,\Psi}{\gvsend{M}{N}}{S}}

\inferrule{\gvtyp{\Phi}{M}{\gvin{T}{S}}}
          {\gvtyp{\Phi}{\gvreceive{M}}{T \otimes S}}

\inferrule{\gvtyp{\Phi,x:\gvdual{S}}{M}{\outterm}}
          {\gvtyp{\Phi}{\gvfork{x}{M}}{ S}}

\inferrule{\gvtyp{\Phi}{M}{\oplus \{ l_i:S_i \}}}
          {\gvtyp{\Phi}{\gvselect{l_i}{M}}{S_i}}

\inferrule{\gvtyp{\Phi}{M}{\with \{ l_i:S_i \}} \\
           \gvtyp{\Psi,x:S_i}{N_i}{T}}
          {\gvtyp{\Phi,\Psi}{\gvcase{M}{l_i\,x.N_i}}{T}}
\end{mathpar}
Replicated session rules
\begin{mathpar}
\inferrule{\gvtyp{\Phi,x:\gvdual{S}}{M}{\outterm} \\
           un(\Phi)}
          {\gvtyp{\Phi}{\gvserve{x}{M}}{\gvservice{S}}}

\inferrule{\gvtyp{\Phi}{M}{\gvservice{S}}}
          {\gvtyp{\Phi}{\gvrequest{M}}{S}}
\end{mathpar}
Recursive session rules
\begin{mathpar}
\inferrule{\gvtyp{\Phi}{M}{G(\mu G)}}
          {\gvtyp{\Phi}{M}{\mu G}}

\inferrule{\gvtyp{\Phi}{M}{\mu G}}
          {\gvtyp{\Phi}{M}{G (\mu G)}}

\inferrule{\gvtyp{\Phi}{M}{G(\nu G)}}
          {\gvtyp{\Phi}{M}{\nu G}}

\inferrule{\gvtyp{\Phi}{M}{\nu G}}
          {\gvtyp{\Phi}{M}{G(\nu G)}}

\inferrule{\gvtyp{\vec{x}:\vec{T},f:\langle \vec{T}, X \rangle \uto \outterm, c:G(X)}{M}{\outterm}}
          {\gvtyp{}{\gvfix{f}{\vec{x}\,c}{M}}{\langle \vec{T}, \nu G \rangle \uto \outterm}}
%% \inferrule{\gvtyp{x_i:T_i,f:\vec{T} \uto X \uto \outterm,c:G(X)}{M}{\outterm} \\
%%            \gvtyp{\Phi,f:\vec{T} \uto \nu G \uto \outterm}{N}{U}}
%%           {\gvtyp{\Phi}{\gvletrec{f\,x_1 \dots x_n\,c}{M}{N}}{U}}
\end{mathpar}
\caption{\mugv Terms and Typing Rules}\label{fig:gv-typing}
\end{figure}

Figure~\ref{fig:gv-typing} gives the terms and typing rules of \mugv.  The structural rules account
for variables, and for weakening and contraction on variables of unlimited type.  The rules for the
functional terms are standard; note that, to account for linearity, the context is split in the
rules for application and pair introduction and elimination, and is limited to unlimited types in
the introduction of unlimited arrows.

Among the session-typed terms, the rules for input, output, choice and selection are standard.  We
provide a term $\gvlink{M}{N}$ to implement channel forwarding; while a version of \tkwd{link}
exists for any session type $S$, it has no generic implementation in terms of other constructs of
\mugv.  Finally, \tkwd{fork} provides session initiation; like Wadler's GV, but unlike LAST (and
much other work on process calculi), our system is deterministic.

Channels of type $\gvservice{S}$ offer arbitrarily many sessions of type $S$; correspondingly,
channels of type $\gvserver{S}$ must consume arbitrarily many $S$ sessions. The rule for
$\gvserve{x}{M}$ parallels that for $\tkwd{fork}$: it defines the server (which replicates $M$) and
returns the channel by which it may be used (of type $\gvdual{\gvserver{S}} =
\gvservice{\gvdual{S}}$). As a consequence, there is no rule involving type $\gvserver{S}$.

Finally, we provide recursive channels. The first four typing rules allow recursive types to be used
as their unfoldings, and vice versa. Previous work has typically included an equivalence relation on
types, taking unfolding into account, and presented type rules up to equivalence. We present
explicit rules to simplify the translation into \mucp, where these rules will correspond to terms
implementing the equivalences. The expression $\gvfix{f}{\vec{x}\,c}{M}$ is used to define
corecursive sessions.  We will give a simple example to motivate its typing rule; the remainder of
the section will provide more in depth examples.

Consider a stream of zeros (we will assume an extension of the core \mugv language to include
non-linear integer constants).  The type of such a stream is $\nu X. !Int.X$.  We would expect the
definition of such a stream to provide one number before recursing; in \mugv, we could begin
implementing this by
\[
  \lrkwd \: f\:c = \gvlet{c}{\gvsend{0}{c}}{\dots}
\]
If $c$ started with type $\nu X.\gvout{Int}{X} = \gvout{Int}{(\nu X.\gvout{Int}{X})}$, then after
the send we expect it to be back to the type $\nu X.\gvout{Int}{X}$.  This is thus the natural place
to make a recursive call; our definition then becomes:
\[ \lrkwd \: f\:c = \gvlet{c}{\gvsend{0}{c}}{f\,c}.\]
Unfortunately, if we give $c$ the type $\nu X.\gvout{Int}{X}$ and $f$ the type $\nu X.\gvout{Int}{X}
\uto \outterm$ in $M$, we cannot be sure that the defined session will be productive.  For example,
an equally valid definition under those typing assumptions would be
\[ \lrkwd \: f\:c = f\:c.\]
We restrict the typing rule for $\lrkwd$ to ensure productivity.  We use a (fresh) type variable $X$
to abstract the recursive behavior; the channel $c$ then has type $G(X)$ instead of $G(\nu G)$, and
$f$ has type $X \uto \outterm$ instead of $\nu G \uto \outterm$.  $M$ is thus required to provide
precisely one iteration of the recursive behavior.

We also allow recursive sessions to maintain internal state (or maintain a coinvariant); this is
captured by the additional arguments $\vec{x}$ to $f$.  We will demonstrate several uses of
coinvariants in the remainder of the section.

Finally, we consider the use of our stream of zeros.  As with the other session typed construct, the
newly defined $f$ consumes a channel expecting recursive behavior; so, for instance, the expression
\[
  \gvfork{c}{f\:c}
\]
would use $f$ to create a channel of zeros.

\todo{Slot this in somewhere appropriate}

Syntactic sugar for multi argument functions
\[
\langle T_1, T_2, \dots, T_n \rangle \uto U
\equiv
T_1 \uto T_2 \lto \dots \lto T_n \lto U
\]
The right hand side is isomorphic to
\[
(T_1 \otimes \dots \otimes T_n) \uto U
\]


\subsection{Multi-function calculator}

Our first example is a simple multi-function calculator.  For the purposes of this example, we will
assume that our term language has been extended by integer constants, along with addition ($+$) and
multiplication ($\times$) operators.  Our goal is to provide a session that accepts an arbitrary
stream of addition and multiplication requests, and can at any time provide the accumulated result.
We can implement the provider of this session as follows:

\newcommand{\mcl}[2]{\multicolumn{#1}{l}{#2}}

\[\begin{array}{llll}
 \mcl{4}{\mkwd{let}\:calc = \lrkwd\:calc\:accum\:c =} \\
 \quad & \mcl{3}{\mkwd{case}\:c\;\mkwd{of}\:\{} \\
 & \quad & \clabel{add}\:c. &\mkwd{let}\:(x,c) = \gvreceive{c} \: \mkwd{in} \\
 & & & calc\:(accum + x)\:c; \\
 & & \clabel{mul}\:c. &\mkwd{let}\:(x,c) = \gvreceive{c}\:\mkwd{in} \\
 & & & calc\:(accum \times x)\:c \\
 & & \clabel{result}\:c. &\mkwd{let}\:c = \gvsend{accum}{c}\:\mkwd{in} \\
 & & & calc\:accum\:c; \\
 & & \clabel{done}\:c.& c \; \}
\end{array}\]
In this case, the type of the recursive channel is
\[
 Calc = \nu X. \with \{ \clabel{add}: \gvin{Int}{X}, \clabel{mul}: \gvin{Int}{X}, \clabel{result}: \gvout{Int}{X}, \clabel{done}: \outterm \}.
\]
and we have that $\gvtyp{}{calc}{Int \uto Calc \lto \outterm}.$  We can implement a consumer of the service as
follows:
\[\begin{array}{l}
  \gvlet{myCalc}{\gvfork{c}{calc\:0\:c}}{} \\
  \gvlet{d}{\gvsend{6}{(\gvselect{\clabel{add}}{myCalc})}}{} \\
  \gvlet{myCalc}{\gvsend{7}{(\gvselect{\clabel{mul}}{myCalc})}}{} \\
  \gvlet{(x,d)}{\gvreceive{(\gvselect{\clabel{result}}{myCalc})}}{} \\
  \gvlet{myCalc}{\gvselect{\clabel{done}}{myCalc}}{x}
\end{array}\]
We begin by constructing an instance of the calculator with the accumulator starting at 0; in the
body of \tkwd{fork}, $c$ has the $\nu$-type given above, so the result of \tkwd{fork} (called
$myCalc$), has type
\[
\mu X. \oplus \{ \clabel{add}: \gvout{Int}{X}, \clabel{mul}: \gvout{Int}{X}, \clabel{result}: \gvin{Int}{X}, \clabel{done}: \interm \}.
\]
We perform several calculations, adding 6 to the accumulator and multiplying by 7.  Finally, we get
the result and close the channel.

\subsection{Bit Strings}
%
%\todo{Validating the translation requires extending the GV interpreter with Booleans, addition and
%  multiplication.}

In this section, we will adapt the bit string example previous explored by Toninho et
al.~\cite{Toninho13} to our setting.  This example represents a string of bits (0 or 1) by a chain
of processes, each storing one bit.  The chain supports operations to increment and retrieve the
stored value; in turn, each link in the chain functions as a one-bit adder.

As in the previous section, we will assume constants for integers, along with addition and
multiplication operators.  We will also assume Boolean constants and an if-then-else expression.

We begin with the type $Link$ of the links in the chain.  Each is a recursive process supporting three
operations: one used to compute the value of the chain, one used to increment the chain, and one
used to dispose of the chain.
%
%{\small\[\begin{array}{l@{\hspace{1mm}}l}
% NodeT = \nu X. \with \{ &\clabel{val}: \cpdual{Nat} \parr (Nat \otimes X), \\
% & \clabel{inc}: \oplus \{ \clabel{carry}: X, \clabel{done}: X \}, \\
% & \clabel{halt}: 1 \}.
%\end{array}\]}
\[
 Link = \nu X. \with \{ \clabel{val}: \gvin{Int}{\gvout{Int}{X}}, \clabel{inc}: \oplus \{ \clabel{carry}: X, \clabel{done}: X \}, \clabel{halt}: \outterm \}
\]
The val operation cascades down the chain (from most- to least-significant bit), returning the
computed value.  The increment operator cascades similarly, but returns the carry bit.

The simplest node is the terminator $Epsilon$: it adds nothing to the value of the string, and
cannot store a value so it must respond to increment requests with carry.
%
%{\small\[\begin{array}{rcll}
%  Epsilon_x & = & \mcl{2}{\lrkwd\:x\langle y \rangle ( y[].0,} \\
%  & & \quad \mkwd{case}\:x\: \{ &\clabel{val}: x(n).x[n].\link{y}{x}; \\
%  & & &\clabel{inc}:\sel{x}{carry}.\link{y}{x}; \\
%  & & &\clabel{halt}: \link{y}{x} \}).
%\end{array}\]}
%
\[\begin{array}{lll}
\mcl{3}{\mkwd{let}\:Epsilon = \lrkwd\:Epsilon\:c =} \\
\mcl{3}{\quad \mkwd{case}\:c\:\mkwd{of}\:\{} \\
\quad \quad & \clabel{val}\:c. &\gvlet{(n,c)}{\gvreceive{c}}{} \\
& & \gvlet{c}{\gvsend{n}{c}}{} \\
& & Epsilon\:c \\
& \clabel{inc}\:c. & \gvlet{c}{\gvselect{\clabel{carry}}{c}}{} \\
& & Epsilon\:c \\
& \clabel{halt}\:c. & c \: \}
\end{array}\]
It is straightforward to see that $\gvtyp{}{Epsilon}{Link \to \outterm}$.

%To give internal nodes in the string, we need some representation of the bit each stores.  Let's use
%Booleans!
%
%{\small\begin{align*}
%Bool &= \oplus \{ \clabel{t}:1, \clabel{f}:1 \}. \\
%True_x &= \sel{x}{t}.x[].0. \\
%False_x &= \sel{x}{f}.x[].0.
%\end{align*}}
%
%As for numeric operations, I'll write $x[True].P$ for $x[b].(True_b \mid P)$.
We can now define internal nodes.  Again, the intuition is relatively simple.  In response to an
increment request, the bit flips, passing on a carry option if needed.  In response to a value
request, it adds its value to the value so far and passes the result down the string; the response
is passed up the chain unchanged.  Internal nodes require two state components: the bit they
represent (here called $b$) and the remainder of the chain (here called $d$).
%
%{\small\[\begin{array}{rcllll}
%  Node_{i,y,n} & = & \mcl{4}{\lrkwd\:n \langle x \rangle (x[j].(\link{j}{i} \mid \link{x}{y}),} \\
%  & & \quad x(b).\mkwd{case}\:n\: \{ &\mcl{3}{\clabel{val}: \rec{x}.\sel{x}{val}.n(m).} \\
%  & & & \quad \mkwd{case}\:b\: \{ &\mcl{2}{\clabel{t}: b().x[2m + 1].x(m).} \\
%  & & & & \mcl{2}{\quad n[m].n[True].\link{x}{n};} \\
%  & & & & \mcl{2}{\clabel{f}: b().x[2m].x(m).} \\
%  & & & & \mcl{2}{\quad n[m].n[False].\link{x}{n} \};} \\
%  & & & \mcl{3}{\clabel{inc}: \rec{x}.\sel{x}{inc}.} \\
%  & & & \quad \mkwd{case}\:x\:\{ &\mcl{2}{\clabel{done}: \sel{n}{done}.n[b].\link{x}{n}} \\
%  & & & &\clabel{carry}: \mkwd{case}\:b\: \{ &\clabel{t}: b().\sel{n}{carry}.n[False].\link{x}{n} \\
%  & & & & &\clabel{f}: b().\sel{n}{done}.n[True].\link{x}{n} \} \}; \\
%  & & &\clabel{halt}: \\
%  & & &\quad \mkwd{case}\:b\:\{ &\mcl{2}{\clabel{t}: b().\rec{x}.\sel{x}{halt}.x().n[].0;} \\
%  & & & &\mcl{2}{\clabel{f}: b().\rec{x}.\sel{x}{halt}.x().n[].0 \} \})}.
%\end{array}\]}
%
\newcommand{\gvifthen}[3]{\mkwd{if}\:#1\:\mkwd{then}\:#2\:\mkwd{else}\:#3}
%
\[\begin{array}{lllll}
\mcl{5}{\mkwd{let}\:Node = \lrkwd\:Node\:b\:d\:c =} \\
\mcl{5}{\quad \mkwd{case}\:c\:\mkwd{of}\:\{} \\
\quad \quad & \clabel{val}\:c. & \mcl{3}{\gvlet{(m,c)}{\gvreceive{c}}{}} \\
& & \mcl{3}{\gvlet{d}{\gvsend{(\gvifthen{b}{2 \times m + 1}{2 \times m})}{(\gvselect{\clabel{val}}{d})}}{}} \\
& & \mcl{3}{\gvlet{(n,d)}{\gvreceive{d}}{}} \\
& & \mcl{3}{\gvlet{c}{\gvsend{n}{c}}{}} \\
& & \mcl{3}{Node\:b\:d\:c;} \\
& \clabel{inc}\:c. & \mcl{3}{\mkwd{case}\:(\gvselect{\clabel{inc}}{d})\:\mkwd{of}\:\{} \\
& & \quad & \clabel{done}\:d. & Node\:b\:d\:(\gvselect{\clabel{done}}{c}) \\
& & & \clabel{carry}\:d. & \gvlet{c}{\gvifthen{b}{\gvselect{\clabel{carry}}{c}}{\gvselect{\clabel{done}}{c}}}{} \\
& & & & Node\:(not\:b)\:d\:c \}; \\
& \clabel{halt}\:c. & \mcl{3}{\gvlet{d}{\gvselect{\clabel{halt}}{d}}{c} \}}
\end{array}\]
We have that $\gvtyp{}{Node}{Bool \uto \gvdual{Link} \lto Link \lto \outterm}.$ (The arrows are linear as
$Node$ values are linear, and so closures that capture them must be as well.)

Finally, we can define the top level interface to a bit string.  The interface supports the same
three operations as the links---increment, retrieve value, and disposal---but with simpler behavior:
\[
  Count = \nu X. \with \{ \clabel{val}: \gvout{Int}{X}, \clabel{inc}: X, \clabel{halt}: \outterm \}
\]
Value retrieval produces the value of the string, increment increases the stored value by one, and
halt gives a closed channel.  The implementation requires one state component, the first link of the
chain (called $d$).
\[\begin{array}{llll}
\mcl{4}{\mkwd{let}\:CounterImpl = \lrkwd\:CounterImpl\:d\:c =} \\
\mcl{4}{\quad \mkwd{case}\:c\:\mkwd{of}\:\{} \\
\quad \quad & \clabel{val}\:c. & \mcl{2}{\gvlet{(n,d)}{\gvreceive{(\gvsend{0}{(\gvselect{\clabel{val}}{d})})}}} \\
& & \mcl{2}{CounterImpl\:d\:(\gvsend{n}{c})} \\
& \clabel{inc}\:c. & \mcl{2}{\mkwd{case}\:\gvselect{\clabel{inc}}{d}\:\mkwd{of}\:\{} \\
& & \quad \clabel{carry}\:d. & \gvlet{e}{\gvfork{e}{Node\:True\:d\:e}}{} \\
& & & CounterImpl\:e\:c; \\
& & \quad \clabel{done}\:d. & CounterImpl\:d\:c\:\}; \\
& \clabel{halt}\:c. & \mcl{2}{\gvlet{d}{\gvselect{\clabel{halt}}{d}}{c}\:\}}
\end{array}\]
The value case uses the value behavior of the links, providing the initial value 0.  The increment
option adds a new link to the chain if incrementing the existing chain requires carrying.  We have
that $\gvtyp{}{CounterImpl}{\gvdual{Link} \uto Count \lto \outterm},$ taking an initial chain as an argument.
Since we expect that the initial string will usually be empty, we can define
\[
  \mkwd{let}\:Counter = \lambda c.CounterImpl\:(\gvfork{x}{Epsilon\:x})\:c.
\]
%
%{\small\[
% CounterT = \nu X. \with \{ \clabel{val}: Nat \otimes X, \clabel{inc}:X, \clabel{halt}:1 \}.
%\]}
%
%{\small\[\begin{array}{rclll}
%  Counter_z & = & \mcl{3}{\lrkwd\:z \langle x \rangle (Epsilon_x,} \\
%  & & \quad \mkwd{case}\:z\:\{ &\mcl{2}{\clabel{val}: \rec{x}.\sel{x}{val}.x[Zero].x(n).z[n].\link{z}{x};} \\
%  & & &  \mcl{2}{\clabel{inc}: \rec{x}.\sel{x}{inc}.} \\
%  & & & \quad \mkwd{case}\:x\:\{ &\clabel{carry}: \cut{n}{CImp}{\cut{i}{Bool}{True_i}{Node_{i,x,n}}}{\link{z}{n}}; \\
%  & & & &\clabel{done}: \link{z}{x} \} \\
%  & & &\mcl{2}{\clabel{halt}:\rec{x}.\sel{x}{halt}.x().z[].0 \}).}
%\end{array}\]}
Finally, we give a simple example of using the counter:
\[\begin{array}{l}
\gvlet{ctr}{\gvfork{c}{Counter\:c}}{} \\
\gvlet{(i,ctr)}{\gvreceive{(\gvselect{\clabel{val}}{ctr})}}{} \\
\gvlet{(j,ctr)}{\gvreceive{(\gvselect{\clabel{val}}{(\gvselect{\clabel{inc}}{ctr})})}}{} \\
\gvlet{(k,ctr)}{\gvreceive{(\gvselect{\clabel{val}}{(\gvselect{\clabel{inc}}{(\gvselect{\clabel{inc}}{ctr})})})}}{} \\
\gvlet{ctr}{\gvselect{\clabel{halt}}{ctr}}{(i,j,k)}
\end{array}\]
We begin by creating a new counter on channel $ctr$; we then perform a mixture of increment and
value operations before closing the $ctr$ channel.  The whole expression evaluates to $(0,1,3)$.


\section{\mucp Syntax and Semantics}\label{sec:mucp}

\subsection{Types and Terms}

\todo{
\begin{itemize}
\item There are a couple of changes from previous presentations of CP.  First, I've changed the
  scoping operator from $\nu$ to \tkwd{new} to avoid confusion with fixed points.  Second, I've
  attempted to make $.$ mean sequencing, as it does in $\pi$-calculus; this meant changing the
  syntax of \tkwd{new} and \tkwd{case} to eliminate extra $.$'s.
\item I'm unsure on whether to prefer a minimal presentation, to simplify the later technical
  development, or a full presentation, to make it look most like a complete language.  For example,
  as it is, I've left out second-order quantification; this isn't because there's any particular
  problem with it, but because I haven't used it in any of the examples and it doesn't interact
  surprisingly with any of the new features.  Some places the paper is schizophrenic: the syntax and
  cut rules use binary sums, but the examples assume $n$-ary sums.
\end{itemize}\vspace{-2mm}}

Types and terms:

{\small
\[\begin{array}{l@{\hspace{2mm}}r@{\hspace{2mm}}c@{\hspace{2mm}}l}
  \text{Types} & A,B & ::= & A \otimes B \mid A \parr B \mid \bot \mid 1 \mid A \oplus B \mid A \with B \mid 0 \mid \top \\
   & & \mid & X \mid \cpdual{X} \mid \mu F \mid \nu F \\
   \text{Type operators} & F & ::= & X.A \\
  \text{Terms} & P,Q & ::= & \link{x}{y} \mid x(y).P \mid x[y].(P \mid Q) \mid x().P \mid x[].0 \\
   & & \mid & \sel{x}{inl}.P \mid \sel{x}{inr}.Q \mid \case{x}{P;Q} \mid \case{x}{} \\
   & & \mid & \cut{x}{A}{P}{Q} \mid \rec{x}.P \mid \corec{x}{y}{A}{P}{Q}
\end{array}\]}

If $F = X.A$, define $F(B) = A[B/X]$.  Definition of duality is standard:

{\small\begin{gather*}
\begin{aligned}
  \cpdual{(A \otimes B)} &= \cpdual{A} \parr \cpdual{B} & \cpdual{1} &= \bot &
    \cpdual{(A \oplus B)} &= \cpdual{A} \with \cpdual{B} & \cpdual{\top} &= 0 \\
  \cpdual{(A \parr B)} &= \cpdual{A} \otimes \cpdual{B} & \cpdual{\bot} &= 1 &
    \cpdual{(A \with B)} &= \cpdual{A} \oplus \cpdual{B} & \cpdual{0} &= \top
\end{aligned}\\
\begin{aligned}
\cpdual{F} &= X.\cpdual{(F(\cpdual{X}))} & \cpdual{(\nu F)} &= \mu \cpdual{F} & \cpdual{(\mu F)} &= \nu \cpdual{F}
\end{aligned}
\end{gather*}}

\begin{figure}
{\small\begin{mathpar}
\inferrule{ }{\cptyp{\link{x}{y}}{x:A,y:\cpdual{A}}}

\inferrule{\cptyp{P}{\Gamma,x:A} \\
           \cptyp{Q}{x:\cpdual{A},\Delta}}
          {\cptyp{\cut{x}{A}{P}{Q}}{\Gamma,\Delta}}

\inferrule{\cptyp{P}{y:A,\Gamma} \\
           \cptyp{Q}{x:B,\Delta}}
          {\cptyp{x[y].(P \mid Q)}{x:A \otimes B,\Gamma,\Delta}}

\inferrule{\cptyp{P}{y:A,x:B,\Gamma}}
          {\cptyp{x(y).P}{x:A \parr B,\Gamma}}

\inferrule{ }{\cptyp{x[].0}{x:1}}

\inferrule{\cptyp{P}{\Gamma}}
          {\cptyp{x().P}{x:\bot,\Gamma}}

\inferrule{\cptyp{P}{x:A,\Gamma}}
          {\cptyp{\sel{x}{inl}.P}{x:A \oplus B,\Gamma}}

\inferrule{\cptyp{P}{x:A,\Gamma} \\
           \cptyp{Q}{x:B,\Gamma}}
          {\cptyp{\case{x}{P;Q}}{x:A \with B,\Gamma}}

\inferrule{ }{\cptyp{\case{x}{}}{x:\top,\Gamma}}

\inferrule{\cptyp{P}{x:F(\mu F), \Gamma}}
          {\cptyp{\rec{x}.P}{x:\mu F,\Gamma}}

\inferrule{\cptyp{P}{y:A,\Gamma} \\
           \cptyp{Q}{y:\cpdual{A},x:F(A)}}
          {\cptyp{\corec{x}{y}{A}{P}{Q}}{x:\nu F,\Gamma}}
\end{mathpar}}

\caption{Terms and typing rules of \mucp}\label{fig:cp-typing}
\end{figure}

\begin{lemma}
  $\cpdual{(F(A))} = \cpdual{F}(\cpdual{A})$.
\end{lemma}

\subsubsection{Structural rules.}

This seems like an odd section.  However, it does serve as a place to introduce the equivalences,
which I'd forgotten otherwise.

\begin{figure}\small
\begin{align*}
  \cut{x}{A}{P}{\link{x}{y}} &\equiv P[y/x] \\
  \cut{x}{A}{P}{Q} &\equiv \cut{x}{\cpdual{A}}{Q}{P} \\
  \cut{x}{A}{P}{\cut{y}{B}{Q}{R}} &\equiv \cut{y}{B}{Q}{\cut{x}{A}{P}{R}} &&\text{if $x \not\in fn(Q)$}
\end{align*}
\caption{Structural equivalences}\label{fig:equivalences}
\end{figure}

\subsubsection{Input and Output}

Binary...

And nullary...

{\small}

\subsubsection{Selection and Choice}

No term to prove 0.

\subsubsection{Recursion and Corecursion}


The new bits are to do with $\mu,\nu$.  The rule for $\mu$ is straightforward---given a process of
type $\mu F$, it unfolds the recursive type once giving a process of type $F(\mu F)$.  The rule for
$\nu$ is less obvious: it implements one expansion of the recursive type, along with an initial
coinvariant.  As a simple example, consider a Haskell definition of the stream of Fibonacci numbers:
\begin{verbatim}
fibs = iter (0,1)
  where iter (m,n) = m : iter (n, m+n)
\end{verbatim}
In this case, the pair \texttt{(m,n)} is the coinvariant, and the \texttt{iter} function behaves
like the step function (albeit with the recursion inlined).
%
\\\todo{That example is miserable, and assumes familiarity with Haskell.  In Glasgow, Phil wanted to
  see the unfoldr equivalent, which is $$unfoldr (\lambda (m,n) \to Just(m, (n,m+n))) (0,1).$$}
\todo{Show that rules for introduction and elimination of $\mu$ and $\nu$ collapse.}


\subsection{Cut Reduction}

\begin{figure}\small
\begin{multline*}
\inferrule
  {\inferrule*
     {\cptyp{P}{y:A,\Gamma} \\
      \cptyp{Q}{x:B,\Gamma'}}
     {\cptyp{x[y].(P \mid Q)}{x: A \otimes B,\Gamma,\Gamma'}} \\
   \inferrule*
     {\cptyp{R}{x:\cpdual{B},y:\cpdual{A},\Delta}}
     {\cptyp{x(y).R}{x:\cpdual{A} \parr \cpdual{B},\Delta}}}
  {\cptyp{\cut{x}{A \otimes B}{x[y].(P \mid Q)}{x(y).R}}{\Gamma,\Gamma',\Delta}}
\Longrightarrow \\
\inferrule
  {\cptyp{Q}{y:A,\Gamma} \\
   \inferrule*
     {\cptyp{P}{x:B,\Gamma'} \\
      \cptyp{R}{x:\cpdual{B},y:\cpdual{A},\Delta}}
     {{\cptyp{\cut{x}{B}{P}{R}}{y:\cpdual{A},\Gamma',\Delta}}}}
  {\cptyp{\cut{y}{A}{Q}{\cut{x}{B}{P}{R}}}{\Gamma,\Gamma',\Delta}}
\end{multline*}
\[
\inferrule
  {\inferrule*
     { }{\cptyp{x[].0}{x:1}} \\
   \inferrule*
     {\cptyp{P}{\Gamma}}
     {\cptyp{x().P}{x:\bot,\Gamma}}}
  {\cptyp{\cut{x}{1}{x[].0}{x().P}}{\Gamma}}
\Longrightarrow
\cptyp{P}{\Gamma}
\]
\begin{multline*}
\inferrule
  {\inferrule*
     {\cptyp{P}{x:A,\Gamma}}
     {\cptyp{\sel{x}{inl}.P}{x:A \oplus B, \Gamma}} \\
   \inferrule*
     {\cptyp{Q}{x:\cpdual{A},\Delta} \\
      \cptyp{R}{x:\cpdual{B},\Delta}}
     {\cptyp{\case{x}{Q;R}}{x:\cpdual{A} \with \cpdual{B},\Delta}}}
  {\cptyp{\cut{x}{A \oplus B}{\sel{x}{inl}.P}{\case{x}{Q;R}}}{\Gamma,\Delta}}
\Longrightarrow \\
\inferrule
  {\cptyp{P}{x:A,\Gamma} \\
   \cptyp{Q}{x:\cpdual{A},\Delta}}
  {\cptyp{\cut{x}{A}{P}{Q}}{\Gamma,\Delta}}
\end{multline*}

\todo{\begin{itemize}
  \item Can we fix inference lines extending to the edge of the page?
  \item Requires more page width than we have.
\end{itemize}
We could fix both of these problems by not including the derivations...}

\parbox{1.2\textwidth}
{\small\begin{multline*}
\inferrule
  {\inferrule*
     {\cptyp{P}{y:B,\Gamma} \\
      \cptyp{Q}{y:\cpdual{B},x:F(B)}}
     {\cptyp{\corec{x}{y}{B}{P}{Q}}{x:\nu F,\Gamma}} \\
   \inferrule*
     {\cptyp{R}{x:\cpdual{F}(\mu (\cpdual{F})),\Delta}}
     {\cptyp{\rec{x}.R}{x:\mu (\cpdual{F}),\Delta}}}
  {\cptyp{\cut{x}{\nu F}{\corec{x}{y}{B}{P}{Q}}{\rec{x}.R}}{\Gamma,\Delta}}
\Longrightarrow \\
\inferrule
  {\cptyp{P}{y:B,\Gamma} \\
   \inferrule*
     {\cptyp{Q}{y:\cpdual{B},x:F(B)} \\
      \inferrule*
        {\cptyp{E}{x:\cpdual{F}(\cpdual{B}),z:F(\nu F)} \\
         \cptyp{R[z/x]}{z:\cpdual{F}(\mu \cpdual{F}),\Delta}}
        {\cptyp{\cut{z}{F(\nu F)}{E}{R[z/x]}}{x:\cpdual{F}(\cpdual{B}),\Delta}}}
     {\cptyp{\cut{x}{F(B)}{Q}{\cut{z}{F(\nu F)}{E}{R[z/x]}}}{y:\cpdual{B},\Delta}}}
  {\cptyp{\cut{y}{B}{P}{\cut{x}{F(B)}{Q}{\cut{z}{F(\nu F)}{E}{R[z/x]}}}}{\Gamma,\Delta}}
\end{multline*}

where $E = \expand{F}{z,x}{\corec{z}{y}{B}{\link{x}{y}}{Q[z/x]}}$.}

\caption{Principal cut elimination rules}\label{fig:beta-reduction}
\end{figure}

\begin{figure}\small
\begin{align*}
  \expand{X.C}{x,w}{Q} &= \link{x}{w} \\
  \expand{X.X}{x,w}{Q} &= Q \\
  \expand{X.C_1 \otimes C_2}{x,w}{Q} &= w(z).x[y].(\expand{X.C_1}{y,z}{Q[y/x,z/w]} \mid \expand{X.C_2}{x,w}{Q}) \\
  \expand{X.C_1 \oplus C_2}{x,w}{Q} &= \case{w}{\sel{x}{inl}.\expand{X.C_1}{x,w}{Q}; \sel{x}{inr}.\expand{X.C_2}{x,w}{Q}} \\
  \expand{X.\mu F'}{x,w}{Q} &= \corec{w}{y}{\nu(\cpdual{C}(A))}{\link{x}{y}}{\rec{y}.\expand{X.F' (\mu F')}{y,w}{Q[y/x]}}
\end{align*}
\caption{Definition of \textbf{map} for positive comibinators.}\label{fig:map}
\end{figure}

Principal cut reductions are given in Fig.~\ref{fig:beta-reduction}. Cut reduction for fixed points
corresponds to one step of unrolling, and depends on a subsidiary function $\mathbf{map}$.  The
positive cases of \textbf{map} are given in Fig.~\ref{fig:map}; the remaining cases can be obtained
by exchanging channels $x$ and $w$.

\begin{lemma}
  If $\cptyp{Q}{x:A,w:B}$ then \(\cptyp{\expand{F}{x,w}{Q}}{x:F(A), w:\cpdual{F}(B)}.\)
\end{lemma}

\subsection{Commuting Conversions}

\begin{figure}\small
\begin{align*}
  \cut{x}{A}{z(y).P}{Q} &\Longrightarrow z(y).\cut{x}{A}{P}{Q} \\
  \cut{x}{A}{z[y].(P \mid Q)}{R} &\Longrightarrow z[y].(\cut{x}{A}{P}{R} \mid Q) &&\text{if $x \not\in fn(Q)$} \\
  \cut{x}{A}{z[y].(P \mid Q)}{R} &\Longrightarrow z[y].(P \mid \cut{x}{A}{Q}{R}) &&\text{if $x \not\in fn(P)$} \\
  \cut{x}{A}{\sel{z}{inl}.P}{Q} &\Longrightarrow \sel{z}{inl}.\cut{x}{A}{P}{Q} \\
  \cut{x}{A}{\case{z}{P;Q}}{R} &\Longrightarrow \case{z}{\cut{x}{A}{P}{R}; \cut{x}{A}{Q}{R}} \\
  \cut{x}{A}{\rec{z}.P}{Q} &\Longrightarrow \rec{z}.\cut{x}{A}{P}{Q} \\
  \cut{x}{A}{\corec{z}{y}{B}{P}{Q}}{R} &\Longrightarrow \corec{z}{y}{B}{\cut{x}{A}{P}{R}}{Q}
\end{align*}
\caption{Commuting conversions}\label{fig:commuting}
\end{figure}

Commuting conversions are given in Fig.~\ref{fig:commuting}, and are unsurprising.

\subsection{Cut Elimination}

\begin{theorem}
  If $\cptyp{P}{\Gamma}$ and $P \Longrightarrow Q$, then $\cptyp{Q}{\Gamma}.$
\end{theorem}

Define $\Longrightarrow^\star$ to be the reflexive, transitive closure of $\equiv\Longrightarrow\equiv$.

\begin{theorem}
  If $\cptyp{P}{\Gamma}$, then there is a $Q$ such that $P \Longrightarrow^\star Q$ and $Q$ is cut-free.
\end{theorem}

\section{\mucp Examples}\label{sec:mucp-examples}

We will use $n$-ary sums $\oplus\{\overline{l:A}\}$,$\with\{\overline{l:A}\}$ with correspondingly
generalized \tkwd{case} and selection expressions.

\subsection{Church Numerals}

Basic idea: can code a type $?A$ by a least fixed point, and its dual $!(\cpdual{A})$ by the dual
greatest fixed point.  Will replicate Phil's Church numeral example using this coding.  Begin with
type abbreviations:
%
{\small\begin{align*}
  Query(A) &= \mu X.\oplus\{\clabel{w}:\bot,\clabel{c}:X \parr X,\clabel{d}:A\}, \\
  Bang(A) &= \nu X.\with\{\clabel{w}:1,\clabel{c}:X \otimes X,\clabel{d}:A\}.
\end{align*}}
%
Can translate type of Church numerals:
{\small\[
  Church = \forall A. Query(A \otimes \cpdual{A}) \parr (\cpdual{A} \parr A).
\]}
\todo{This requires second-order quantification.  To me, this argues for its removal.}
Now, expressing numbers is sarcasm-quotes obvious:
{\small\begin{align*}
  Zero_x &= x(A).x(s).x(z).\rec{s}.\sel{s}{w}.s().\link{z}{x}, \\
  One_x &= x(A).x(s).x(z).\rec{s}.\sel{s}{d}.s[a].(\link{a}{z} \mid \link{s}{x}).
\end{align*}}
Note the two different uses of the value $s$ of type $Query(A)$.  In $Zero$, we have no use of $s$,
so we select weakening and discard the resulting value of type $\bot$.  In $One$, we make one use of
it, and so select dereliction instead.

Of course, we don't want to have to code all the numbers manually.  Instead, we can devise a general
pattern for incrementing a Church numeral:
{\small\begin{align*}
  Inc_{x,y} =\ &y(A).y(s).y(z).\rec{s}.\sel{s}{c}.s(f).\rec{f}.\sel{f}{d}. \\
             &f[a].(\link{a}{z} \mid x[A].x[w].(\link{w}{s} \mid x[v].(\link{v}{f} \mid \link{y}{x}))).
\end{align*}}
%
We have that $\cptyp{Inc_{x,y}}{x:\cpdual{Church},y:Church}$, confirming that $Inc_{x,y}$ has the
expected type.  Finally, we can confirm that $Inc$ behaves as expected by showing, for example, that
{\small\[
  \cut{x}{Church}{Zero_x}{Inc_{x,y}} \Longrightarrow^\star One_{y}.
\]}
\todo{Use of $\Longrightarrow^\star$ before definition.}

\subsection{Peano Numerals}

As an alternative to the Church encodings in the previous section, we could use recursive types
directly to express Peano encodings of the naturals.  The type is natural:
%
{\small\[
  Peano = \mu X.\oplus\{zero: 1, succ: X\}.
\]}
%
The representation of values is more natural in this encoding, however.  For example, we have 0 and
increment encoded as follows:
%
{\small\begin{align*}
  Zero_x &= \rec{x}.\sel{x}{zero}.x[].0 \\
  Inc_{x,y} &= \rec{y}.\sel{y}{succ}.\link{x}{y}
\end{align*}}
Again, we can show that increment behaves as we expect; for example, we have that
%
{\small\[
  \cut{x}{Peano}{Zero_x}{Inc_{x,y}} \Longrightarrow^\star \rec{y}.\sel{y}{succ}.\rec{y}.\sel{y}{zero}.y[].0.
\]}

{\small\[\begin{array}{rcl@{\hspace{0mm}}ll}
  Add_{x,y,z} & = & \mcl{3}{\mkwd{corec}\:x\langle a \rangle} \\
  & & \quad (&\mcl{2}{a[y].\link{a}{z},} \\
  & & & a(b).\mkwd{case}\:x\:\{&\clabel{zero}: x().\link{a}{b}; \\
  & & & & \clabel{succ}: x[b'].(Inc_{b,b'} \mid  \link{a}{x}) \}).
\end{array}\]}
We can show that $\cptyp{Add_{x,y,z}}{x:\cpdual{Peano}, y:\cpdual{Peano}, z:Peano}$ and, for instance,
that
%
{\small\[
  \cut{x}{Peano}{One_x}{\cut{y}{Peano}{One_y}{Add_{x,y,z}}} \Longrightarrow^\star Two_z.
\]}

\subsection{Streams}

Another obvious thing to do with a recursion is streams.  The types are again quite intuitive:
{\small\begin{align*}
  Sink(A) &= \mu X. \oplus \{ \clabel{end}: \bot, \clabel{more}: A \parr X \}, \\
  Source(A) &= \nu X. \with \{ \clabel{end}: 1, \clabel{more}: A \otimes X \}.
\end{align*}}

Now, let's define some streams of naturals!  Let $Nat$ stand in for either of the encodings of
naturals.  We'll start with a stream of zeros.  Our form for defining greatest fixed points, called
\tkwd{corec}, allows an arbitrary coinvariant; in this case, we don't need one, so we'll just use 1:
%
{\small\begin{align*}
  Zeros_y =\ &\corec{y}{z}{1}{z[].0}{z().\case{y}{\clabel{end}: y[].0; \clabel{more}: y[x].(Zero_x | y[].0)}}.
\end{align*}}
%
In the \textrm{more} case, we rely on our earlier definition of $Zero$.  Building the stream of
naturals $0,1,2,\dots$ is more involved, but little more complicated. Note that we will need two
copies of each number in the stream: the one that appears in the stream itself, and the one used to
generate the remainder of the stream.  Therefore, we'll use a $Bang(Nat)$ as our coinvariant.  We
begin by lifting $Zero$ to type $Bang(Nat)$:
%
{\small\[\begin{array}{r@{\hspace{2mm}}c@{\hspace{2mm}}l@{\hspace{0mm}}l@{\:}l}
  LiftZero_z & = & \mcl{3}{\lrkwd \: z \langle a \rangle (a[].0,} \\
  & & \quad & a().\mkwd{case}\: z \: \{ &\clabel{w}: z[].0; \\
  & & & & \clabel{d}: Zero_z; \\
  & & & & \clabel{c}: z[w].(w[].0 \mid z[].0) \}).
\end{array}\]}
%
Again, we don't need a coinvariant, so we use 1.  The only interesting behavior is in the case of
dereliction, in which we rely (again) on our existing definition of $Zero$.  Next, we can lift the
$Inc$ definition above to operate on $Bang(Nat)$ processes:
%
{\small\[\begin{array}{r@{\hspace{2mm}}c@{\hspace{2mm}}l@{\hspace{0mm}}l@{\:}l}
  LiftInc_{x,y} & = & \mcl{3}{\lrkwd \: y \langle z \rangle (\link{x}{z},} \\
  & & \quad & \mkwd{case} \: y \: \{ & \clabel{w}: \rec{z}.\sel{z}{w}.y[].0; \\
  & & & & \clabel{d}: \rec{z}.\sel{z}{d}.Inc_{z,y}; \\
  & & & & \clabel{c}: \rec{z}.\sel{z}{c}.z(w).y[x].(\link{x}{w} \mid \link{y}{z}) \}).
\end{array}\]}
%
The invariant $z$ is of type $Bang(Nat)$.  In the case of dereliction, $LiftInc$ behaves as
$Inc$; the other cases are implemented in terms of the corresponding cases of the coinvariant.
Thus, we have that
\[
  \cptyp{LiftInc_{x,y}}{x:Query(\cpdual{Nat}),y:Bang(Nat)}.
\]
Finally, we can define a stream of naturals: the invariant is of type $Bang(Church)$, initialized by
$LiftZero$, and the \textrm{more} case relies on $LiftInc$:
%
{\small\[\begin{array}{r@{\hspace{2mm}}c@{\hspace{2mm}}l@{\hspace{0mm}}l@{\:}l}
  CNats_y & = & \mcl{3}{\lrkwd \: y \langle z \rangle (Zero_z,} \\
  & & \quad & \mkwd{case}\:y \{ & \clabel{end}: \rec{z}.\sel{z}{w}.z().y[].0; \\
  & & & & \clabel{more}: \rec{z}.\sel{z}{c}.z(w).y[x].\\
  & & & & \quad (\rec{w}.\sel{w}{d}.\link{x}{w} \mid LiftInc_{z,y}) \}).
\end{array}\]}
%
As we expect, we have that $\cptyp{CNats_y}{y:Stream(Nat)}$.
\\\todo{Example of using streams?  They're not terribly surprising.}

\section{Translation from \mugv to \gvpi}\label{sec:gvtogvpi}

Following our previous work~\cite{LindleyM14} we factor the
translation of \mugv into \mucp through an intermediate
translation. The language \gvpi is the restriction of \mugv to session
types, that is, \mugv without $\lto$, $\uto$, or $\otimes$. In order
to avoid $\otimes$, we disallow plain $\gvreceive{M}$, but do permit
it to be fused with a pair elimination $\gvlet{(x,
  y)}{\gvreceive{M}}{N}$. We can simulate all non-session types as
session types via a translation from \mugv to \gvpi.  The translation
on types is exactly as in our previous work. It is given by the
homomorphic extension of the following equations:
\[
\ba{@{}rclcl@{}}
\topi{T \lto U}    &=& \gvdual{\gvin{\gvdual{\topi{T}}}{\topi{U}}}
                   &=& \gvout{\topi{T}}{\gvdual{\topi{U}}} \\
\topi{T \uto U}    &=& \gvdual{\gvserver{(\gvin{\topi{\gvdual{T}}}{\topi{U}})}}
                   &=& \gvservice{(\gvout{\topi{T}}{\gvdual{\topi{U}}})} \\
\topi{T \otimes U} &=& \gvdual{\gvout{\gvdual{T}}{\topi{U}}}
                   &=& \gvin{\gvdual{\topi{T}}}{\gvdual{\topi{U}}} \\
\ea
\]
Each target type is the interface to the simulated source type. A
linear function is simulated by input on a channel; its interface is
output on the other end of the channel. An unlimited function is
simulated by a server; its interface is the service on the other end
of that channel. A tensor is simulated by output on a channel; its
interface is input on the other end of that channel. This duality
between implementation and interface explains the flipping of types in
Wadler's original CPS translation from GV to CP.

In order to translate away the arrows in the $\key{corec}$ rule, we
adopt a simplified session-oriented variant of the $\key{corec}$ rule
for \gvpi.
%
\begin{mathpar}
\inferrule{\gvtyp{x:T,p:\gvservice{(\gvout{T}{\gvout{X}{\outterm}})}, c:G(X)}{M}{\outterm} \\
           \gvtyp{\Phi,p:\gvservice{(\gvout{T}{\gvout{\nu G}{\outterm}})}}{N}{U}}
          {\gvtyp{\Phi}{\gvletrec{p}{x\,c}{M}{N}}{U}}
\end{mathpar}
%
This rule takes advantage of the fact that we can always translate
away functions using the $\topi{-}$ translation, and we can simulate
multiple arguments using a tensor.

The full translation on terms is as follows.
\begin{equations}
\topi{\lambda x.M} &=& \gvfork{z}{\gvlet{(x, z)}{\gvreceive{z}}{\gvlink{\topi{M}}{z}}} \\
\topi{L\,M} &=& \gvsend{\topi{M}}{\topi{L}} \\
\topi{M, N} &=&
  \gvfork{z}
    {\gvlink{(\gvsend{\topi{M}}{z})}{\topi{N}}} \\
\topi{\gvlet{(x, y)}{M}{N}} &=&
    \gvlet{(x, y)}{\gvreceive{\topi{M}}}{\topi{N}} \\
\topi{L : T \uto U} &=&
  \gvfork{z}{\gvlink{z}{(\gvserve{y}{\gvlink{\topi{L}}{y}})}} \\
\topi{L : T \lto U} &=& \gvrequest{\topi{L}} \\
\topi{\gvreceive{M}} &=& \topi{M}
\\[1ex]
\topi{\gvletrec{f}{\vec{x}\,c}{M}{N}} &=&
  \gvletrec{p}{z\,c}{\gvlet{\vec{x}}{z}{\topi{M[L/f]}}}{\topi{N[L/f]}} \\
&& \text{where }L = \lambda \vec{x} c.\gvsend{c}{(\gvsend{\vec{x}}{(\gvrequest{p})})} \\
\end{equations}%
Formally, this is a translation on derivations. We write type
annotations to indicate $\to$ introduction and elimination. For all
other cases, it is unambiguous to give the translation on plain term
syntax. Each introduction form translates to an interface
$\gvfork{z}{M}$ of type $\gvdual{S}$, where $M : \outterm$ provides
the implementation, with $z : S$ bound in $M$.
%
The only new case is that for $\key{corec}$. We package up all of the
arguments into a tuple, and simulate the interface to the arrows using
session operations in the obvious way dictated by the rest of the
$\topi{-}$ translation.

We can extend the translation on types to a translation on contexts:
\begin{equations}
\topi{x_1:T_1, \dots, x_n:T_n} &=& x_1:\topi{T_1}, \dots, x_n:\topi{T_n} \\
\end{equations}%
It is straightforward to verify that our translation preserves typing.
\begin{theorem}
If $\gvtyp{\Phi}{M}{T}$ then $\gvtyp{\topi{\Phi}}{\topi{M}}{\topi{T}}$.
\end{theorem}



%% \begin{mathpar}
%% %% \inferrule{un(\Psi) \\
%% %%            \gvtyp{\Psi,\vec{x}:\vec{T},f:\langle \vec{T}, X \rangle \uto \outterm, c:G(X)}{M}{\outterm} \\
%% %%            \gvtyp{\Phi,\Psi,f:\langle \vec{T}, \nu G \rangle \uto \outterm}{N}{U}}
%% %%           {\gvtyp{\Phi,\Psi}{\gvletrec{f\,\vec{x}\,c}{M}{N}}{U}}

%% \inferrule{\gvtyp{\vec{x}:\vec{T},f:\langle \vec{T}, X \rangle \uto \outterm, c:G(X)}{M}{\outterm} \\
%%            \gvtyp{\Phi,f:\langle \vec{T}, \nu G \rangle \uto \outterm}{N}{U}}
%%           {\gvtyp{\Phi}{\gvletrec{f\,\vec{x}\,c}{M}{N}}{U}}


%% %% \inferrule{\gvtyp{\vec{x}:\vec{T},f:\langle \vec{T}, X \rangle \uto \outterm, c:G(X)}{M}{\outterm} \\
%% %%            \gvtyp{\Phi,f:\langle \vec{T}, \nu G \rangle \uto \outterm}{N}{U}}
%% %%           {\gvtyp{\Phi}{\gvletrec{f\,\vec{x}\,c}{M}{N}}{U}}

%% %% \inferrule{\gvtyp{\vec{x}:\vec{T},p:\gvout{\langle \vec{T}, X \rangle}{\outterm}, c:G(X)}{M}{\outterm} \\
%% %%            \gvtyp{\Phi,p:\gvout{\langle \vec{T}, \nu G \rangle}{\outterm}}{N}{U}}
%% %%           {\gvtyp{\Phi}{\gvletrec{p\,\vec{x}\,c}{M}{N}}{U}}

%% %% \inferrule{\gvtyp{x:T, f:T \uto X \lto \outterm, c:G(X)}{M}{\outterm} \\
%% %%            \gvtyp{\Phi, f:T \uto \nu G \lto \outterm}{N}{U}}
%% %%           {\gvtyp{\Phi}{\gvletrec{f\,x\,c}{M}{N}}{U}}

%% %% \inferrule{\gvtyp{x:T, f:(T \otimes X) \uto \outterm, c:G(X)}{M}{\outterm} \\
%% %%            \gvtyp{\Phi, f:(T \otimes \nu G) \uto \outterm}{N}{U}}
%% %%           {\gvtyp{\Phi}{\gvletrec{f\,x\,c}{M}{N}}{U}}


%% \inferrule{\gvtyp{x:T,p:\gvservice{(\gvout{T}{\gvout{X}{\outterm}})}, c:G(X)}{M}{\outterm} \\
%%            \gvtyp{\Phi,p:\gvservice{(\gvout{T}{\gvout{\nu G}{\outterm}})}}{N}{U}}
%%           {\gvtyp{\Phi}{\gvletrec{p\,x\,c}{M}{N}}{U}}
%% \end{mathpar}


%% \newcommand{\replicate}[2]{{!#1(#2)}}
%% \newcommand{\derelict}[2]{{?#1[#2]}}

%% \[
%% \bl
%% \left\llbracket
%% \inferrule{\gvtyp{x:T,p:\gvservice{(\gvout{T}{\gvout{X}{\outterm}})},c:G(X)}{M}{\outterm} \\
%%            \gvtyp{\Phi,p:\gvservice{(\gvout{T}{\gvout{\nu G}{\outterm}})}}{N}{U}}
%%           {\gvtyp{\Phi}{\gvletrec{p\,x\,c}{M}{N}}{U}}
%% \right\rrbracket z = \\
%% \qquad \cut{p}{}{\replicate{p}{y}.y(x).y(c).y().\corec{c}{w}{}{w[x].w[].0}{P}}{\tocp{N}z} \\
%% %%\cut{p}{}{\replicate{p}{y}.y(x).y(c).y().\corec{c}{ci}{}{\tocp{init}^\star}{\tocp{M^\dagger}^\star}}{\tocp{N}z}
%% \qquad \qquad \text{where }
%% P = \cut{p}{}{\replicate{p}{y}.y(x).y(c).y().c[x].c[].0}{w(x).\tocp{M}w} \\
%% \el
%% \]


%% \[
%%   \tocp{M}^\star = \cut{z}{\bot}{\tocp{M}z}{z[].0}
%% \]

%% \[
%%  init = \gvsend{x}{ci}
%% \]

%% \[
%% M^\dagger =
%%   \bl
%%   \key{let}\,p=\,\gvfork{p}
%%                    {\bl
%%                     \key{let}\,(x,y) = \gvreceive{(\gvrequest{p})}\,\key{in} \\
%%                     \key{let}\,(c,y) = \gvreceive{y}\,\key{in} \\
%%                     \quad \gvsend{x}{c}\,\key{in}
%%                     \el} \\
%%   \gvlet{(x,ci)}{\gvreceive{ci}}{M} \\
%%   \el
%% \]


\section{Translation from \gvpi to \mucp}\label{sec:gvpitocp}

%% SL: I think we've decided to embrace exponentials anyway
%% GM: Says who?
%%
%% \todo{\begin{itemize}
%%   \item Translating unlimited GV terms (at the moment, this is only unlimited lambdas) requires
%%     exponentials, either directly or encoded, in CP.  Adding exponentials to CP requires a
%%     significant expansion of the existing typing and cut reduction rules (not technically difficult,
%%     but increasingly overwhelming the actual point of the paper).  Using coding would not require
%%     extension of the CP rules, but differs from the existing GV $\to$ CP translations.
%% \end{itemize}}

\todo{Fill in the text for this section}

Translation of session types from \gvpi to \mucp.

\begin{align*}
\tocp{\gvout{T}{S}}        &= \cpdual{\tocp{T}} \otimes \tocp{S} &
\tocp{\oplus \{l_i:S_i \}} &= \oplus \{l_i:\tocp{S_i}\} &
\tocp{\outterm}            &= 1 \\
\tocp{\gvin{T}{S}}         &= \tocp{T} \parr \tocp{S} &
\tocp{\with \{l_i:S_i \}}  &= \with \{l_i:\tocp{S_i}\} &
\tocp{\interm}             &= \bot \\
\tocp{\gvservice{S}}       &= \cpquery{\tocp{S}} &
\tocp{\gvserver{S}}        &= \cpbang{\tocp{S}} \\
\tocp{X}                   &= X &
\tocp{\gvdual{X}}          &= \cpdual{X} \\
\tocp{X.S}                 &= X. \tocp{S} &
\tocp{\nu G}               &= \nu \tocp{G} &
\tocp{\mu G}               &= \mu \tocp{G}
\end{align*}

\newcommand{\replicate}[2]{{!#1(#2)}}
\newcommand{\derelict}[2]{{?#1[#2]}}

\begin{align*}
\left\llbracket \inferrule{\gvtyp{\Phi}{N}{S}}{\gvtyp{\Phi,x:\interm}{N}{S}} \right\rrbracket\!\!z &=
  \inferrule
    {\cptyp{\tocp{N}z}{\tocp{\Phi},z:\cpdual{\tocp{S}}}}
    {\cptyp{x().\tocp{N}z}{\tocp{\Phi},x:\bot,z:\cpdual{\tocp{S}}}}
\\[3ex]
\left\llbracket \inferrule{\gvtyp{\Phi,x:\interm,x':\interm}{N}{S}}
                          {\gvtyp{\Phi,x:\interm}{N[x/x']}{S}} \right\rrbracket \!\!z &=
  \inferrule
    {\cptyp{\tocp{N}z}{\tocp{\Phi},x:\bot,x':\bot,z:\cpdual{\tocp{S}}}}
    {\cptyp{\cut{x'}{}{\tocp{N}z}{x'[].0}}{\tocp{\Phi},x:\bot,z:\cpdual{\tocp{S}}}}
\\[3ex]
\tocp{x}z &= \link{x}{z} \\
\tocp{\gvsend{M}{N}}z &= \cut{x}{}{x[y].(\tocp{M}y \mid \link{x}{z})}{\tocp{N}x} \\
\tocp{\gvlet{(x,y)}{\gvreceive{M}}{M}}z &= \cut{y}{}{\tocp{M}y}{y(x).\tocp{N}z} \\
\tocp{\gvselect{l}{M}}z &= \cut{x}{}{\tocp{M}x}{x[l].\link{x}{z}} \\
\tocp{\gvcase{M}{l_n\,x.N_i}}z &=  \cut{x}{}{\tocp{M}x}{\case{x}{l_i.\tocp{N_i}z}} \\
\tocp{\gvfork{x}{M}}z &= \cut{x}{}{\cut{y}{}{\tocp{M}y}{y[].0}}{\link{x}{z}} \\
\tocp{\gvlink{M}{N}}z &= z().\cut{x}{}{\tocp{M}x}{\tocp{N}x} \\
%\tocp{\gvSendType{S}{M}}z &=
%  \cut{x}{\tocp{M}x}{\cpSendType{x}{\tocp{S}}{\cpLink{x}{z}}} \\
%\tocp{\gvReceiveType{X}{M}}z &=
%  \cut{x}{\tocp{M}x}{\cpReceiveType{x}{X}{\cpLink{x}{z}}} \\
\tocp{\gvserve{y}{M}}z &= \replicate{z}{y}.\cut{x}{}{\tocp{M}x}{x[].0} \\
\tocp{\gvrequest{M}}z &= \cut{x}{}{\tocp{M}x}{\derelict{x}{y}.\link{y}{z}} \\
\end{align*}

{\small
\[
\left\llbracket
\inferrule{\gvtyp{\Phi}{M}{\mu G}}{\gvtyp{\Phi}{M}{G (\mu G)}}
\right\rrbracket z =
\cut{y}{\nu \tocp{G}}{\tocp{\gvtyp{\Phi}{M}{\mu G}}y}{\rec{y}.\link{y}{z}}
\]

\[
\left\llbracket
\inferrule{\gvtyp{\Phi}{M}{G(\nu G)}}{\gvtyp{\Phi}{M}{\nu G}}
\right\rrbracket z =
\cut{y}{\nu \tocp{G}}{\tocp{\gvtyp{\Phi}{M}{G(\nu G)}}y}{\rec{z}.\link{y}{z}}
\]

\[
\left\llbracket
\inferrule{\gvtyp{\Phi}{M}{G(\mu G)}}{\gvtyp{\Phi}{M}{\mu G}}
\right\rrbracket z =
\cut{y}{\tocp{G}(\mu \tocp{G})}{\tocp{\gvtyp{\Phi}{M}{G (\mu G)}}}
       {\corec{z}{x}{\tocp{G}(\mu \tocp{G})}
              {\link{y}{x}}
              {\expand{G}{x,z}{\rec{x}.\link{x}{z}}}}
\]

\[
\left\llbracket
\inferrule{\gvtyp{\Phi}{M}{\nu G}}{\gvtyp{\Phi}{M}{G (\nu G)}}
\right\rrbracket z =
\cut{y}{\mu \tocp{G}}{\tocp{\gvtyp{\Phi}{M}{\nu G}}}
       {\corec{y}{x}{\cpdual{\tocp{G}}(\nu \cpdual{\tocp{G}})}
              {\link{z}{x}}
              {\expand{G}{x,y}{\rec{x}.\link{x}{y}}}}
\]

\[
\bl
\left\llbracket
\inferrule{\gvtyp{p:\gvservice{(\gvout{T}{\gvout{X}{\outterm}})},x:T,c:G(X)}{M}{\outterm}}
          {\gvtyp{}{\gvfix{p}{x\,c}{M}}{\gvservice{(\gvout{T}{\gvout{\nu G}{\outterm}})}}}
\right\rrbracket z = \\
\replicate{z}{y}.y(x).y(c).y(). \\
\quad \corec{c}{w}{}{w[x].w[].0}{\cut{p}{}{\replicate{p}{y}.y(x).y(c).y().c[x].c[].0}{w(x).\tocp{M}w}} \\
\el
\]
%
\todo{Maybe move the definition of the sugar elsewhere}
%
where we use the following syntactic sugar for output along a channel:
\[
x[y].P \equiv x[y'].(\link{y}{y'} \mid P)
\]



%% \begin{multline*}
%% \left\llbracket
%% \inferrule{\gvtyp{x_i:T_i,f:\vec{T} \uto Q \uto \outterm,c:G(Q)}{M}{\outterm} \\
%%            \gvtyp{\Phi,f:\vec{T} \uto \nu G \uto \outterm}{N}{U}}
%%           {\gvtyp{\Phi}{\gvletrec{f\,x_1 \dots x_n\,c}{M}{N}}{U}}
%% \right\rrbracket z = \\
%% \replicate{f}{f_1}.f_1(x_1)\dots.\replicate{f_{n-1}}{f_n}.f_n(x_n).\corec{c}{ci}{}{\tocp{init_{ci}}^\star}{\tocp{M^\dagger_{ci}}^\star}
%% \end{multline*}

%% where

%% \[
%%   \tocp{M}^\star = \cut{z}{\bot}{\tocp{M}z}{z[].0}
%% \]

%% \[
%%  init_{ci} = \gvsend{x_n}{(\dots(\gvsend{x_1}{ci}))}
%% \]

%% \[\begin{array}{rcl}
%% M^\dagger_{ci} &=& \gvlet{f}{\lambda x_1\dots\lambda x_n.\lambda c.\gvsend{x_n}{(\dots(\gvsend{x_1}{c})\dots)}}
%%                 {\\&&\gvlet{(x_1,ci)}{\gvreceive{ci}}
%%                 {\\&&\vdots\\&&\gvlet{(x_n,ci)}{\gvreceive{ci}}{M}}}
%% \end{array}\]
%% }

\begin{theorem}
  If $\gvtyp{\Phi}{M}{T}$, then $\cptyp{\tocp{M}z}{\tocp{\Phi},z:\cpdual{\tocp{T}}}$.
\end{theorem}

\section{Related Work}\label{sec:related}

\section{Conclusion and Future Work}\label{sec:future}

\begin{itemize}
\item Translation of \mucp{} into \mugv{}?
\item Direct (asynchronous) semantics of \mugv{}?
\item Recursive types (instead of just recursive sessions)?
\item $\mathrm{MIX}_0,\mathrm{MIX}_2$ and the treatment of closed channels.
\end{itemize}

\label{sect:bib}
\bibliographystyle{plain}
\bibliography{main}

\end{document}
