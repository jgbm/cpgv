% -*- fill-column: 100 -*-

\documentclass[orivec,envcountsame]{llncs}

\usepackage{amsmath,amssymb,mathwidth,stmaryrd,xcolor,xspace}
\addtolength{\jot}{-3px}

\usepackage{mathpartir}
\mprset{sep=1em}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

\newcommand{\with}{\mathbin\binampersand}
\newcommand{\parr}{\mathbin\bindnasrepma}
\newcommand{\cpdual}[1]{#1^\perp}
\newcommand{\cpbang}[1]{{! #1}}
\newcommand{\cpquery}[1]{{? #1}}
\newcommand{\gvdual}[1]{\overline{#1}}
\newcommand{\gvout}[2]{{!#1.#2}}
\newcommand{\gvin}[2]{{?#1.#2}}
\newcommand{\lto}{\ensuremath{\multimap}}
\newcommand{\uto}{\ensuremath{\rightarrow}}
\newcommand{\outterm}{\mathrm{end}_!}
\newcommand{\interm}{\mathrm{end}_?}
\newcommand{\gvserver}[1]{\flat #1}
\newcommand{\gvservice}[1]{\sharp #1}
\newcommand{\trule}[1]{(\textit{#1})}
\newcommand{\cptyp}[2]{#1 \vdash #2}
\newcommand{\gvtyp}[3]{#1 \vdash #2 : #3}

\newcommand{\mapname}{\mathsf{map}}
\newcommand{\map}[3]{\mapname^{#1}_{#2}(#3)}
\newcommand{\gvmap}[3]{\mapname^{#1}_{#2}\:#3}

\newcommand{\mkwd}[1]{\mathsf{#1}}
\newcommand{\tkwd}[1]{\textsf{#1}}
\newcommand{\link}[2]{#1 \leftrightarrow #2}
\newcommand{\cut}[4]{\mkwd{new}\:#1 \: (#3 \mid #4)}
\newcommand{\replicate}[2]{{!#1(#2)}}
\newcommand{\derelict}[2]{{?#1[#2]}}
\newcommand{\rec}[1]{\mkwd{rec}\:#1}
\newcommand{\corec}[5]{\mkwd{corec}\:#1 \langle #2 \rangle (#4,#5)}
\newcommand{\clabel}[1]{\mathrm{#1}}
\renewcommand{\case}[2]{\mkwd{case}\:#1\:\{#2\}}
\newcommand{\sel}[2]{#1[\clabel{#2}]}
\newcommand{\gvsend}[2]{\mkwd{send}\:#1\:#2}
\newcommand{\gvreceive}[1]{\mkwd{receive}\:#1}
\newcommand{\gvlet}[3]{\mkwd{let}\;#1 = #2\;\mkwd{in}\;#3}
\newcommand{\gvselect}[2]{\mkwd{select}\:#1\:#2}
\newcommand{\gvcase}[2]{\mkwd{case}\:#1\:\{#2\}}
\newcommand{\gvlink}[2]{\mkwd{link}\:#1\:#2}
\newcommand{\gvfork}[2]{\mkwd{fork}\:#1.#2}
\newcommand{\lrkwd}{\mkwd{fix}}
\newcommand{\gvfix}[3]{\lrkwd\:#1\:#2 = #3}
\newcommand{\gvletrec}[4]{\gvlet{#1}{\gvfix{#1}{#2}{#3}}{#4}}
\newcommand{\gvserve}[2]{\mkwd{serve}\:#1.#2}
\newcommand{\gvrequest}[1]{\mkwd{request}\:#1}

\newcommand{\gvreceivek}[4]{\gvlet{({#1}, {#2})}{\gvreceive{#3}}{#4}}


\newcommand{\key}{\mkwd}
\newcommand{\fix}{\lrkwd}

\newcommand{\tocpbig}[1]{\left\llbracket #1 \right\rrbracket}

\newcommand{\tocp}[1]{\llbracket #1 \rrbracket}
\newcommand{\togv}[1]{\llparenthesis #1 \rrparenthesis}
\newcommand{\De}{\mathcal{D}}

\newcommand{\topi}[1]{({#1})^\star}

\newcommand{\un}{un}
\newcommand{\lin}{lin}

\newcommand{\mucp}{$\mu\mathrm{CP}$\xspace}
\newcommand{\mugv}{$\mu\mathrm{GV}$\xspace}
\newcommand{\gvpi}{$\mu\mathrm{GV}\pi$\xspace}

\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}

\newcommand{\bl}{\ba[t]{@{}l@{}}}
\newcommand{\el}{\ea}

\newenvironment{equations}{\[\ba{@{}r@{~}c@{~}l@{}}}{\ea\]}
\newenvironment{eqs}{\ba{@{}r@{~}c@{~}l@{}}}{\ea}

\newcommand{\secref}[1]{(\S\ref{sec:#1})}

\title{Recursive Session Types and Linear Logic}
\author{J. Garrett Morris \and Sam Lindley \and Philip Wadler}
\institute{University of Edinburgh \\
           \email{Garrett.Morris@ed.ac.uk,\{slindley,wadler\}@inf.ed.ac.uk}}

\newcommand{\todo}[1]{{\noindent\small\color{red} \framebox{\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{\textbf{TODO:} #1}}}}
%\newcommand{\todo}[1]{}

\begin{document}

\maketitle

\begin{abstract}
  A Curry-Howard correspondence between session types and linear logic was first demonstrated by
  Caires and Pfenning for intuitionistic linear logic, and later adapted to the classical setting by
  Wadler. These correspondences give both a logical interpretation of session types and a
  computational interpretation of linear logic proofs, and ensure race freedom, deadlock freedom,
  and termination of well-typed processes. However, neither system accomodates recursive sessions,
  as might be used to represent stateful servers or inductive data types.

  We extend Wadler's correspondence to recursive processes and sessions using equirecursive session
  types. We show that the resulting types and processes are in correspondence with the propositions
  and proofs of Baelde's extension of linear logic with greatest and least fixed points. Unlike
  prior accounts of recursive session typing, our system distinguishes recursive and corecursive
  processes, and exploits their duality to maintain race freedom, deadlock freedom, and termination,
  even in the presence of unbounded corecursive processes.
\end{abstract}

\section{Introduction}\label{sec:intro}

\todo{\begin{itemize}
\item History of session types;
\item Curry-Howard correspondence developed by Caires and Pfenning~\cite{CairesPfenning10};
\item Wadler's adaptation of Caires and Pfenning's correspondence to classical setting~\cite{Wadler12};
\item Recursion in process calculi; and,
\item Fixed points in LL.
\end{itemize}}

The primary contribution of this paper is the extension of Wadler's Curry-Howard correspondence to
recursive session types, while preserving the significant results of the existing correspondence
(race and deadlock freedom and termination).  To this end:
\begin{itemize}
\item We begin by presenting a simple, session-typed functional language~\secref{mugv}, which
  includes support for recursive session types.  In contrast to existing approaches to recursive
  session types, we distinguish between the greatest and least fixed points of recursive equations.
  We give several examples of recursive processes and their use.
\item We next review Baelde's combinators for recursion in Girard's LL, and extend Wadler's term
  assignment for LL to include terms corresponding to recursion and corecursion~\secref{mucp}.  We
  demonstrate the use of these combinators both to code traditional recursive data types and
  infinite streams.
\item Finally, we show that the languages \mugv and \mucp are equally expressive.  This has two
  stages.  First, we show a translation of the functional features of \mugv into its process
  oriented features~\secref{gvtogvpi}; we call the resulting restricted language \gvpi.  Second, we
  show that programs in \gvpi can be translated to terms of \mucp~\secref{gvpitocp}, and that terms
  of \mucp can be translated to terms of \gvpi~\secref{cptogvpi}.
\end{itemize}
We conclude with a survey of related~\secref{related} and future~\secref{future} work.

\todo{Full list of examples: \begin{enumerate}
\item Stream of zeros (no use of coinvariant);
\item Stream of naturals (simple coinvariant);
\item Stream of Fibonacci numbers (slightly less simple coinvariant);
\item Calculator (recursion and choice)
\item Bit strings (correspondence to Toninho et al.)
\item Church numerals
\item Peano numerals
\item Simulating exponentials with fixed points
\end{enumerate}}

\section{A Session-Typed Functional Language}\label{sec:mugv}

\subsection{Types and Terms of \mugv}\label{sec:mugv-syntax}

\begin{figure}\small
\[\begin{array}{l@{\hspace{1mm}}r@{\hspace{2mm}}c@{\hspace{2mm}}l}
  \text{Types} & T,U,V & ::= & S \mid T \otimes U \mid T \lto U \mid T \uto U \\
  \text{Session types} & S & ::= & \gvout{T}{S} \mid \gvin{T}{S} \mid \oplus \{ l_i : S_i \} \mid \with \{ l_i : S_i \} \mid \outterm \mid \interm \\
   & & \mid & X \mid \gvdual{X} \mid \mu G \mid \nu G \mid \gvservice{S} \mid \gvserver{S} \\
  \text{Type operators} & G & ::= & X.S % \\
%  \text{Terms} & M,N & ::= & x \mid \lambda x.N \mid M\,N \mid (M,N) \mid \gvlet{(x,y)}{M}{N} \\
%   & & \mid & \gvsend{M}{N} \mid \gvreceive{M} \mid \gvselect{l_i}{M} \mid \gvcase{M}{l_i : N_i} \\
%   & & \mid & \gvlink{M}{N} \mid \gvfork{x}{M} \mid \gvletrec{x}{M}{N}
\end{array}\]
\caption{\mugv Types and Session Types}\label{fig:gv-syntax}
\end{figure}

In this section, we present \mugv, a simple functional language with session types patterned on the
language of Gay and Vasconcelos~\cite{GayVasconcelos10} (which we call LAST) and Wadler's language
GV. Figure~\ref{fig:gv-syntax} gives the syntax of \mugv terms and types. Types include linear pairs
($T \otimes U$), and both linear ($T \lto U$) and unlimited ($T \uto U$) functions. Session types
include input ($\gvin{T}{S}$), output ($\gvout{T}{S}$), selection ($\oplus\{ l_i:S_i \}$) and choice
($\with\{l_i:S_i\}$). We have two variations on the closed channel ($\interm$ and $\outterm$). These
arise from our interpretation of session types in classical linear logic, where there is no
self-dual proposition to implement closed channels. We include a notion of replicated sessions,
corresponding to exponentials in linear logic: a channel of type $\gvservice{S}$ is a ``service'',
providing any number of channels of type $S$; a channel of type $\gvserver{S}$ is the ``server''
providing such a service. Finally, we include session variables and their duals ($X,\gvdual{X}$),
and two forms of recursive session types, corresponding to least ($\mu X.S$) and greatest ($\nu
X.S$) fixed points. If $G$ is an operator $X.S$, we write $G(S')$ for the substitution instance
$S[S'/X]$.
%
Each type $T$ is either linear ($\lin{T}$) or unlimited ($\un{T}$). The linearity of $T$ is
determined entirely by its top level type constructor.
%
All types are linear except unlimited functions $T \uto U$, replicated channels $\gvservice{S}$, and
closed input channels $\interm$.

Duality on non-recursive session types is standard.
{\small\begin{align*}
\gvdual{\gvout{T}{S}} &= \gvin{T}{\gvdual{S}} &
  \gvdual{\oplus \{ l_i: S_i \}} &= \with \{ l_i : \gvdual{S_i} \} &
  \gvdual{\interm} &= \outterm &
  \gvdual{\gvservice{S}} &= \gvserver{\gvdual{S}} &
  \gvdual{X} &= \gvdual{X} \\
\gvdual{\gvin{T}{S}} &= \gvout{T}{\gvdual{S}} &
  \gvdual{\with \{ l_i: S_i \}} &= \oplus \{ l_i : \gvdual{S_i} \} &
  \gvdual{\outterm} &= \interm &
  \gvdual{\gvserver{S}} &= \gvservice{\gvdual{S}} &
  \gvdual{\gvdual{X}} &= X
\end{align*}}%
We define the dual of an operator $G = X.S$ as:
\[
\gvdual{G} = X.\gvdual{G(\gvdual{X})}
\]%
%
Observe that $\gvdual{G}(\gvdual{S}) = \gvdual{G(S)}$, which allows us to
give a natural definition of duality for fixed points:
%
{\small\begin{align*}
\gvdual{\mu G} &= \nu \gvdual{G} & \gvdual{\nu G} = \mu \gvdual{G}
\end{align*}}%
Unlike many notions of duality for session types, our definition preserves duality when recursive
session types are unfolded, even when the recursion occurs in messages.  For example, consider the
operator $G = X.\gvin{X}{\interm}$, its dual $\gvdual{G} = X.\gvout{\gvdual{X}}{\outterm}$, and the
session types $\mu G$ and $\nu \gvdual{G}$.  Unfolding the first type yields $G(\mu G)$, or
$\gvin{\mu G}{\interm}$; unfolding the second yields {\small\[ \gvdual{G}(\nu \gvdual{G}) =
  \gvout{\gvdual{\nu \gvdual{G}}}{\outterm} = \gvout{\mu G}{\outterm},
\]}%
which is the dual of $\gvin{\mu G}{\interm}$.

To ensure that fixed points exist, we require that all operators $X.S$ be monotonic, that is,
variables may appear only as positive subformulas of $S$, and negated variables only as negative
subformulas. As usual, the subformula $T$ in types $T \lto U$ and $T \uto U$ is
negative. Futhermore, the argument $T$ in the session type $\gvout{T}{S}$ is negative. All other
subformulas are positive. Thus, the operator $X.\gvout{X}{\outterm}$ is not monotonic, but the
operator $X.\gvout{(X \uto \outterm)}{\outterm}$ is.

\todo{Formally define monotonicity of operators}

%% pos(X, ~X) = false
%% pos(X, X) = true
%% pos(X, T -o U) = neg(X, T) and pos(X, U)
%% pos(X, T -> U) = neg(X, T) and pos(X, U)
%% pos(X, !T.S) = neg(X, T) and pos(X, S)
%% etc.


\begin{figure}
Structural rules
\begin{mathpar}
\inferrule{ }{\gvtyp{x:T}{x}{T}}

\inferrule{\gvtyp{\Phi}{M}{U} \\
           un(T)}
          {\gvtyp{\Phi,x:T}{M}{U}}

\inferrule{\gvtyp{\Phi,x:T,x':T}{M}{U} \\
           un(T)}
          {\gvtyp{\Phi,x:T}{M[x/x']}{U}}
\end{mathpar}
Lambda rules
\begin{mathpar}
\inferrule{\gvtyp{\Phi,x:T}{M}{U}}
          {\gvtyp{\Phi}{\lambda x.M}{T \lto U}}

\inferrule{\gvtyp{\Phi}{M}{T \lto U} \\
           \gvtyp{\Psi}{N}{T}}
          {\gvtyp{\Phi,\Psi}{M\,N}{U}}

\inferrule{\gvtyp{\Phi}{M}{T \lto U} \\
           un(\Phi)}
          {\gvtyp{\Phi}{M}{T \uto U}}

\inferrule{\gvtyp{\Phi}{M}{T \uto U}}
          {\gvtyp{\Phi}{M}{T \lto U}}

\inferrule{\gvtyp{\Phi}{M}{T} \\
           \gvtyp{\Psi}{N}{U}}
          {\gvtyp{\Phi,\Psi}{(M,N)}{T \otimes U}}

\inferrule{\gvtyp{\Phi}{M}{T \otimes U} \\
           \gvtyp{\Psi,x:T,y:U}{N}{V}}
          {\gvtyp{\Phi,\Psi}{\gvlet{(x,y)}{M}{N}}{V}}
\end{mathpar}
Session rules
\begin{mathpar}
\inferrule{\gvtyp{\Phi}{M}{S} \\
           \gvtyp{\Psi}{N}{\gvdual{S}}}
          {\gvtyp{\Phi,\Psi}{\gvlink{M}{N}}{\outterm}}

\inferrule{\gvtyp{\Phi}{M}{T} \\
           \gvtyp{\Psi}{N}{\gvout{T}{S}}}
          {\gvtyp{\Phi,\Psi}{\gvsend{M}{N}}{S}}

\inferrule{\gvtyp{\Phi}{M}{\gvin{T}{S}}}
          {\gvtyp{\Phi}{\gvreceive{M}}{T \otimes S}}

\inferrule{\gvtyp{\Phi,x:\gvdual{S}}{M}{\outterm}}
          {\gvtyp{\Phi}{\gvfork{x}{M}}{ S}}

\inferrule{\gvtyp{\Phi}{M}{\oplus \{ l_i:S_i \}}}
          {\gvtyp{\Phi}{\gvselect{l_i}{M}}{S_i}}

\inferrule{\gvtyp{\Phi}{M}{\with \{ l_i:S_i \}} \\
           \gvtyp{\Psi,x:S_i}{N_i}{T}}
          {\gvtyp{\Phi,\Psi}{\gvcase{M}{l_i\,x.N_i}}{T}}
\end{mathpar}
Replicated session rules
\begin{mathpar}
\inferrule{\gvtyp{\Phi,x:\gvdual{S}}{M}{\outterm} \\
           un(\Phi)}
          {\gvtyp{\Phi}{\gvserve{x}{M}}{\gvservice{S}}}

\inferrule{\gvtyp{\Phi}{M}{\gvservice{S}}}
          {\gvtyp{\Phi}{\gvrequest{M}}{S}}
\end{mathpar}
Recursive session rules
\begin{mathpar}
\inferrule{\gvtyp{\Phi}{M}{G(\mu G)}}
          {\gvtyp{\Phi}{M}{\mu G}}

\inferrule{\gvtyp{\Phi}{M}{\mu G}}
          {\gvtyp{\Phi}{M}{G (\mu G)}}

\inferrule{\gvtyp{\Phi}{M}{G(\nu G)}}
          {\gvtyp{\Phi}{M}{\nu G}}

\inferrule{\gvtyp{\Phi}{M}{\nu G}}
          {\gvtyp{\Phi}{M}{G(\nu G)}}

\inferrule{\gvtyp{\vec{x}:\vec{T},f:\langle \vec{T}, X \rangle \uto \outterm, c:G(X)}{M}{\outterm}}
          {\gvtyp{}{\gvfix{f}{\vec{x}\,c}{M}}{\langle \vec{T}, \nu G \rangle \uto \outterm}}
\end{mathpar}

\caption{\mugv Terms and Typing Rules}\label{fig:gv-typing}
\end{figure}

Figure~\ref{fig:gv-typing} gives the terms and typing rules of \mugv. The structural rules account
for variables, and for weakening and contraction on variables of unlimited type. The rules for the
functional terms are standard; note that, to account for linearity, the context is split in the
rules for application and pair introduction and elimination, and is limited to unlimited types in
the introduction of unlimited arrows.

The session rules for input, output, choice and selection are standard. Following our earlier
work~\cite{LindleyM14}, we provide a term $\gvlink{M}{N}$ to implement channel forwarding; while a
version of \tkwd{link} exists for any session type $S$, it has no generic implementation in terms of
other constructs of \mugv. The \tkwd{fork} construct provides session initiation; like Wadler's GV,
but unlike LAST (and much other work on process calculi), our system is deterministic.

Channels of type $\gvservice{S}$ offer arbitrarily many sessions of type $S$; correspondingly,
channels of type $\gvserver{S}$ must consume arbitrarily many $S$ sessions. The rule for
$\gvserve{x}{M}$ parallels that for $\tkwd{fork}$: it defines the server (which replicates $M$) and
provides the channel by which it may be used (of type $\gvdual{\gvserver{S}} =
\gvservice{\gvdual{S}}$).
% As a consequence, there is no rule involving type $\gvserver{S}$.

Finally, we provide recursive channels. The first four typing rules allow recursive types to be used
as their unfoldings, and vice versa. Previous work on recursive sessions has typically included an
equivalence relation on types, taking unfolding into account, and interpretting typing rules up to
equivalence. We present explicit rules in order to simplify the translation into \mucp, where these
rules correspond to explicit terms implementing the equivalences.
%
The fixed point construct $\gvfix{f}{\vec{x}\,c}{M}$ is used to define corecursive sessions. We
introduce the following syntactic sugar for multi-argument functions:
\[
  \langle T_1, T_2, \dots, T_n \rangle \uto U \equiv T_1 \uto T_2 \lto \dots \lto T_n \lto U
\]
Note that the right-hand side is isomorphic to $(T_1 \otimes \dots \otimes T_n) \uto U$.  In the
remainder of the section, we will give several simple examples to motivate the typing and use of
$\lrkwd$.

Syntactic sugar for let binding:
\[
\key{let}\:x=M\:\key{in}\:N \equiv (\lambda x.M)\:N
\]

\todo{This example is useless because we cannot actually use a stream of ints without introducing a
  way of terminating the stream! ($\nu X.\with \{next: !Int.X, done: \outterm \}$)}


Type of a stream of integers:
\[
Ints = \nu X.!Int.X
\]

Using $\fix$ we can define a function that outputs a stream of zeros along a corecursive
channel:
\[
  \bl
  makeZeros : Ints \uto \outterm \\
  makeZeros = \fix\:f\:c = \gvlet{d}{\gvsend{0}{c}}{f\:d} \\
  \el
\]
The body outputs a single zero and then recurses. In order to read from the stream, we use
$\key{fork}$ to create a recursive channel of type $\gvdual{Ints}$:
\[
\bl
zeros : \gvdual{Ints} \\
zeros = \gvfork{c}{makeZeros\:c} \\
\el
\]

\todo{Oops! Only infinite programs can consume zeros, due to linearity.}


\paragraph{productivity}

We might expect to assign $c$ the type $\nu X.\gvout{Int}{X} = \gvout{Int}{(\nu X.\gvout{Int}{X})}$,
and $d$ the type $\nu X.\gvout{Int}{X}$, but then productivity would not be assured. For example,
under the same typing assumptions for $f$ and $c$ we could then write:
\[
\fix\:f\:c = f\:c
\]
%
We restrict the typing rule for $\fix$ in order to ensure productivity. We use a fresh type variable
$X$ to abstract the recursive behavior; the channel $c$ then has type $G(X)$ (in our example
$\gvout{Int}{X}$) instead of $G(\nu G)$ (in our example $\gvout{Int}{(\nu X.\gvout{Int}{X})}$), and
$f$ has type $X \uto \outterm$ instead of $\nu G \uto \outterm$. The body of $\lrkwd$ is thus
required to provide precisely one iteration of the recursive behavior.

\paragraph{coinvariants}

We allow recursive sessions to maintain internal state (a \emph{coinvariant}). In the typing rule,
this is captured by the additional arguments $\vec{x}$. For example, we can construct a stream of
consecutive naturals using the expression:
\[
  \gvfix{nats}{x\:c}{\gvlet{c}{\gvsend{x}{c}}{nats\:(x + 1)\:c}}
\]
The variable $x$ tracks the next value to send to the stream, and is accordingly incremented in the
recursive call. We can maintain coinvariants of arbitrary complexity; for example, we can define a
stream of the Fibonacci numbers as follows:
\[
  \gvfix{fibs}{m\:n\:c}{\gvlet{c}{\gvsend{m}{c}}{fibs\:n\:(m + n)\:c}}
\]

Having shown how to define recursive channels, we now how to use them. The following example returns
an input channel for reading the Fibonacci numbers.
\[
\bl
\key{let}\:fibs = (\gvfix{fibs}{m\:n\:c}{\gvlet{c}{\gvsend{m}{c}}{fibs\:n\:(m + n)\:c}})\:\key{in} \\
\gvfork{c}{fibs\:0\:1\:c} \\
\el
\]
The channel $c$ passed to $fibs$ implements the Fibonacci numbers as a stream of outputs of type
$\nu X.!Int.X$. The $\key{fork}$ construct returns the other end of that channel, whose type is $\mu
X.?Int.X$: in any given program we can request an arbitrary finite number of elements of the
Fibonacci sequence.

\subsection{Multi-function calculator}

Our next example is a simple multi-function calculator. For the purposes of this example, we will
assume that our term language has been extended by integer constants, along with addition ($+$) and
multiplication ($\times$) operators.  Our goal is to provide a session that accepts an arbitrary
stream of addition and multiplication requests, and can at any time provide the accumulated result.
We can implement the provider of this session as follows:

\newcommand{\mcl}[2]{\multicolumn{#1}{l}{#2}}

\[\begin{array}{llll}
 \mcl{4}{calc : \langle Int, Calc \rangle \uto \outterm} \\
 \mcl{4}{calc = \lrkwd\:calc\:accum\:c =} \\
 \quad & \mcl{3}{\mkwd{case}\:c\;\mkwd{of}\:\{} \\
 & \quad & \clabel{add}\:c. &\mkwd{let}\:(x,c) = \gvreceive{c} \: \mkwd{in} \\
 & & & calc\:(accum + x)\:c; \\
 & & \clabel{mul}\:c. &\mkwd{let}\:(x,c) = \gvreceive{c}\:\mkwd{in} \\
 & & & calc\:(accum \times x)\:c \\
 & & \clabel{result}\:c. &\mkwd{let}\:c = \gvsend{accum}{c}\:\mkwd{in} \\
 & & & calc\:accum\:c; \\
 & & \clabel{done}\:c.& c \; \}
\end{array}\]
In this case, the type of the recursive channel is
\[
 Calc = \nu X. \with \{ \clabel{add}: \gvin{Int}{X}, \clabel{mul}: \gvin{Int}{X}, \clabel{result}: \gvout{Int}{X}, \clabel{done}: \outterm \}.
\]%
Here is a consumer of the service:
\[\begin{array}{l}
  \gvlet{myCalc}{\gvfork{c}{calc\:0\:c}}{} \\
  \gvlet{d}{\gvsend{6}{(\gvselect{\clabel{add}}{myCalc})}}{} \\
  \gvlet{myCalc}{\gvsend{7}{(\gvselect{\clabel{mul}}{myCalc})}}{} \\
  \gvlet{(x,d)}{\gvreceive{(\gvselect{\clabel{result}}{myCalc})}}{} \\
  \gvlet{myCalc}{\gvselect{\clabel{done}}{myCalc}}{x}
\end{array}\]
We begin by constructing an instance of the calculator with the accumulator starting at 0; in the
body of \tkwd{fork}, $c$ has the $\nu$-type given above, so the result of \tkwd{fork} (called
$myCalc$), has type
\[
\mu X. \oplus \{ \clabel{add}: \gvout{Int}{X}, \clabel{mul}: \gvout{Int}{X}, \clabel{result}: \gvin{Int}{X}, \clabel{done}: \interm \}.
\]
We perform several calculations, adding 6 to the accumulator and multiplying by 7.  Finally, we get
the result and close the channel.

\subsection{Bit Strings}
%
%\todo{Validating the translation requires extending the GV interpreter with Booleans, addition and
%  multiplication.}

We now adapt an example due to Toninho et al.~\cite{Toninho13} to our setting. This example
represents a string of bits (0 or 1) by a chain of processes, each storing one bit. The chain
supports operations to increment and retrieve the stored value as an integer encoded by the bit
string. Each link in the chain functions as a one-bit adder.

As in the previous section, we assume constants for integers, along with addition and multiplication
operators. We also assume Boolean constants and an if-then-else construct.

We begin with the type $Link$ of the links in the chain. Each is a recursive process supporting
three operations: compute the integer value encoded by the chain, increment the chain, and dispose
of the chain.
%
%{\small\[\begin{array}{l@{\hspace{1mm}}l}
% NodeT = \nu X. \with \{ &\clabel{val}: \cpdual{Nat} \parr (Nat \otimes X), \\
% & \clabel{inc}: \oplus \{ \clabel{carry}: X, \clabel{done}: X \}, \\
% & \clabel{halt}: 1 \}.
%\end{array}\]}
\[
 Link = \nu X. \with \{ \clabel{val}: \gvin{Int}{\gvout{Int}{X}}, \clabel{inc}: \oplus \{ \clabel{carry}: X, \clabel{done}: X \}, \clabel{halt}: \outterm \}
\]
The val operation cascades down the chain (from most- to least-significant bit), returning the
computed value.  The increment operator cascades similarly, but returns the carry bit.

The simplest node is the terminator $Epsilon$: it adds nothing to the value of the string, and
cannot store a value so it must respond to increment requests with carry.
%
%{\small\[\begin{array}{rcll}
%  Epsilon_x & = & \mcl{2}{\lrkwd\:x\langle y \rangle ( y[].0,} \\
%  & & \quad \mkwd{case}\:x\: \{ &\clabel{val}: x(n).x[n].\link{y}{x}; \\
%  & & &\clabel{inc}:\sel{x}{carry}.\link{y}{x}; \\
%  & & &\clabel{halt}: \link{y}{x} \}).
%\end{array}\]}
%
\[
\bl
Epsilon : Link \to \outterm \\
Epsilon = \lrkwd\:Epsilon\:c = \\
\quad \mkwd{case}\:c\:\mkwd{of}\:\{
  \bl
  \clabel{val}\:c.
    \bl
    \gvlet{(n,c)}{\gvreceive{c}}{} \\
    \gvlet{c}{\gvsend{n}{c}}{} \\
    Epsilon\:c \\
    \el \\
  \clabel{inc}\:c.
    \bl
    \gvlet{c}{\gvselect{\clabel{carry}}{c}}{} \\
    Epsilon\:c \\
    \el \\
  \clabel{halt}\:c. c\}  \\
  \el \\
\el
\]

%To give internal nodes in the string, we need some representation of the bit each stores.  Let's use
%Booleans!
%
%{\small\begin{align*}
%Bool &= \oplus \{ \clabel{t}:1, \clabel{f}:1 \}. \\
%True_x &= \sel{x}{t}.x[].0. \\
%False_x &= \sel{x}{f}.x[].0.
%\end{align*}}
%
%As for numeric operations, I'll write $x[True].P$ for $x[b].(True_b \mid P)$.
We can now define internal nodes. In response to a value request, it adds its value to the value
accululated so far, and passes the result to the next node in the chain; the response is passed up
the chain unchanged. In response to an increment request, the bit flips, passing on a carry option
if needed. Internal nodes require two state components: the represented bit ($b$)
and the remainder of the chain ($d$).
%
%{\small\[\begin{array}{rcllll}
%  Node_{i,y,n} & = & \mcl{4}{\lrkwd\:n \langle x \rangle (x[j].(\link{j}{i} \mid \link{x}{y}),} \\
%  & & \quad x(b).\mkwd{case}\:n\: \{ &\mcl{3}{\clabel{val}: \rec{x}.\sel{x}{val}.n(m).} \\
%  & & & \quad \mkwd{case}\:b\: \{ &\mcl{2}{\clabel{t}: b().x[2m + 1].x(m).} \\
%  & & & & \mcl{2}{\quad n[m].n[True].\link{x}{n};} \\
%  & & & & \mcl{2}{\clabelx{f}: b().x[2m].x(m).} \\
%  & & & & \mcl{2}{\quad n[m].n[False].\link{x}{n} \};} \\
%  & & & \mcl{3}{\clabel{inc}: \rec{x}.\sel{x}{inc}.} \\
%  & & & \quad \mkwd{case}\:x\:\{ &\mcl{2}{\clabel{done}: \sel{n}{done}.n[b].\link{x}{n}} \\
%  & & & &\clabel{carry}: \mkwd{case}\:b\: \{ &\clabel{t}: b().\sel{n}{carry}.n[False].\link{x}{n} \\
%  & & & & &\clabel{f}: b().\sel{n}{done}.n[True].\link{x}{n} \} \}; \\
%  & & &\clabel{halt}: \\
%  & & &\quad \mkwd{case}\:b\:\{ &\mcl{2}{\clabel{t}: b().\rec{x}.\sel{x}{halt}.x().n[].0;} \\
%  & & & &\mcl{2}{\clabel{f}: b().\rec{x}.\sel{x}{halt}.x().n[].0 \} \})}.
%\end{array}\]}
%
\newcommand{\gvifthen}[3]{\mkwd{if}\:#1\:\mkwd{then}\:#2\:\mkwd{else}\:#3}
%
\[\begin{array}{lllll}
\mcl{5}{Node : \langle Bool, \gvdual{Link}, Link \rangle \uto \outterm} \\
\mcl{5}{Node = \lrkwd\:Node\:b\:d\:c =} \\
\mcl{5}{\quad \mkwd{case}\:c\:\mkwd{of}\:\{} \\
\quad \quad & \clabel{val}\:c. & \mcl{3}{\gvlet{(m,c)}{\gvreceive{c}}{}} \\
& & \mcl{3}{\gvlet{d}{\gvsend{(\gvifthen{b}{2 \times m + 1}{2 \times m})}{(\gvselect{\clabel{val}}{d})}}{}} \\
& & \mcl{3}{\gvlet{(n,d)}{\gvreceive{d}}{}} \\
& & \mcl{3}{\gvlet{c}{\gvsend{n}{c}}{}} \\
& & \mcl{3}{Node\:b\:d\:c;} \\
& \clabel{inc}\:c. & \mcl{3}{\mkwd{case}\:(\gvselect{\clabel{inc}}{d})\:\mkwd{of}\:\{} \\
& & \quad & \clabel{done}\:d. & Node\:b\:d\:(\gvselect{\clabel{done}}{c}) \\
& & & \clabel{carry}\:d. & \gvlet{c}{\gvifthen{b}{\gvselect{\clabel{carry}}{c}}{\gvselect{\clabel{done}}{c}}}{} \\
& & & & Node\:(not\:b)\:d\:c \}; \\
& \clabel{halt}\:c. & \mcl{3}{\gvlet{d}{\gvselect{\clabel{halt}}{d}}{c} \}}
\end{array}\]
%% SL: unnecessary - typing rule for fix is always like this
%%
%% (The arrows are linear as $Node$ values are linear, and so closures that capture them must be as
%% well.)

Finally, we can define the top level interface to a bit string.  The interface supports the same
three operations as the links---increment, retrieve value, and disposal---but with simpler behavior:
\[
  Count = \nu X. \with \{ \clabel{val}: \gvout{Int}{X}, \clabel{inc}: X, \clabel{halt}: \outterm \}
\]
Value retrieval outputs the value of the string, increment increases the stored value by one, and
halting closes the channel. The implementation requires one state component, the first link of the
chain (called $d$).
\[\begin{array}{llll}
\mcl{4}{CounterImpl : \langle \gvdual{Link}, Count \rangle \uto \outterm} \\
\mcl{4}{CounterImpl = \lrkwd\:CounterImpl\:d\:c =} \\
\mcl{4}{\quad \mkwd{case}\:c\:\mkwd{of}\:\{} \\
\quad \quad & \clabel{val}\:c. & \mcl{2}{\gvlet{(n,d)}{\gvreceive{(\gvsend{0}{(\gvselect{\clabel{val}}{d})})}}} \\
& & \mcl{2}{CounterImpl\:d\:(\gvsend{n}{c})} \\
& \clabel{inc}\:c. & \mcl{2}{\mkwd{case}\:\gvselect{\clabel{inc}}{d}\:\mkwd{of}\:\{} \\
& & \quad \clabel{carry}\:d. & \gvlet{e}{\gvfork{e}{Node\:True\:d\:e}}{} \\
& & & CounterImpl\:e\:c; \\
& & \quad \clabel{done}\:d. & CounterImpl\:d\:c\:\}; \\
& \clabel{halt}\:c. & \mcl{2}{\gvlet{d}{\gvselect{\clabel{halt}}{d}}{c}\:\}}
\end{array}\]
The value case uses the value behavior of the links, providing the initial value 0.  The increment
option adds a new link to the chain if incrementing the existing chain requires
carrying. $CounterImpl$ takes an initial chain as an argument. For a counter, we initialise this to
the empty chain encoding $0$:
\[\bl
  Counter : Count \uto \outterm \\
  Counter = \lambda c.CounterImpl\:(\gvfork{x}{Epsilon\:x})\:c. \\
\el\]
%
%{\small\[
% CounterT = \nu X. \with \{ \clabel{val}: Nat \otimes X, \clabel{inc}:X, \clabel{halt}:1 \}.
%\]}
%
%{\small\[\begin{array}{rclll}
%  Counter_z & = & \mcl{3}{\lrkwd\:z \langle x \rangle (Epsilon_x,} \\
%  & & \quad \mkwd{case}\:z\:\{ &\mcl{2}{\clabel{val}: \rec{x}.\sel{x}{val}.x[Zero].x(n).z[n].\link{z}{x};} \\
%  & & &  \mcl{2}{\clabel{inc}: \rec{x}.\sel{x}{inc}.} \\
%  & & & \quad \mkwd{case}\:x\:\{ &\clabel{carry}: \cut{n}{CImp}{\cut{i}{Bool}{True_i}{Node_{i,x,n}}}{\link{z}{n}}; \\
%  & & & &\clabel{done}: \link{z}{x} \} \\
%  & & &\mcl{2}{\clabel{halt}:\rec{x}.\sel{x}{halt}.x().z[].0 \}).}
%\end{array}\]}
Here is a simple example of using the counter:
\[\begin{array}{l}
\gvlet{ctr}{\gvfork{c}{Counter\:c}}{} \\
\gvlet{(i,ctr)}{\gvreceive{(\gvselect{\clabel{val}}{ctr})}}{} \\
\gvlet{(j,ctr)}{\gvreceive{(\gvselect{\clabel{val}}{(\gvselect{\clabel{inc}}{ctr})})}}{} \\
\gvlet{(k,ctr)}{\gvreceive{(\gvselect{\clabel{val}}{(\gvselect{\clabel{inc}}{(\gvselect{\clabel{inc}}{ctr})})})}}{} \\
\gvlet{ctr}{\gvselect{\clabel{halt}}{ctr}}{(i,j,k)}
\end{array}\]
We begin by creating a new counter on channel $ctr$; we then perform a mixture of increment and
value operations before closing the $ctr$ channel.  The whole expression evaluates to $(0,1,3)$.


\section{\mucp Syntax and Semantics}\label{sec:mucp}

\subsection{Types and Terms}

\todo{
\begin{itemize}
\item There are a couple of changes from previous presentations of CP.  First, I've changed the
  scoping operator from $\nu$ to \tkwd{new} to avoid confusion with fixed points.  Second, I've
  attempted to make $.$ mean sequencing, as it does in $\pi$-calculus; this meant changing the
  syntax of \tkwd{new} and \tkwd{case} to eliminate extra $.$'s.
\item I'm unsure on whether to prefer a minimal presentation, to simplify the later technical
  development, or a full presentation, to make it look most like a complete language.  For example,
  as it is, I've left out second-order quantification; this isn't because there's any particular
  problem with it, but because I haven't used it in any of the examples and it doesn't interact
  surprisingly with any of the new features.  Some places the paper is schizophrenic: the syntax and
  cut rules use binary sums, but the examples assume $n$-ary sums.
\end{itemize}\vspace{-2mm}}

The types of \mugv are the propositions of CLL, extended with type operators $F$ and fixed points
$\mu F,\nu F$.
\[\begin{array}{l@{\hspace{2mm}}r@{\hspace{2mm}}c@{\hspace{2mm}}l}
  \text{Types} & A,B & ::= & A \otimes B \mid A \parr B \mid \bot \mid 1 \mid A \oplus B \mid A \with B \mid 0 \mid \top \\
   & & \mid & \cpbang{A} \mid \cpquery{A} \mid X \mid \cpdual{X} \mid \mu F \mid \nu F \\
   \text{Type operators} & F & ::= & X.A %\\
%  \text{Terms} & P,Q & ::= & \link{x}{y} \mid x(y).P \mid x[y].(P \mid Q) \mid x().P \mid x[].0 \\
%   & & \mid & \sel{x}{inl}.P \mid \sel{x}{inr}.Q \mid \case{x}{P;Q} \mid \case{x}{} \\
%   & & \mid & \cut{x}{A}{P}{Q} \mid \replicate{x}{y}{P} \mid \derelict{x}{y}{P} \\
%   & & \mid & \rec{x}.P \mid \corec{x}{y}{A}{P}{Q}
\end{array}\]
If $F = X.A$, define $F(B) = A[B/X]$.  The standard notion of CLL duality is extended to fixed points in the expected fashion:
points:
\begin{align*}
  \cpdual{(A \otimes B)} &= \cpdual{A} \parr \cpdual{B} & \cpdual{1} &= \bot &
    \cpdual{(A \oplus B)} &= \cpdual{A} \with \cpdual{B} & \cpdual{\top} &= 0 \\
  \cpdual{(A \parr B)} &= \cpdual{A} \otimes \cpdual{B} & \cpdual{\bot} &= 1 &
    \cpdual{(A \with B)} &= \cpdual{A} \oplus \cpdual{B} & \cpdual{0} &= \top \\
  \cpdual{(\cpbang{A})} &= \cpquery{\cpdual{A}} & \cpdual{(\cpquery{A})} &= \cpbang{\cpdual{A}} &
     \cpdual{(\nu F)} &= \mu \cpdual{F} & \cpdual{(\mu F)} &= \nu \cpdual{F}
\end{align*}
where $X^{\perp\perp}  = X$, and we define the dual of a type operator by $\cpdual{F} =
X.\cpdual{(F(\cpdual{X}))}.$ Note that, as for type operators in \mugv, $\cpdual{F(A)} =
\cpdual{F}(\cpdual{A})$.

\begin{figure}
\begin{mathpar}
\inferrule{ }{\cptyp{\link{x}{y}}{x:A,y:\cpdual{A}}}

\inferrule{\cptyp{P}{\Gamma}\\un(A)}{\cptyp{P}{x:A,\Gamma}}

\inferrule{\cptyp{P}{x:A,x':A,\Gamma\\un(A)}}{\cptyp{P[x/x']}{x:A,\Gamma}}

\inferrule{\cptyp{P}{y:A,\Gamma} \\
           \cptyp{Q}{x:B,\Delta}}
          {\cptyp{x[y].(P \mid Q)}{x:A \otimes B,\Gamma,\Delta}}

\inferrule{\cptyp{P}{y:A,x:B,\Gamma}}
          {\cptyp{x(y).P}{x:A \parr B,\Gamma}}

\inferrule{ }{\cptyp{x[].0}{x:1}}

\inferrule{\cptyp{P}{\Gamma}}
          {\cptyp{x().P}{x:\bot,\Gamma}}

\inferrule{\cptyp{P}{x:A,\Gamma}}
          {\cptyp{\sel{x}{inl}.P}{x:A \oplus B,\Gamma}}

\inferrule{\cptyp{P}{x:A,\Gamma} \\
           \cptyp{Q}{x:B,\Gamma}}
          {\cptyp{\case{x}{P;Q}}{x:A \with B,\Gamma}}

\inferrule{ }{\cptyp{\case{x}{}}{x:\top,\Gamma}}

\inferrule{\cptyp{P}{y:A,\Gamma}}{\cptyp{\derelict{x}{y}{P}}{x:\cpquery{A},\Gamma}}

\inferrule{\cptyp{P}{y:A,\cpquery{\Gamma}}}{\cptyp{\replicate{x}{y}{P}}{x:\cpbang{A}, \Gamma}}

\inferrule{\cptyp{P}{\Gamma,x:A} \\
           \cptyp{Q}{x:\cpdual{A},\Delta}}
          {\cptyp{\cut{x}{A}{P}{Q}}{\Gamma,\Delta}}

\inferrule{\cptyp{P}{x:F(\mu F), \Gamma}}
          {\cptyp{\rec{x}.P}{x:\mu F,\Gamma}}

\inferrule{\cptyp{P}{y:A,\Gamma} \\
           \cptyp{Q}{y:\cpdual{A},x:F(A)}}
          {\cptyp{\corec{x}{y}{A}{P}{Q}}{x:\nu F,\Gamma}}
\end{mathpar}
\todo{Server and client output look like sequencing... Shouldn't they have a dot?}
\caption{Terms and typing rules of \mucp}\label{fig:cp-typing}
\end{figure}


\paragraph{Structural rules.}

This seems like an odd section.  However, it does serve as a place to introduce the equivalences,
which I'd forgotten otherwise.

\begin{figure}\small
\begin{align*}
  \cut{x}{A}{P}{\link{x}{y}} &\equiv P[y/x] \\
  \cut{x}{A}{P}{Q} &\equiv \cut{x}{\cpdual{A}}{Q}{P} \\
  \cut{x}{A}{P}{\cut{y}{B}{Q}{R}} &\equiv \cut{y}{B}{Q}{\cut{x}{A}{P}{R}} &&\text{if $x \not\in fn(Q)$}
\end{align*}
\caption{Structural equivalences}\label{fig:equivalences}
\end{figure}

\paragraph{Input and Output}

Binary...

And nullary...

{\small}

\paragraph{Selection and Choice}

No term to prove 0.

\paragraph{Recursion and Corecursion}

We introduce least fixed points $\mu F$ and greatest fixed points $\mu F$ to CP, following Baelde's
proof theoretic treatment of fixed points in linear logic~\cite{Baelde12}.  The proof rules can be
understood from traditional two-sided rules for least and greated fixed points, combined with the
duality between the fixed points.  We begin with a two-sided presentation:
\begin{mathpar}
\inferrule{F(A) \vdash A \\ \Gamma, A \vdash B}{\Gamma, \mu F \vdash B}

\inferrule{\Gamma \vdash F (\mu F)}{\Gamma \vdash \mu F}

\inferrule{\Gamma, F (\nu F) \vdash B}{\Gamma, \nu F \vdash B}

\inferrule{A \vdash F(A) \\ \Gamma \vdash A}{\Gamma \vdash \nu F}
\end{mathpar}
Functional programmers should recognize the first as the typing rule of a fold, and the fourth as
the typing rule of an unfold.  We can translate this to a one sided presentation, as follows.  (As
$\Gamma$ denotes any context, we will write $\Gamma$ instead of $\cpdual{\Gamma}$).
\begin{mathpar}
\inferrule{\vdash \cpdual{F}(\cpdual{A}),A \\ \vdash \Gamma,\cpdual{A},B}{\vdash \Gamma,\nu \cpdual{F},B}

\inferrule{\vdash \Gamma, F (\mu F)}{\vdash \Gamma, \mu F}
\\
\inferrule{\vdash \Gamma, \cpdual{F}(\mu \cpdual{F}), B}{\vdash \Gamma, \mu \cpdual{F}, B}

\inferrule{\vdash \cpdual{A}, F(A) \\ \vdash \Gamma, A}{\vdash \Gamma, \nu F}
\end{mathpar}
However, now we can observe that $\Gamma,B$ is itself an instance of a context, and $\cpdual{F}$ a
type operator, and so the four rules above are just two instances each of the two rules below.
\begin{mathpar}
\inferrule{\vdash \Gamma, F (\mu F)}{\vdash \Gamma, \mu F}

\inferrule{\vdash \cpdual{A}, F(A) \\ \vdash \Gamma, A}{\vdash \Gamma, \nu F}
\end{mathpar}
And these are the typing rules for the \mucp terms $\rec{x}.P$ and $\corec{x}{y}{}{P}{Q}$.

\subsection{Cut Elimination}

\begin{figure}\small
\begin{multline*}
\inferrule
  {\inferrule*
     {\cptyp{P}{y:A,\Gamma} \\
      \cptyp{Q}{x:B,\Gamma'}}
     {\cptyp{x[y].(P \mid Q)}{x: A \otimes B,\Gamma,\Gamma'}} \\
   \inferrule*
     {\cptyp{R}{x:\cpdual{B},y:\cpdual{A},\Delta}}
     {\cptyp{x(y).R}{x:\cpdual{A} \parr \cpdual{B},\Delta}}}
  {\cptyp{\cut{x}{A \otimes B}{x[y].(P \mid Q)}{x(y).R}}{\Gamma,\Gamma',\Delta}}
\Longrightarrow \\
\inferrule
  {\cptyp{Q}{y:A,\Gamma} \\
   \inferrule*
     {\cptyp{P}{x:B,\Gamma'} \\
      \cptyp{R}{x:\cpdual{B},y:\cpdual{A},\Delta}}
     {{\cptyp{\cut{x}{B}{P}{R}}{y:\cpdual{A},\Gamma',\Delta}}}}
  {\cptyp{\cut{y}{A}{Q}{\cut{x}{B}{P}{R}}}{\Gamma,\Gamma',\Delta}}
\end{multline*}
\[
\inferrule
  {\inferrule*
     { }{\cptyp{x[].0}{x:1}} \\
   \inferrule*
     {\cptyp{P}{\Gamma}}
     {\cptyp{x().P}{x:\bot,\Gamma}}}
  {\cptyp{\cut{x}{1}{x[].0}{x().P}}{\Gamma}}
\Longrightarrow
\cptyp{P}{\Gamma}
\]
\begin{multline*}
\inferrule
  {\inferrule*
     {\cptyp{P}{x:A,\Gamma}}
     {\cptyp{\sel{x}{inl}.P}{x:A \oplus B, \Gamma}} \\
   \inferrule*
     {\cptyp{Q}{x:\cpdual{A},\Delta} \\
      \cptyp{R}{x:\cpdual{B},\Delta}}
     {\cptyp{\case{x}{Q;R}}{x:\cpdual{A} \with \cpdual{B},\Delta}}}
  {\cptyp{\cut{x}{A \oplus B}{\sel{x}{inl}.P}{\case{x}{Q;R}}}{\Gamma,\Delta}}
\Longrightarrow \\
\inferrule
  {\cptyp{P}{x:A,\Gamma} \\
   \cptyp{Q}{x:\cpdual{A},\Delta}}
  {\cptyp{\cut{x}{A}{P}{Q}}{\Gamma,\Delta}}
\end{multline*}

\[
\inferrule
  {\inferrule*
     {\cptyp{P}{y:A,\cpquery{\Gamma}}}
     {\cptyp{\replicate{x}{y}.P}{x:\cpbang{A},\Gamma}} \\
   \inferrule*
     {\cptyp{Q}{y:\cpdual{A},\Delta}}
     {\cptyp{\derelict{x}{y}.Q}{x:\cpquery{\cpdual{A}},\Delta}}}
  {\cptyp{\cut{x}{\cpbang{A}}{\replicate{x}{y}{P}}{\derelict{x}{y}{Q}}}{\Gamma,\Delta}}
\Longrightarrow
\inferrule
  {\cptyp{P}{x:A,\Gamma} \\
   \cptyp{Q}{y:\cpdual{A},\Delta}}
  {\cptyp{\cut{y}{A}{P}{Q}}{\Gamma,\Delta}}
\]

\[
\inferrule
  {\inferrule*
     {\cptyp{P}{y:A,?\Gamma}}
     {\cptyp{\replicate{x}{y}.P}{x:\cpbang{A},\Gamma}} \\
   \inferrule*
     {\cptyp{Q}{\Delta} \\ un(\cpquery{\cpdual{A}})}
     {\cptyp{Q}{y:\cpquery{\cpdual{A}}}}}
  {\cptyp{\cut{y}{\cpbang{A}}{\replicate{x}{y}.P}{Q}}{\Gamma,\Delta}}
\Longrightarrow
\inferrule
  {\cptyp{Q}{\Delta}}
  {\cptyp{Q}{\Gamma,\Delta}}
\]

\begin{multline*}
\inferrule
  {\inferrule*
     {\cptyp{P}{y:A,\cpquery{\Gamma}}}
     {\cptyp{\replicate{x}{y}.P}{x:\cpbang{A},\Gamma}} \\
   \inferrule*
     {\cptyp{Q}{x:\cpquery{\cpdual{A}},x':\cpquery{\cpdual{A}},\Delta}}
     {\cptyp{Q[x/x']}{x:\cpquery{\cpdual{A}},\Delta}}}
  {\cptyp{\cut{x}{\cpbang{A}}{\replicate{x}{y}.P}{Q[x/x']}}{\Gamma,\Delta}}
\Longrightarrow \\
\inferrule
  {\inferrule*
     {\cptyp{P}{y:A,\cpquery{\Gamma}}}
     {\cptyp{\replicate{x}{y}.P}{x:\cpbang{A},\Gamma}} \\
   \inferrule*
     {\inferrule*
         {\cptyp{P}{y:A,\cpquery{\Gamma}}}
         {\cptyp{\replicate{x'}{y}.P}{x':\cpbang{A},\Gamma}} \\
      \cptyp{Q}{x:\cpquery{\cpdual{A}},x':\cpquery{\cpdual{A}},\Delta}}
     {\cptyp{\cut{x'}{\cpbang{A}}{\replicate{x'}{y}.P}{Q}}{\Gamma,\Delta}}}
  {\cptyp{\cut{x}{\cpbang{A}}{\replicate{x}{y}.P}{\cut{x'}{\cpbang{A}}{\replicate{x'}{y}.P}{Q}}}{\Gamma,\Delta}}
\end{multline*}

%% \todo{\begin{itemize}
%%   \item Can we fix inference lines extending to the edge of the page?
%%   \item Requires more page width than we have.
%% \end{itemize}
%% We could fix both of these problems by not including the derivations...}

\[
\bl
\inferrule
  {\inferrule*
     {\cptyp{P}{y:B,\Gamma} \\
      \cptyp{Q}{y:\cpdual{B},x:F(B)}}
     {\cptyp{\corec{x}{y}{B}{P}{Q}}{x:\nu F,\Gamma}} \\
   \inferrule*
     {\cptyp{R}{x:\cpdual{F}(\mu (\cpdual{F})),\Delta}}
     {\cptyp{\rec{x}.R}{x:\mu (\cpdual{F}),\Delta}}}
  {\cptyp{\cut{x}{\nu F}{\corec{x}{y}{B}{P}{Q}}{\rec{x}.R}}{\Gamma,\Delta}}
\Longrightarrow \\
\inferrule
  {\cptyp{P}{y:B,\Gamma} \\
   \inferrule*
     {\cptyp{Q}{y:\cpdual{B},x:F(B)} \\
      \inferrule*
        {\cptyp{E}{x:\cpdual{F}(\cpdual{B}),z:F(\nu F)} \\
         \cptyp{R[z/x]}{z:\cpdual{F}(\mu \cpdual{F}),\Delta}}
        {\cptyp{\cut{z}{F(\nu F)}{E}{R[z/x]}}{x:\cpdual{F}(\cpdual{B}),\Delta}}}
     {\cptyp{\cut{x}{F(B)}{Q}{\cut{z}{F(\nu F)}{E}{R[z/x]}}}{y:\cpdual{B},\Delta}}}
  {\cptyp{\cut{y}{B}{P}{\cut{x}{F(B)}{Q}{\cut{z}{F(\nu F)}{E}{R[z/x]}}}}{\Gamma,\Delta}}
\el
\]
where $E = \map{F}{z,x}{\corec{z}{y}{B}{\link{x}{y}}{Q[z/x]}}$.

\caption{Principal cut elimination rules}\label{fig:beta-reduction}
\end{figure}

\begin{figure}\small
\begin{align*}
  \map{X.C}{x,w}{Q} &= \link{x}{w} \\
  \map{X.X}{x,w}{Q} &= Q \\
  \map{X.C_1 \otimes C_2}{x,w}{Q} &= w(z).x[y].(\map{X.C_1}{y,z}{Q[y/x,z/w]} \mid \map{X.C_2}{x,w}{Q}) \\
  \map{X.C_1 \oplus C_2}{x,w}{Q} &= \case{w}{\sel{x}{inl}.\map{X.C_1}{x,w}{Q}; \sel{x}{inr}.\map{X.C_2}{x,w}{Q}} \\
  \map{X.\cpquery{C}}{x,w}{Q} &= \replicate{w}{w'}.\derelict{x}{x'}.Q[x'/x,w'/x] \\
  \map{X.\mu F'}{x,w}{Q} &= \corec{w}{y}{\nu(\cpdual{C}(A))}{\link{x}{y}}{\rec{y}.\map{X.F' (\mu F')}{y,w}{Q[y/x]}}
\end{align*}
\caption{Definition of $\mapname$ for positive combinators.}\label{fig:map}
\end{figure}

Principal cut reductions are given in Fig.~\ref{fig:beta-reduction}. Cut reduction for fixed points
corresponds to one step of unrolling, and depends on a auxiliary function $\mapname$. The positive
cases of $\mapname$ are given in Fig.~\ref{fig:map}; the remaining cases can be obtained by
exchanging channels $x$ and $w$.

\begin{lemma}
  If $\cptyp{Q}{x:A,w:B}$ then \(\cptyp{\map{F}{x,w}{Q}}{x:F(A), w:\cpdual{F}(B)}.\)
\end{lemma}

\begin{figure}\small
\begin{align*}
  \cut{x}{A}{z(y).P}{Q} &\Longrightarrow z(y).\cut{x}{A}{P}{Q} \\
  \cut{x}{A}{z[y].(P \mid Q)}{R} &\Longrightarrow z[y].(\cut{x}{A}{P}{R} \mid Q) &&\text{if $x \not\in fn(Q)$} \\
  \cut{x}{A}{z[y].(P \mid Q)}{R} &\Longrightarrow z[y].(P \mid \cut{x}{A}{Q}{R}) &&\text{if $x \not\in fn(P)$} \\
  \cut{x}{A}{\sel{z}{inl}.P}{Q} &\Longrightarrow \sel{z}{inl}.\cut{x}{A}{P}{Q} \\
  \cut{x}{A}{\case{z}{P;Q}}{R} &\Longrightarrow \case{z}{\cut{x}{A}{P}{R}; \cut{x}{A}{Q}{R}} \\
  \cut{x}{A}{\rec{z}.P}{Q} &\Longrightarrow \rec{z}.\cut{x}{A}{P}{Q} \\
  \cut{x}{A}{\corec{z}{y}{B}{P}{Q}}{R} &\Longrightarrow \corec{z}{y}{B}{\cut{x}{A}{P}{R}}{Q}
\end{align*}
\caption{Commuting conversions}\label{fig:commuting}
\end{figure}

Commuting conversions are given in Fig.~\ref{fig:commuting}, and are unsurprising.

\begin{theorem}
  If $\cptyp{P}{\Gamma}$ and $P \Longrightarrow Q$, then $\cptyp{Q}{\Gamma}.$
\end{theorem}

Define $\Longrightarrow^\star$ to be the reflexive, transitive closure of $\equiv\Longrightarrow\equiv$.

\begin{theorem}
  If $\cptyp{P}{\Gamma}$, then there is a $Q$ such that $P \Longrightarrow^\star Q$ and the bottom
  rule of $Q$ is not a cut.
\end{theorem}

\subsection{Peano Numerals}

As an alternative to the Church encodings in the previous section, we could use recursive types
directly to express Peano encodings of the naturals.  The type is natural:
%
{\small\[
  Peano = \mu X.\oplus\{zero: 1, succ: X\}.
\]}
%
The representation of values is more natural in this encoding, however.  For example, we have 0 and
increment encoded as follows:
%
{\small\begin{align*}
  Zero_x &= \rec{x}.\sel{x}{zero}.x[].0 \\
  Inc_{x,y} &= \rec{y}.\sel{y}{succ}.\link{x}{y}
\end{align*}}
Again, we can show that increment behaves as we expect; for example, we have that
%
{\small\[
  \cut{x}{Peano}{Zero_x}{Inc_{x,y}} \Longrightarrow^\star \rec{y}.\sel{y}{succ}.\rec{y}.\sel{y}{zero}.y[].0.
\]}

{\small\[\begin{array}{rcl@{\hspace{0mm}}ll}
  Add_{x,y,z} & = & \mcl{3}{\mkwd{corec}\:x\langle a \rangle} \\
  & & \quad (&\mcl{2}{a[y].\link{a}{z},} \\
  & & & a(b).\mkwd{case}\:x\:\{&\clabel{zero}: x().\link{a}{b}; \\
  & & & & \clabel{succ}: x[b'].(Inc_{b,b'} \mid  \link{a}{x}) \}).
\end{array}\]}
We can show that $\cptyp{Add_{x,y,z}}{x:\cpdual{Peano}, y:\cpdual{Peano}, z:Peano}$ and, for instance,
that
%
{\small\[
  \cut{x}{Peano}{One_x}{\cut{y}{Peano}{One_y}{Add_{x,y,z}}} \Longrightarrow^\star Two_z.
\]}

\subsection{Streams}

As in our discussion of the $\lrkwd$ form in \mugv~\secref{mugv-syntax}, we can use \mucp fixed
points to encode streams.  The encoding of the stream type is quite intuitive:
\begin{align*}
  Sink(A) &= \mu X. \oplus \{ \clabel{end}: \bot, \clabel{more}: A \parr X \}, \\
  Source(A) &= \nu X. \with \{ \clabel{end}: 1, \clabel{more}: A \otimes X \}.
\end{align*}
Note that, following the typical treatment of duality in linear logic, we have that
$\cpdual{(Source(A))} = Sink(\cpdual{A})$.

We can define several streams, building on our previous encoding of Peano numerals in \mucp.  we
begin with a stream of zeros:
\[
  Zeros_y =\ \corec{y}{z}{1}{z[].0}{z().\case{y}{\clabel{end}: y[].0; \clabel{more}: y[x].(Zero_x | y[].0)}}.
\]
We have no need for the coinvariant in this definition, so we use the trivial coinvariant 1.  Next,
we describe the stream of naturals $0,1,2,\dots$.  As in \mugv, we will rely on the coinvariant to
track the next number to send to the channel.  However, unlike in \mugv, $Peano$ is a linear
proposition.  To account for this, we begin by demonstrating that we can duplicate and discard
proofs of $Peano$:
\[\begin{array}{lll}
  \multicolumn{3}{l}{Copy_{x,z} = \lrkwd\:x\langle y \rangle ( \link{y}{z},} \\
  \quad \quad & \mkwd{case}\:x\:\{\:&\clabel{zero}: x().y[y'].(Zero_{y'} \mid Zero_{y}) \\
  & & \clabel{succ}: x(x').y[y'].(Inc_{x',y'} \mid Inc_{x,y}) \}) \\
  \multicolumn{3}{l}{Drop_{x,z} = \lrkwd\:x \langle y \rangle (\link{y}{z},} \\
  \quad \quad & \mkwd{case}\:x\:\{\:&\clabel{zero}: \link{x}{y} \\
  & & \clabel{succ}: \link{x}{y} \})
\end{array}\]
We have that $\cptyp{Copy_{x,z}}{x:\cpdual{Peano}, z:Peano \otimes Peano}$ and that
$\cptyp{Drop_{x,z}}{x:\cpdual{Peano},z:1}$. Finally, we can demonstrate the stream of naturals:
\[\begin{array}{r@{\hspace{2mm}}c@{\hspace{2mm}}l@{\hspace{0mm}}l@{\:}l}
  CNats_y & = & \mcl{3}{\lrkwd \: y \langle z \rangle (Zero_z,} \\
  & & \quad & \mkwd{case}\:y \{ & \clabel{end}: \cut{a}{}{Drop_{z,a}}{a().y[].0}; \\
  & & & & \clabel{more}: \mkwd{new}\:w\:(Copy_{z,w} \mid \\
  & & & & \quad w(z).y[x].(\link{x}{z} \mid \cut{v}{}{Inc_{w,v}}{\link{y}{v}}))\})
\end{array}\]
In the $\clabel{more}$ case, we begin by copying the coinvariant numeral $z$ as $z$ and $w$.  We
then send $z$ along the channel $y$, increment $w$ giving $v$, and re-establish the coinvariant
using $v$.  As we expect, we have that $\cptyp{CNats_y}{y:Stream(Nat)}$.

\section{Relating \mugv and \mucp}\label{sec:translation}

\subsection{Translation from \mugv to \gvpi}\label{sec:gvtogvpi}

Following our previous work~\cite{LindleyM14} we factor the
translation of \mugv into \mucp through an intermediate
translation. The language \gvpi is the restriction of \mugv to session
types, that is, \mugv without $\lto$, $\uto$, or $\otimes$. In order
to avoid $\otimes$, we disallow plain $\gvreceive{M}$, but do permit
it to be fused with a pair elimination $\gvlet{(x,
  y)}{\gvreceive{M}}{N}$. We can simulate all non-session types as
session types via a translation from \mugv to \gvpi.  The translation
on types is exactly as in our previous work. It is given by the
homomorphic extension of the following equations:
%\[
%\ba{@{}rclcl@{}}
%\topi{T \lto U}    &=& \gvdual{\gvin{\gvdual{\topi{T}}}{\topi{U}}}
%                   &=& \gvout{\topi{T}}{\gvdual{\topi{U}}} \\
%\topi{T \uto U}    &=& \gvdual{\gvserver{(\gvin{\topi{\gvdual{T}}}{\topi{U}})}}
%                   &=& \gvservice{(\gvout{\topi{T}}{\gvdual{\topi{U}}})} \\
%\topi{T \otimes U} &=& \gvdual{\gvout{\gvdual{T}}{\topi{U}}}
%                   &=& \gvin{\gvdual{\topi{T}}}{\gvdual{\topi{U}}} \\
%\ea
%\]
\begin{align*}
\topi{T \lto U} &= \gvout{\topi{T}}{\topi{U}} \\
\topi{T \uto U} &= \gvservice{(\gvout{\topi{T}}{\topi{U}})} \\
\topi{T \otimes U} &= \gvin{\topi{T}}{\topi{U}}
\end{align*}
Each target type is the interface to the simulated source type. A
linear function is simulated by input on a channel; its interface is
output on the other end of the channel. An unlimited function is
simulated by a server; its interface is the service on the other end
of that channel. A tensor is simulated by output on a channel; its
interface is input on the other end of that channel. This duality
between implementation and interface explains the flipping of types in
Wadler's original CPS translation from GV to CP.

In order to translate away the arrows in the $\key{corec}$ rule, we
adopt a simplified session-oriented variant of the $\key{corec}$ rule
for \gvpi.
%
\begin{mathpar}
\inferrule{\gvtyp{x:T,p:\gvservice{(\gvout{T}{\gvout{X}{\outterm}})}, c:G(X)}{M}{\outterm}}
          {\gvtyp{\Phi}{\gvfix{p}{x\,c}{M}}{\gvservice{(\gvout{T}{\gvout{\nu G}{\outterm}})}}}
\end{mathpar}
%
This rule takes advantage of the fact that we can always translate
away functions using the $\topi{-}$ translation, and we can simulate
multiple arguments using a tensor.

The full translation on terms is as follows.
\begin{equations}
\topi{\lambda x.M} &=& \gvfork{z}{\gvlet{(x, z)}{\gvreceive{z}}{\gvlink{\topi{M}}{z}}} \\
\topi{L\,M} &=& \gvsend{\topi{M}}{\topi{L}} \\
\topi{M, N} &=&
  \gvfork{z}
    {\gvlink{(\gvsend{\topi{M}}{z})}{\topi{N}}} \\
\topi{\gvlet{(x, y)}{M}{N}} &=&
    \gvlet{(x, y)}{\gvreceive{\topi{M}}}{\topi{N}} \\
\topi{L : T \uto U} &=&
  \gvserve{z}{\gvlink{\topi{L}}{z}} \\
\topi{L : T \lto U} &=& \gvrequest{\topi{L}} \\
\topi{\gvreceive{M}} &=& \topi{M}
\\[1ex]
\topi{\gvfix{f}{\vec{x}\,c}{M}} &=&
  \gvfix{p}{z\,c}{\gvlet{\vec{x}}{z}{\topi{M[L/f]}}} \\
&& \text{where }L = \lambda \vec{x} c.\gvsend{c}{(\gvsend{\vec{x}}{(\gvrequest{p})})} \\
\end{equations}%
Formally, this is a translation from derivations to terms. We write type annotations to indicate
$\to$ introduction and elimination. For all other cases, it is unambiguous to give the translation
on plain term syntax. Each introduction form translates to an interface $\gvfork{z}{M}$ of type
$\gvdual{S}$, where $M : \outterm$ provides the implementation, with $z : S$ bound in $M$.
%
The only new case is that for $\key{corec}$. We package up all of the arguments into a tuple, and
simulate the interface to the arrows using session operations in the obvious way dictated by the
rest of the $\topi{-}$ translation.

We can extend the translation on types to a translation on contexts:
\begin{equations}
\topi{x_1:T_1, \dots, x_n:T_n} &=& x_1:\topi{T_1}, \dots, x_n:\topi{T_n} \\
\end{equations}%
It is straightforward to verify that our translation preserves typing.
\begin{theorem}
If $\gvtyp{\Phi}{M}{T}$ then $\gvtyp{\topi{\Phi}}{\topi{M}}{\topi{T}}$.
\end{theorem}

\subsection{Translation from \gvpi to \mucp}\label{sec:gvpitocp}

We now give a translation from \gvpi to CP. Post composing this with the embedding of \mugv in \gvpi
yields a semantics for \mugv. The translation on session types is as follows:
\[
\ba{@{}c@{\qquad}c@{\qquad}c@{}}
\begin{eqs}
\tocp{\gvout{T}{S}}        &=& \cpdual{\tocp{T}} \otimes \tocp{S} \\
\tocp{\gvin{T}{S}}         &=& \tocp{T} \parr \tocp{S} \\
\tocp{\gvservice{S}}       &=& \cpquery{\tocp{S}} \\
\tocp{\gvserver{S}}        &=& \cpbang{\tocp{S}} \\
\end{eqs}
&
\begin{eqs}
\tocp{\oplus \{l_i:S_i \}} &=& \oplus \{l_i:\tocp{S_i}\} \\
\tocp{\with \{l_i:S_i \}}  &=& \with \{l_i:\tocp{S_i}\} \\
\tocp{\nu G}               &=& \nu\tocp{G} \\
\tocp{\mu G}               &=& \mu\tocp{G} \\
\end{eqs}
&
\begin{eqs}
\tocp{\outterm}            &=& 1 \\
\tocp{\interm}             &=& \bot \\
\tocp{X}                   &=& X \\
\tocp{\gvdual{X}}          &=& \cpdual{X} \\
\end{eqs}\\
& \tocp{X.S} = X.\tocp{S} & \\
\ea
\]
The translation is homomorphic except for output, where the output type is dualised. This accounts
for the discrepancy between $\gvdual{\gvout{T}{S}} = \gvin{T}{\gvdual{S}}$ and $\cpdual{(A \otimes
  B)} = \cpdual{A} \parr \cpdual{B}.$

The translation on terms is formally specified as a CPS translation on derivations as in Wadler's
presentation. We provide the full translations of weakening and contraction for $\interm$, and for
rolling and unrolling of recursive session types $\nu G$ and $\mu G$, as these steps are implicit in
the syntax of \mugv terms. The other constructs depend only on the immediate syntactic structure, so
we abbreviate their translations as mappings on plain terms.  The majority of translations are as in
our previous work:

\begin{align*}
\left\llbracket \inferrule{\gvtyp{\Phi}{N}{S}}{\gvtyp{\Phi,x:\interm}{N}{S}} \right\rrbracket\!\!z &=
  \inferrule
    {\cptyp{\tocp{N}z}{\tocp{\Phi},z:\cpdual{\tocp{S}}}}
    {\cptyp{x().\tocp{N}z}{\tocp{\Phi},x:\bot,z:\cpdual{\tocp{S}}}}
\\[3ex]
\left\llbracket \inferrule{\gvtyp{\Phi,x:\interm,x':\interm}{N}{S}}
                          {\gvtyp{\Phi,x:\interm}{N[x/x']}{S}} \right\rrbracket \!\!z &=
  \inferrule
    {\cptyp{\tocp{N}z}{\tocp{\Phi},x:\bot,x':\bot,z:\cpdual{\tocp{S}}}}
    {\cptyp{\cut{x'}{}{\tocp{N}z}{x'[].0}}{\tocp{\Phi},x:\bot,z:\cpdual{\tocp{S}}}}
\\[3ex]
\tocp{x}z &= \link{x}{z} \\
\tocp{\gvsend{M}{N}}z &= \cut{x}{}{x[y].(\tocp{M}y \mid \link{x}{z})}{\tocp{N}x} \\
\tocp{\gvlet{(x,y)}{\gvreceive{M}}{M}}z &= \cut{y}{}{\tocp{M}y}{y(x).\tocp{N}z} \\
\tocp{\gvselect{l}{M}}z &= \cut{x}{}{\tocp{M}x}{x[l].\link{x}{z}} \\
\tocp{\gvcase{M}{l_n\,x.N_i}}z &=  \cut{x}{}{\tocp{M}x}{\case{x}{l_i.\tocp{N_i}z}} \\
\tocp{\gvfork{x}{M}}z &= \cut{x}{}{\cut{y}{}{\tocp{M}y}{y[].0}}{\link{x}{z}} \\
\tocp{\gvlink{M}{N}}z &= z().\cut{x}{}{\tocp{M}x}{\tocp{N}x} \\
%\tocp{\gvSendType{S}{M}}z &=
%  \cut{x}{\tocp{M}x}{\cpSendType{x}{\tocp{S}}{\cpLink{x}{z}}} \\
%\tocp{\gvReceiveType{X}{M}}z &=
%  \cut{x}{\tocp{M}x}{\cpReceiveType{x}{X}{\cpLink{x}{z}}} \\
\tocp{\gvserve{y}{M}}z &= \replicate{z}{y}.\cut{x}{}{\tocp{M}x}{x[].0} \\
\tocp{\gvrequest{M}}z &= \cut{x}{}{\tocp{M}x}{\derelict{x}{y}.\link{y}{z}} \\[3ex]
\end{align*}
The folding and unfolding of recursive session types in GV can be translated to cuts against the CP
proofs of the corresponding equivalences; for example, unfolding the GV session type $\mu G$ to $G
(\mu G)$ corresponds to the CP proof that $\nu F \lto F(\mu F)$.  Note the parallels between the
first two and last two cases: this aligns with the derivation of the rules for $\mu$ and $\nu$ in
\mucp.
\begin{gather*}
\tocpbig{\inferrule{\gvtyp{\Phi}{M}{\mu G}}{\gvtyp{\Phi}{M}{G (\mu G)}}} z = \cut{y}{\nu \tocp{G}}{\tocp{\gvtyp{\Phi}{M}{\mu G}}y}{\rec{y}.\link{y}{z}} \\[3ex]
\tocpbig{\inferrule{\gvtyp{\Phi}{M}{G(\nu G)}}{\gvtyp{\Phi}{M}{\nu G}}} z = \cut{y}{\nu \tocp{G}}{\tocp{\gvtyp{\Phi}{M}{G(\nu G)}}y}{\rec{z}.\link{y}{z}} \\[3ex]
\tocpbig{\inferrule{\gvtyp{\Phi}{M}{G(\mu G)}}{\gvtyp{\Phi}{M}{\mu G}}} z =
\cut{y}{\tocp{G}(\mu \tocp{G})}{\tocp{\gvtyp{\Phi}{M}{G (\mu G)}}}
       {\corec{z}{x}{\tocp{G}(\mu \tocp{G})}
              {\link{y}{x}}
              {\map{G}{x,z}{\rec{x}.\link{x}{z}}}}
\\[3ex]
\tocpbig{\inferrule{\gvtyp{\Phi}{M}{\nu G}}{\gvtyp{\Phi}{M}{G (\nu G)}}} z =
\cut{y}{\mu \tocp{G}}{\tocp{\gvtyp{\Phi}{M}{\nu G}}}
       {\corec{y}{x}{\cpdual{\tocp{G}}(\nu \cpdual{\tocp{G}})}
              {\link{z}{x}}
              {\map{G}{x,y}{\rec{x}.\link{x}{y}}}}
\end{gather*}

\todo{Clarify - the following sentence is unintelligible}

Finally, the translation of $\lrkwd$ depends on, first, extracting the expected state from the
coinvariant and, second, replacing the recursive behavior with re-establishing the coinvariant.
\[
\bl
\left\llbracket
\inferrule{\gvtyp{p:\gvservice{(\gvout{T}{\gvout{X}{\outterm}})},x:T,c:G(X)}{M}{\outterm}}
          {\gvtyp{}{\gvfix{p}{x\,c}{M}}{\gvservice{(\gvout{T}{\gvout{\nu G}{\outterm}})}}}
\right\rrbracket z = \\
\replicate{z}{y}.y(x).y(c).y(). \\
\quad \corec{c}{w}{}{w[x].w[].0}{\cut{p}{}{\replicate{p}{y}.y(x).y(c).y().c[x].c[].0}{w(x).\tocp{M}w}} \\
\el
\]
where we have used the following syntactic sugar for output along a channel:
\[
x[y].P \equiv x[y'].(\link{y}{y'} \mid P)
\]

\begin{theorem}
  If $\gvtyp{\Phi}{M}{T}$, then $\cptyp{\tocp{M}z}{\tocp{\Phi},z:\cpdual{\tocp{T}}}$.
\end{theorem}

\subsection{Translating from \mucp to \gvpi}\label{sec:cptogvpi}

We now present the translation $\togv{-}$ from CP to \gvpi. The translation on types is as follows:
\[
\ba{@{}c@{\qquad}c@{\qquad}c@{}}
\begin{eqs}
\togv{A \otimes B} &=& \gvout{\gvdual{\togv{A}}}{\togv{B}} \\
\togv{A \parr B}   &=& \gvin{\togv{A}}{\togv{B}} \\
\togv{\cpbang{A}}   &=& \gvservice{\togv{A}} \\
\togv{\cpquery{A}}  &=& \gvserver{\togv{A}} \\
\end{eqs}
&
\begin{eqs}
\togv{+\{l_i:A_i\}_i}     &=& +\{l_i:\togv{A_i}\}_i  \\
\togv{\with\{l_i:A_i\}_i} &=& \with\{l_i:\togv{A_i}\}_i \\
\togv{\nu F} &=& \nu \togv{F} \\
\togv{\mu F} &=& \mu \togv{F} \\
\togv{X.A} &=& X.\togv{A} \\
\end{eqs}
&
\begin{eqs}
\togv{1}           &=& \outterm \\
\togv{\bot}              &=& \interm \\
\togv{X}            &=& X \\
\togv{\cpdual{X}}   &=& \gvdual{X} \\
\end{eqs}
\ea
\]
The translation on terms makes use of $\key{let}$ expressions to simplify the presentation; these
are expanded to \gvpi as follows
\[
\gvlet{x}{M}{N} \equiv
  \topi{(\lambda x.N) M} \equiv
  \gvsend{M}{(\gvfork{z}{\gvreceivek{x}{z}{z}{\gvlink{N}{z}}})}
\]%
and the translation on terms is as follows
\begin{equations}
  \togv{x[y].(P \mid Q)} &=&
    \gvlet{x}{\gvsend{(\gvfork{y}{\togv{P}})}{x}}{\togv{Q}} \\
  \togv{x(y).P} &=&
    \gvlet{(y,x)}{\gvreceive{x}}{\togv{P}} \\
  \togv{\sel{x}{\mathit{l}}.P} &=&
    \gvlet{x}{\gvselect{l}{x}}{\togv{P}} \\
  \togv{\case{x}{l_i.P_i}} &=&
    \gvcase{x}{l_i.\togv{P_i}} \\
  \togv{x[].0} &=& x \\
  \togv{x().P} &=& \togv{P} \\
  \togv{\cut{x}{}{P}{Q}} &=&
    \gvlet{x}{\gvfork{x}{\togv{P}}}{\togv{Q}} \\
  \togv{\link{x}{y}} &=& \gvlink{x}{y} \\
  \togv{\replicate{s}{x}{P}} &=&
    \gvlink{s}{(\gvserve{x}{\togv{P}})} \\
  \togv{\derelict{s}{x}{P}} &=&
    \gvlet{x}{\gvrequest{s}}{\togv{P}} \\
  \togv{\cptyp{\corec{c}{x}{}{P}{Q}}{\Gamma, x:\nu F}} &=&
    \gvsend{(\gvfork{x}{\togv{P}})\,c}{(\gvrequest{(\gvfix{p}{x\,c}{Q_{F,p,x,c}})})} \\
  \togv{\rec{x}.P} &=& \togv{P} \\
\end{equations}%
where:
%
%% \[
%%   Q_{F,p,x,c} =
%%     \gvlet{c'}{\gvfork{c}{\togv{Q}}}
%%               {\gvmap{\togv{F}}{c,c'}{(\gvsend{c\,c'}{(\gvrequest{p})})}}
%% \]%
\[
  Q_{F,p,x,c} =
    \gvlet{c'}{\gvfork{c}{\togv{Q}}}
          {\togv{\map{F}{c,c'}{\derelict{p}{z}{z[c, c'].p[].0}}}}
\]%

%% \todo{The above is clearly nonsense. We must need to send two things to the result of a fix in order
%%   to obtain an end!. Also $c$ isn't bound anywhere!}
%% \[
%%   Q^\dagger =
%%     \gvlet{c}
%%           {\gvfork{x}{\togv{Q}}}
%%           {\gvmap{\togv{F}}{x,c}{(\gvsend{c}{(\gvsend{x}{p})})}}
%% \]%
%% \[
%%   Q^\dagger =
%%     \gvlet{y'}
%%           {\gvfork{y}{\togv{Q}}}
%%           {\togv{\map{F}{x,c}{p[x].p[c].p[].0}}}
%% \]%

The translation is the same as in our previous work~\cite{LindleyM14} except for recursion and
corecursion. Formally, it is a translation from judgements to terms (as we need to know the type
operator in the case of $\key{corec}$).

%% %
%% \[
%%   Q^\dagger = \gvlet{d}{\gvfork{x}{\togv{Q}}}{\gvmap{\togv{F}}{c,d}{(\gvsend{c}{(\gvsend{d}{p})})}}.
%% \]



%% Again, we can extend the translation on types to a translation on contexts, and show that the
%% translation preserves typing.
%% \begin{theorem}
%% If $\cpj{P}{\G}$ then $\gvj{\cptogv{\G}}{\cptogv{P}}{\gvEndOutput}$.
%% \end{theorem}

%% We can transfer the functoriality result from \mucp to \mugv:

%% \begin{lemma}
%%   If $\gvtyp{c:S,d:S'}{M}{\outterm}$, then there is a term, which we call $\gvmap{G}{c,d}{M}$, such
%%   that $\gvtyp{c:G(S),d:\gvdual{G}(S')}{\gvmap{G}{c,d}{M}}{\outterm}$.
%% \end{lemma}

%% Since $\mapname$ is defined in \mucp by cases, we can get $\mapname$ in \mugv by applying our
%% existing translation to each case.  Define
%% \[
%%   Q^\dagger = \gvlet{d}{\gvfork{x}{\togv{Q}}}{\gvmap{\togv{F}}{c,d}{(\gvsend{c}{(\gvsend{d}{p})})}}.
%% \]

%% \begin{lemma}
%%   If $\cptyp{Q}{y:\cpdual{A},x:F(A)}$, then
%%   \[
%%     \gvtyp{x:\gvdual{\togv{A}},p:\gvservice{(\gvout{\gvdual{\togv{A}}}{\gvout{X}{\outterm}})},c:\togv{F}(X)}{Q^\dagger}{\outterm}
%%   \]
%% \end{lemma}

%% \begin{theorem}
%%   If $\cptyp{Q}{y:\cpdual{A},x:F(A)}$, then $\gvtyp{}{\gvfix{p}{y\,c}{Q^\dagger}}{\gvservice{(\gvout{\gvdual{\togv{A}}}{\gvout{\nu \togv{F}}{\outterm}})}}$.
%% \end{theorem}


%% \begin{align*}
%%   \togv{\corec{x}{y}{}{P}{Q}} &= \gvsend{(\gvfork{y}{P})}{(\gvrequest{(\gvfix{p}{y\,x}{Q^\dagger})})} \\
%%   \togv{\rec{x}.P} &= \togv{P} \\
%%   \togv{x[y].(P \mid Q)} &=
%%     \gvlet{x}{\gvsend{(\gvfork{y}{\togv{P}})}{x}}{\togv{Q}} \\
%%   \togv{x(y).P} &=
%%     \gvlet{(y,x)}{\gvreceive{x}}{\togv{P}} \\
%%   \togv{\sel{x}{\mathit{l}}.P} &=
%%     \gvlet{x}{\gvselect{l}{x}}{\togv{P}} \\
%%   \togv{\case{x}{l_i.P_i}} &=
%%     \gvcase{x}{l_i.\togv{P_i}} \\
%%   \togv{x[].0} &= x \\
%%   \togv{x().P} &= \togv{P} \\
%%   \togv{\cut{x}{}{P}{Q}} &=
%%     \gvlet{x}{\gvfork{x}{\togv{P}}}{\togv{Q}} \\
%%   \togv{\link{x}{y}} &= \gvlink{x}{y} \\
%%   \togv{\replicate{s}{x}{P}} &=
%%     \gvlink{s}{(\gvserve{x}{\togv{P}})} \\
%%   \togv{\derelict{s}{x}{P}} &=
%%     \gvlet{x}{\gvrequest{s}}{\togv{P}} \\
%% \end{align*}

\begin{theorem}
  If $\cptyp{P}{\Gamma}$, then $\gvtyp{\togv{\Gamma}}{\togv{P}}{\outterm}$.
\end{theorem}

\section{Related Work}\label{sec:related}

\begin{itemize}
\item Session types
  \begin{itemize}
  \item Honda
  \item Honda, Vasconcelos, Kubo
  \item Other examples of recursion?
  \item Giovanni Bernardi?
  \end{itemize}
\item CH correspondence
  \begin{itemize}
  \item Abramsky~\cite{Abramsky92,BellinScott94}
  \item Caires and Pfenning~\cite{CairesPfenning10}
  \item Wadler~\cite{Wadler12}
  \end{itemize}
\item LL and fixed points
  \begin{itemize}
  \item Girard~\cite{Girard87}
  \item Baelde~\cite{Baelde12}
  \end{itemize}
\end{itemize}

\section{Conclusion and Future Work}\label{sec:future}

\begin{itemize}
\item Direct (asynchronous) semantics of \mugv{}?
\item Recursive types (instead of just recursive sessions)?
\item $\mathrm{MIX}_0,\mathrm{MIX}_2$ and the treatment of closed channels.
\end{itemize}

\label{sect:bib}
\bibliographystyle{plain}
\bibliography{main}

\end{document}
