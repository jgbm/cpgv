% -*- fill-column: 70 -*-

% easychair.tex,v 3.2 2012/05/15
%
% Select appropriate paper format in your document class as
% instructed by your conference organizers. Only withtimes
% and notimes can be used in proceedings created by EasyChair
%
% The available formats are 'letterpaper' and 'a4paper' with
% the former being the default if omitted as in the example
% below.
%
\documentclass{easychair}
%\documentclass[debug]{easychair}
%\documentclass[verbose]{easychair}
%\documentclass[notimes]{easychair}
%\documentclass[withtimes]{easychair}
%\documentclass[a4paper]{easychair}
%\documentclass[letterpaper]{easychair}

% This provides the \BibTeX macro
\usepackage{doc}
\usepackage{makeidx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{stmaryrd}
\usepackage{mathpartir}
\usepackage{xspace}

% In order to save space or manage large tables or figures in a
% landcape-like text, you can use the rotating and pdflscape
% packages. Uncomment the desired from the below.
%
% \usepackage{rotating}
% \usepackage{pdflscape}

% If you plan on including some algorithm specification, we recommend
% the below package. Read more details on the custom options of the
% package documentation.
%
% \usepackage{algorithm2e}


%%% macros

\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}

\newenvironment{equations}{\[\ba{@{}r@{~}c@{~}l@{}}}{\ea\]}
\newenvironment{eqs}{\ba{@{}r@{~}c@{~}l@{}}}{\ea}



\newcommand{\key}{\mathsf}

\newcommand{\set}[1]{\{ #1 \}}


\newcommand{\gvtocp}[1]{\llbracket{#1}\rrbracket}
\newcommand{\cptogv}[1]{\llparenthesis{#1}\rrparenthesis}

\newcommand{\row}[2]{\set{#1}_{#2}}

\newcommand{\gvOutput}[2]{\mathord{!}{#1}.{#2}}
\newcommand{\gvInput}[2]{\mathord{?}{#1}.{#2}}
\newcommand{\gvEndOutput}{\key{end}_!}
\newcommand{\gvEndInput}{\key{end}_?}
\newcommand{\gvPlus}[2]{\oplus \row{#1}{#2}}
\newcommand{\gvChoice}[2]{\binampersand \row{#1}{#2}}
\newcommand{\gvServer}[1]{\flat {#1}}
\newcommand{\gvService}[1]{\sharp {#1}}
\newcommand{\gvDual}[1]{\overline{#1}}
\newcommand{\gvOutputType}[2]{![{#1}].{#2}}
\newcommand{\gvInputType}[2]{?[{#1}].{#2}}

\newcommand{\cpj}[2]{{#1} \vdash {#2}}
\newcommand{\gvj}[3]{{#1} \vdash {#2} : {#3}}

\newcommand{\la}{l}
\newcommand{\G}{\Gamma}
\newcommand{\D}{\Delta}

\newcommand{\lolli}{\multimap}

\newcommand{\gvLinFun}[2]{{#1} \lolli {#2}}
\newcommand{\gvUnFun}[2]{{#1} \to {#2}}
\newcommand{\gvTimes}[2]{{#1} \otimes {#2}}
\newcommand{\gvUnitType}{\key{Unit}}

\newcommand{\gvUnit}{\key{unit}}
\newcommand{\gvLink}[2]{\key{link}~{#1}~{#2}}
\newcommand{\gvLam}[2]{\lambda {#1}.{#2}}
\newcommand{\gvApp}[2]{{#1}~{#2}}
\newcommand{\gvPair}[2]{({#1},{#2})}
\newcommand{\gvLet}[3]{\key{let}~{#1}={#2}~\key{in}~{#3}}
\newcommand{\gvSend}[2]{\key{send}~{#1}~{#2}}
\newcommand{\gvReceive}[1]{\key{receive}~{#1}}
\newcommand{\gvSelect}[2]{\key{select}~{#1}~{#2}}
\newcommand{\gvCase}[2]{\key{case}~{#1}~\key{of}~{#2}}
\newcommand{\gvWith}[3]{\key{with}~{#1}~\key{connect}~{#2}~\key{to}~{#3}}
\newcommand{\gvTerminate}[1]{\key{terminate}~{#1}}

% receive with continuation
\newcommand{\gvReceiveK}[4]{\gvLet{\gvPair{#1}{#2}}{\gvReceive{#3}}{#4}}

\newcommand{\gvSendType}[2]{\key{sendType}~{#1}~{#2}}
\newcommand{\gvReceiveType}[1]{\key{receiveType}~{#1}}


\newcommand{\gvServeOld}[3]{\key{serve}~{#1}({#2})={#3}}

\newcommand{\gvServe}[2]{\key{serve}~{#1}.{#2}}
\newcommand{\gvRequest}[1]{\key{request}~{#1}}

\newcommand{\cpLink}[2]{{#1} \leftrightarrow {#2}}
\newcommand{\cpCut}[3]{\nu {#1}.({#2} \mid {#3})}
\newcommand{\cpOutput}[4]{{#1}[{#2}].({#3} \mid {#4})}
\newcommand{\cpInput}[3]{{#1}({#2}).{#3}}
\newcommand{\cpInject}[3]{{#1}[{#2}].{#3}}
\newcommand{\cpCase}[2]{{#1}.\key{case}~{#2}}
\newcommand{\cpServe}[3]{!{#1}({#2}).{#3}}
\newcommand{\cpRequest}[3]{?{#1}[{#2}].{#3}}
\newcommand{\cpEmptyOut}[1]{{#1}[].0}
\newcommand{\cpEmptyIn}[2]{{#1}().{#2}}
\newcommand{\cpSendType}[3]{{#1}[{#2}].{#3}}
\newcommand{\cpReceiveType}[3]{{#1}({#2}).{#3}}


\newcommand{\cpTimes}[2]{{#1} \otimes {#2}}
\newcommand{\cpPar}[2]{{#1} \mathbin{\bindnasrepma} {#2}}
\newcommand{\cpPlus}[2]{\oplus \row{#1}{#2}}
\newcommand{\cpWith}[2]{\binampersand \row{#1}{#2}}
\newcommand{\cpOne}{1}
\newcommand{\cpBottom}{\bot}
\newcommand{\cpOfCourse}[1]{!{#1}}
\newcommand{\cpWhyNot}[1]{?{#1}}
\newcommand{\cpDual}[1]{{#1}^\bot}
\newcommand{\cpExists}[2]{\exists {#1}.{#2}}
\newcommand{\cpForall}[2]{\forall {#1}.{#2}}

\newcommand{\cpZero}{0}    % 0   == +{}
\newcommand{\cpTop}{\top}  % top == &{}

\newcommand{\un}[1]{\mathit{un}(#1)}
\newcommand{\lin}[1]{\mathit{lin}(#1)}

\newcommand{\FV}[1]{\mathit{FV}(#1)}
\newcommand{\subst}[3]{{#1}[{#2}/{#3}]}

\newcommand{\gvtocps}[1]{\gvtocp{#1}}
\newcommand{\gvtocpd}[1]{\gvtocp{#1}}

\newcommand{\cpMix}[2]{({#1} \mid {#2})}
\newcommand{\cpCutOutput}[5]{{#2}[{#3}].\nu{#1}.\cpMix{#4}{#5}}

\newcommand{\hgv}{HGV\xspace}
\newcommand{\hgvpi}{HGV$\pi$\xspace}

%\makeindex

%% Document
%%
\begin{document}

\title{Sessions as propositions}

% \titlerunning{} has to be set to either the main title or its shorter
% version for the running heads. When processed by
% EasyChair, this command is mandatory: a document without \titlerunning
% will be rejected by EasyChair

\titlerunning{Sessions as propositions}

% Authors are joined by \and. Their affiliations are given by \inst, which indexes
% into the list defined using \institute
%
\author{
  Sam Lindley
  \and
  J. Garrett Morris
}
%% \author{
%% Serguei A. Mokhov\inst{1}\thanks{Designed and implemented the class style}
%% \and
%%     Geoff Sutcliffe\inst{2}\thanks{Did numerous tests and provided a lot of suggestions}
%% \and
%%    Andrei Voronkov\inst{3}\thanks{Masterminded EasyChair and created versions
%%      3.0--3.1 of the class style}\\
%% \and
%%    Graham Gough\inst{3}\thanks{Changed author list format.}\\
%% }


% Institutes for affiliations are also joined by \and,
\institute{The University of Edinburgh \\
           \email{Sam.Lindley@ed.ac.uk, Garrett.Morris@ed.ac.uk}
}
%% \institute{
%%   Concordia University,
%%   Montreal, Quebec, Canada\\
%%   \email{mokhov@cse.concordia.ca}
%% \and
%%    University of Miami,
%%    Miami, Florida, U.S.A.\\
%%    \email{geoff@cs.miami.edu}\\
%% \and
%%    University of Manchester,
%%    Manchester, U.K.\\
%%    \email{andrei@voronkov.com, graham@cs.man.ac.uk}\\
%%  }
%  \authorrunning{} has to be set for the shorter version of the authors' names;
% otherwise a warning will be rendered in the running heads. When processed by
% EasyChair, this command is mandatory: a document without \authorrunning
% will be rejected by EasyChair

\authorrunning{Lindley and Morris}


\clearpage

\maketitle


\begin{abstract}
Recently, Wadler presented a continuation-passing translation from a session-typed functional
language, called GV, to a process calculus, called CP, based on classical linear logic. However,
this translation is one-way: CP is more expressive than GV. We propose an extension to GV, called
\hgv, which bridges the expressiveness gap. We provide direct translations from CP into the session
fragment of \hgv, called \hgvpi, and from \hgv to \hgvpi. We prove that the original
qcontinuation-passing translation from GV to CP factors through the direct translation to
\hgvpi. The new translations shed light both on the original translation from GV to CP, and on the
limitations in expressiveness of GV.
\end{abstract}


%\section{To mention}
%
%Processing in EasyChair - number of pages.
%
%Examples of how EasyChair processes papers. Caveats (replacement of EC
%class, errors).

% \pagestyle{empty}


\section{Introduction}

Linear logic has long been seen as a possible typing discipline for concurrent programming.
Girard~\cite{Girard87} originally identified that the connectives of linear logic could be
interpreted as parallel computation.  Abramsky~\cite{Abramsky92} and Bellin and
Scott~\cite{BellinScott94} demonstrated an interpretation of linear logic proofs as processes in
Milner's $\pi$-calculus; however, while their system provided $\pi$-calculus interprations of all
linear logic proofs, it did not provide a proof-theoretic interpretation for arbitrary
$\pi$-calculus terms.  Caires and Pfenning~\cite{CairesPfenning10} observed that the multiplicative
connectives could be interpreted in the style of session types; however, their underlying process
calculus is more similar to the $\pi$-calculus than to traditional session-typed languages, and is
based on intuitionistic linear logic.  Finally, Wadler~\cite{Wadler12} showed that a simple
session-typed linear functional language, patterned after that of Gay and
Vasconselos~\cite{GayVasconcelos10}, could be mapped into a process calculus based on the classical
linear logic.

Wadler's work showed that linear session-typed programs could be interpreted as proofs in linear
logic.  However, his session-typed language (called GV) is less expressive than the linear
logic---thus, there are linear logic proofs, with corresponding terms of his process calculus
(called CP), which do not correspond to any GV program.  This work begins by defining an extension
of GV, called \hgv, sufficient to express all proofs in the linear logic. To demonstrate \hgv's
expressiveness, we both give a direct translation from CP into \hgv and extend Wadler's
continuation-passing translation from GV into CP to one from \hgv into CP.

As CP only describes process communication, our translation maps all of CP into the session-oriented
fragment of HGV (which we call \hgvpi), avoiding the functional features of \hgv entirely.  Thus, by
composing the translation from \hgv to CP with that from CP to \hgvpi, we obtain a translation of
the functional features of \hgv into their process counterparts.  Because the translation from \hgv
to CP is continuation-passing, the composed translation from \hgv into \hgvpi is also
continuation-passing.  As an alternative approach, we give a direct translation from \hgv to \hgvpi.
These translations illustrate several points.  First, they show the increased exprsesivityof \hgv:
as GV's session types contained no notion of replication or recursion, they could not express the
non-linear features of its functional fragment; \hgv, in contrast, can be reduced to \hgvpi.
Second, factoring the translation of \hgv into CP over that from \hgv into \hgvpi simplifies the
translation, and illuminates regularities that were not apparent in Wadler's original translation.

\section{Background}


\subsection{\hgv}
~

GV stands for ``good vibrations''. \hgv stands for ``harmonious good
vibrations''.

Session types
\[
S ::= \gvOutput{T}{S} \mid \gvInput{T}{S} \mid
      \gvPlus{\la_i:S_i}{i} \mid \gvChoice{\la_i:S_i}{i} \mid
      \gvEndOutput \mid \gvEndInput \mid
      X \mid \gvDual{X} \mid
      \gvOutputType{X}{S} \mid \gvInputType{X}{S} \mid
      \gvServer{S} \mid \gvService{S}
\]

\hgv, in addition to the: value output ($\gvOutput{T}{S}$), value
input ($\gvInput{T}{S}$), select ($\gvPlus{\la_i:S_i}{i}$), choice
($\gvChoice{\la_i:S_i}{i}$), end output ($\gvEndOutput$) and end input
($\gvEndInput$) session types of GV, has: session type variables
($X$), negated session type variables ($\gvDual{X}$), type output
($\gvOutputType{X}{S}$), type input ($\gvInputType{X}{S}$), server
($\gvServer{S}$) and service ($\gvService{S}$) session types.


Types
\[
T,U,V ::= S \mid \gvTimes{T}{U} \mid \gvLinFun{T}{U} \mid \gvUnFun{T}{U}
\]

Each type $T$ is classified as either linear ($\lin{T}$) or unlimited
($\un{T}$).
\[
\begin{array}{l}
\lin{\gvOutput{T}{S}}  \quad \lin{\gvInput{T}{S}} \quad
\lin{\gvPlus{\la_i:S_i}{i}} \quad \lin{\gvChoice{\la_i:S_i}{i}} \quad
\lin{\gvEndOutput} \quad \un{\gvEndInput} \\
\lin{X} \quad
\lin{\gvOutputType{X}{S}} \quad \lin{\gvInputType{X}{S}} \quad
\lin{\gvServer{S}} \quad \un{\gvService{S}} \\
\lin{\gvTimes{T}{U}} \quad \lin{\gvLinFun{T}{U}} \quad \un{\gvUnFun{T}{U}}
\end{array}
\]
The only unlimited type constructors are those for end input,
services, and unlimited functions.

Apart from the extensions, the two differences in the types of GV are
that there is no unit type (called $\gvUnitType$ in GV), and
$\gvEndInput$ is unlimited. We omit unit because it is isomorphic to
both $\gvEndInput$ and $\gvService{(\gvPlus{}{})}$.

The terms and typing rules for \hgv are given in
Figure~\ref{fig:hgv-typing}. The first three rules are structural. The
next six rules cover the non-session fragment of \hgv. The remaining
rules cover the session fragment of \hgv.

Notice that the non-session and session fragments are orthogonal, in
that the non-session rules mention only non-session type constructors,
and the session rules mention only session type constructors. This is
a useful property which does not hold of the original GV. As we shall
see, it enables us to compile away the non-session fragment into the
session fragment.

Vanilla GV, has session constructs $\key{receive}$ and
$\key{terminate}$, both of whose typing rules mention non-session
types.
\begin{mathpar}
\inferrule[Receive-$\otimes$]
{\gvj{\Phi}{M}{\gvInput{T}{S}}}
{\gvj{\Phi}{\gvReceive{M}}{\gvTimes{T}{S}}}

\inferrule[Terminate-$\otimes$]
{\gvj{\Phi}{M}{\gvTimes{T}{\gvEndInput}}}
{\gvj{\Phi}{\gvTerminate{M}}{T}}
\end{mathpar}
\hgv dispenses with $\key{terminate}$ by making $\gvEndOutput$
unlimited, and builds a pair binding into $\key{receive}$, thus
immediately eliminating the tensor.

The final five typing rules of Figure~\ref{fig:hgv-typing} extend the
functionality of \hgv with respect to GV: $\gvLink{M}{N}$ links
channel $M$ to channel $N$, $\gvSendType{S}{M}$ sends session type $S$
along $M$, $\gvReceiveType{M}$ receives a type along $M$,
$\gvServe{x}{M}$ defines a server as $M$ parameterised by channel $x$,
and $\gvRequest{M}$ requests a fresh instance of service $M$.
%

We argue that each of the five new constructs adds expressive power to
GV.
%
It seems clear that the ability to send and receive types adds
expressive power.
%
One can straightforwardly simulate $\gvLink{M}{N}$ in terms of other
constructs for monomorphic types, but not for polymorphic types.
%
There are parallels between servers and unlimited functions. One might
expect to be able to simulate the former in terms of the latter --- a
server is much like an unlimited function parameterised by a
channel. A key difference is that functions are not session types, so
cannot appear everywhere that a server type can. We believe that
servers can be simulated by unlimited functions, but only if one
performs a global translation.
%
%% A key difference is that we can disassociate a server declaration
%% ($\gvWith{s}{\dots}{\dots}$) from its definition
%% ($\gvServeOld{s}{x}{\dots}$). Thus, servers support a very limited
%% form of linear dynamic binding, which functions do not. We believe
%% that servers can be simulated by unlimited functions, but only if one
%% performs a global translation similar to closure conversion.
%
In fact, we will be more interested in going the other way,
translating away functions as sessions.






\begin{figure}
\begin{mathpar}
\inferrule[Id]
{ }
{\gvj{x:T}{X}{T}}

\inferrule[Weaken]
{\gvj{\Phi}{N}{U} \\ \un{T}}
{\gvj{\Phi,x:T}{N}{U}}

\inferrule[Contract]
{\gvj{\Phi,x:T,x':T}{N}{U} \\ \un{T}}
{\gvj{\Phi,x:T}{\subst{N}{x}{x'}}{U}}
\\

\inferrule[$\lolli$-I]
{\gvj{\Phi,x:T}{N}{U}}
{\gvj{\Phi}{\gvLam{x}{N}}{\gvLinFun{T}{U}}}

\inferrule[$\lolli$-E]
{\gvj{\Phi}{L}{\gvLinFun{T}{U}} \\ \gvj{\Psi}{M}{T}}
{\gvj{\Phi,\Psi}{\gvApp{L}{M}}{U}}

\\

\inferrule[$\to$-I]
{\gvj{\Phi}{L}{\gvLinFun{T}{U}} \\ \un{\Phi}}
{\gvj{\Phi}{L}{\gvUnFun{T}{U}}}

\inferrule[$\to$-E]
{\gvj{\Phi}{L}{\gvUnFun{T}{U}}}
{\gvj{\Phi}{L}{\gvLinFun{T}{U}}}

\\

%% \inferrule[Unit]
%% { }
%% {\gvj{}{\gvUnit}{\gvUnitType}}

\inferrule[$\otimes$-I]
{\gvj{\Phi}{M}{T} \\ \gvj{\Psi}{N}{U}}
{\gvj{\Phi,\Psi}{\gvPair{M}{N}}{\gvTimes{T}{U}}}

\inferrule[$\otimes$-E]
{\gvj{\Phi}{M}{\gvTimes{T}{U}} \\ \gvj{\Psi,x:T,y:U}{N}{V}}
{\gvj{\Phi,\Psi}{\gvLet{\gvPair{x}{y}}{M}{N}}{V}}

\inferrule[Send]
{\gvj{\Phi}{M}{T} \\ \gvj{\Psi}{N}{\gvOutput{T}{S}}}
{\gvj{\Phi}{\gvSend{M}{N}}{S}}


\inferrule[Receive]
{\gvj{\Phi}{M}{\gvInput{T}{S}} \\ \gvj{\Psi,x:T,y:S}{N}{V}}
{\gvj{\Phi,\Psi}{\gvReceiveK{x}{y}{M}{N}}{V}}

\inferrule[Select]
{\gvj{\Phi}{M}{\gvPlus{\la_i:S_i}{i}}}
{\gvj{\Phi}{\gvSelect{\la_j}{M}}{S_j}}

\inferrule[Case]
{\gvj{\Phi}{M}{\gvChoice{\la_i:S_i}{i}} \\ \row{\gvj{\Psi,x:S_i}{N_i}{T}}{i}}
{\gvj{\Phi,\Psi}{\gvCase{M}{\row{\la_i(x).N_i}{i}}}{T}}

\inferrule[Connect]
{\gvj{\Phi,x:S}{M}{\gvEndOutput} \\ \gvj{\Psi,x:\gvDual{S}}{N}{T}}
{\gvj{\Phi,\Psi}{\gvWith{x}{M}{N}}{T}}

\inferrule[Link]
{\gvj{\Phi}{M}{S} \\ \gvj{\Phi}{N}{\gvDual{S}}}
{\gvj{\Phi}{\gvLink{M}{N}}{\gvEndOutput}}

\inferrule[SendType]
{\gvj{\Phi}{M}{\gvInputType{X}{S}}}
{\gvj{\Phi}{\gvSendType{S}{M}}{\subst{S'}{S}{X}}}

\inferrule[ReceiveType]
{\gvj{\Phi}{M}{\gvOutputType{X}{S}} \\ X \notin \FV{\Phi}}
{\gvj{\Phi}{\gvReceiveType M}{S'}}

\inferrule[Serve]
{\gvj{\Phi,x : S}{M}{\gvEndOutput} \\ \un{\Phi}}
{\gvj{\Phi}{\gvServe{x}{M}}{\gvService{S}}}

\inferrule[Request]
{\gvj{\Phi}{M}{\gvService{S}}}
{\gvj{\Phi}{\gvRequest{M}}{S}}
\end{mathpar}

\caption{Typing rules for \hgv}
\label{fig:hgv-typing}
\end{figure}







\section{From CP to \hgv}
~

Types
\[
\begin{array}{@{}c@{\qquad}c@{\qquad}c@{}}
\begin{eqs}
\cptogv{\cpTimes{A}{B}} &=& \gvOutput{\gvDual{\cptogv{A}}}{\cptogv{B}} \\
\cptogv{\cpPar{A}{B}} &=& \gvInput{\cptogv{A}}{\cptogv{B}} \\
\cptogv{\cpPlus{\la_i:A_i}{i}} &=& \gvPlus{\la_i:\cptogv{A_i}}{i} \\
\cptogv{\cpWith{\la_i:A_i}{i}} &=& \gvChoice{\la_i:\cptogv{A_i}}{i} \\
\end{eqs}
&
\begin{eqs}
\cptogv{\cpOne} &=& \gvEndOutput \\
\cptogv{\cpBottom} &=& \gvEndInput \\[1ex]
\cptogv{\cpOfCourse{A}} &=& \gvServer{\cptogv{A}} \\
\cptogv{\cpWhyNot{A}} &=& \gvService{\cptogv{A}} \\
\end{eqs}
&
\begin{eqs}
\cptogv{X} &=& X \\
\cptogv{\cpExists{X}{A}} &=& \gvOutputType{X}{\cptogv{A}} \\
\cptogv{\cpForall{X}{A}} &=& \gvInputType{X}{\cptogv{A}} \\[1ex]
\end{eqs}
\end{array}
\]

Terms
\begin{equations}
\cptogv{\cpCut{x}{P}{Q}} &=&
  \gvWith{x}{\cptogv{P}}{\cptogv{Q}} \\
\cptogv{\cpOutput{x}{y}{P}{Q}} &=&
  \gvWith{y}{\cptogv{P}}{\gvLet{x}{\gvSend{y}{x}}{\cptogv{Q}}} \\
\cptogv{\cpInput{x}{y}{P}} &=&
  \gvLet{\gvPair{y}{x}}{\gvReceive{x}}{\cptogv{P}} \\
\cptogv{\cpInject{x}{\la}{P}} &=&
  \gvLet{x}{\gvSelect{\la}{x}}{\cptogv{P}} \\
\cptogv{\cpCase{x}{\row{\la_i.P_i}{i}}} &=&
  \gvCase{x}{\row{\la_i(x).\cptogv{P_i}}{i}} \\
\cptogv{\cpEmptyOut{x}} &=& x \\
\cptogv{\cpEmptyIn{x}{P}} &=& \cptogv{P} \\[1ex]
  %% \gvLet{z}{\gvTerminate{x}}{\cptogv{P}} \\[1ex]

\cptogv{\cpSendType{x}{A}{P}} &=&
  \gvLet{x}{\gvSendType{\cptogv{A}}{x}}{\cptogv{P}} \\
\cptogv{\cpReceiveType{x}{X}{P}} &=&
  \gvLet{x}{\gvReceiveType{x}}{\cptogv{P}} \\[1ex]

\cptogv{\cpLink{x}{y}} &=& \gvLink{x}{y} \\
\cptogv{\cpServe{s}{x}{P}} &=&
  \gvLink{s}{(\gvServe{x}{\cptogv{P}})} \\
\cptogv{\cpRequest{s}{x}{P}} &=&
  \gvWith{x}{\gvLink{(\gvRequest{s})}{x}}{\cptogv{P}} \\
\end{equations}

Judgements
\begin{equations}
\cptogv{\cpj{P}{\G}} = \gvj{\cptogv{\G}}{\cptogv{P}}{\gvEndOutput}
\end{equations}

\section{From \hgv to \hgvpi}

\newcommand{\lampi}[1]{({#1})^\star}


The language \hgvpi is the restriction of \hgv to session types,
that is, \hgv without $\lolli$, $\to$, or $\otimes$.

The translation on types is given by the homomorphic extension of the
following equations.
\[
\lampi{\gvLinFun{T}{U}} = \gvOutput{\lampi{T}}{\gvDual{\lampi{U}}} \qquad
\lampi{\gvUnFun{T}{U}} = \gvService{(\gvOutput{\lampi{T}}{\gvDual{\lampi{U}}})} \qquad
\lampi{\gvTimes{T}{U}} = \gvInput{\lampi{T}}{\gvDual{\lampi{U}}}
\]%
Each translated type characterise the \emph{interface} to the
simulated source type. A linear function is simulated by input along a
channel; its interface is output along the other end of the channel.
An unlimited function is simulated by a server; its interface is a
client. A tensor is simulated by output along a channel; its interface
is input along the other end of that channel.
%
This duality between implementation and interface explains the
dualisation of types in Wadler's original CPS translation from GV to
CP.

The translation on terms is given by the homomorphic extension of the
following equations.
\begin{equations}
\lampi{\gvLam{x}{M}} &=& \gvWith{z}{\gvLet{\gvPair{x}{z}}{\gvReceive{z}}{\gvLink{\lampi{M}}{z}}}{z} \\
\lampi{\gvApp{L}{M}} &=& \gvSend{\lampi{M}}{\lampi{L}} \\
\lampi{\gvTimes{M}{N}} &=&
  \gvWith{z}
    {\gvLink{(\gvSend{\lampi{M}}{z})}{\lampi{N}}}
    {z} \\
\lampi{\gvLet{\gvPair{x}{y}}{M}{N}} &=&
    \gvLet{\gvPair{x}{y}}{\gvReceive{\lampi{M}}}{\lampi{N}} \\
\lampi{L : \gvUnFun{T}{U}} &=&
  \gvWith{z}{\gvLink{z}{(\gvServe{y}{\gvLink{\lampi{L}}{y}})}}{z} \\
\lampi{L : \gvLinFun{T}{U}} &=& \gvRequest{\lampi{L}} \\
\end{equations}%
Each introduction form translates to a term $\gvWith{z}{M}{z}$, where
$M : \gvEndOutput$ provides the simulated implementation of the
introduction form with $z : S$ bound in $M$, and $z : \gvDual{S}$ on
the right provides its interface.

The translation on judgements is pointwise.
%
\begin{equations}
\lampi{\gvj{\Phi}{M}{T}} &=& \gvj{\lampi{\Phi}}{\lampi{M}}{\lampi{T}} \\
\end{equations}%


\section{From \hgvpi to CP}
~

\newcommand{\hgvcp}[1]{\llbracket{#1}\rrbracket}

Session types
\begin{equations}
\hgvcp{\gvOutput{T}{S}}        &=& \cpTimes{\cpDual{\hgvcp{T}}}{\hgvcp{S}} \\
\hgvcp{\gvInput{T}{S}}         &=& \cpPar{\hgvcp{T}}{\hgvcp{S}} \\
\hgvcp{\gvPlus{\la_i:S_i}{i}}   &=& \cpPlus{\la_i:\hgvcp{S_i}}{i} \\
\hgvcp{\gvChoice{\la_i:S_i}{i}} &=& \cpWith{\la_i:\hgvcp{S_i}}{i} \\
\hgvcp{\gvEndOutput}              &=& \cpOne \\
\hgvcp{\gvEndInput}               &=& \cpBottom \\[1ex]

\hgvcp{X}                       &=& X \\
\hgvcp{\gvOutputType{X}{S}}     &=& \cpExists{X}{\hgvcp{S}} \\
\hgvcp{\gvInputType{X}{S}}      &=& \cpForall{X}{\hgvcp{S}} \\[1ex]

\hgvcp{\gvServer{S}}  &=& \cpOfCourse{\hgvcp{S}} \\
\hgvcp{\gvService{S}} &=& \cpWhyNot{\hgvcp{S}} \\[1ex]
\end{equations}

Terms

\begin{mathpar}
\left\llbracket \inferrule{\gvj{\Phi}{N}{U}}{\gvj{\Phi,x:\gvEndInput}{N}{U}} \right\rrbracket z =
  \inferrule
    {\cpj{\hgvcp{N}z}{\hgvcp{\Phi},z:\cpDual{\hgvcp{U}}}}
    {\cpj{\cpEmptyIn{x}{\hgvcp{N}z}}{\hgvcp{\Phi},x:\cpBottom,z:\cpDual{\hgvcp{U}}}}
\\
\left\llbracket \inferrule{\gvj{\Phi,x:\gvEndInput,x':\gvEndInput}{N}{U}}
                          {\gvj{\Phi,x:\gvEndInput}{\subst{N}{x}{x'}}{U}} \right\rrbracket z =
  \inferrule
    {\cpj{\hgvcp{N}z}{\hgvcp{\Phi},x:\cpBottom,x':\cpBottom,z:\cpDual{\hgvcp{U}}}}
    {\cpj{\cpCut{x'}{\hgvcp{N}z}{\cpEmptyOut{x'}}}{\hgvcp{\Phi},x:\cpBottom,z:\cpDual{\hgvcp{U}}}}
\end{mathpar}
\begin{equations}
\hgvcp{x}z &=& \cpLink{x}z \\
\hgvcp{\gvSend{M}{N}}z &=& \cpCut{x}{\cpOutput{x}{y}{\hgvcp{M}y}{\cpLink{x}{z}}}{\hgvcp{N}x} \\
\hgvcp{\gvReceiveK{y}{x}{M}{N}}z &=&
  \cpCut{x}{\hgvcp{M}x}{\cpInput{x}{y}{\hgvcp{N}z}} \\
\hgvcp{\gvSelect{\la}{x}}z &=&
  \cpCut{x}{\hgvcp{M}x}{\cpInject{x}{\la}{\cpLink{x}{z}}} \\
\hgvcp{\gvCase{M}{\row{\la_i(x).N_i}{i}}}z &=&
  \cpCut{x}{\hgvcp{M}x}{\cpCase{x}{\row{\la_i.N_i}{i}}} \\
\hgvcp{\gvWith{x}{M}{N}}z &=&
  \cpCut{x}{\cpCut{y}{\hgvcp{M}y}{\cpEmptyOut{y}}}{\hgvcp{N}z} \\[1ex]

\hgvcp{\gvSendType{S}{(M : \cpForall{X}{S'})}}z &=&
  \cpCut{x}{\hgvcp{M}x}{\cpSendType{x}{\hgvcp{S}}{\cpLink{x}{z}}} \\
\hgvcp{\gvReceiveType{(M : \cpExists{X}{S'})}}z &=&
  \cpCut{x}{\hgvcp{M}x}{\cpReceiveType{x}{X}{\cpLink{x}{z}}} \\[1ex]

\hgvcp{\gvLink{M}{N}}z &=& \cpEmptyIn{z}{\cpCut{x}{\hgvcp{M}x}{\cpCut{y}{\hgvcp{N}y}{\cpLink{x}{y}}}} \\
\hgvcp{\gvServe{y}{M}}z &=&
   \cpServe{z}{y}
      {\cpCut{x}{\hgvcp{M}x}{\cpEmptyOut{x}}} \\
\hgvcp{\gvRequest{M}}z &=& \cpCut{x}{\hgvcp{M}x}{\cpRequest{x}{y}{\cpLink{y}{z}}} \\
\end{equations}

Judgements
\begin{equations}
\hgvcp{\gvj{\Phi}{M}{T}} &=& \cpj{\hgvcp{M}z}{\hgvcp{\Phi}, z:\gvDual{\hgvcp{T}}}
\end{equations}



\section{Conclusions and Future Work}

TODO

\cite{wadler2014jfp}

\label{sect:bib}
\bibliographystyle{plain}
%\bibliographystyle{alpha}
%\bibliographystyle{unsrt}
%\bibliographystyle{abbrv}
\bibliography{cpgv}


%% \subsection{GV extensions}

%% \begin{mathpar}
%% \inferrule
%% {\gvj{\Phi}{M}{\gvInputType{X}{S}}}
%% {\gvj{\Phi}{\gvSendType{S}{M}}{S'[S/X]}}

%% \inferrule
%% {\gvj{\Phi}{M}{\gvOutputType{X}{S}} \\ X \notin \FV{\Phi}}
%% {\gvj{\Phi}{\gvReceiveType M}{S'}}
%% \end{mathpar}

%% \begin{mathpar}
%% \inferrule
%% {\gvj{\Phi}{M}{S} \\ \gvj{\Phi}{N}{\gvDual{S}}}
%% {\gvj{\Phi}{\gvLink{M}{N}}{\gvEndOutput}}

%% \inferrule
%% {\gvj{\Phi, s : \gvServer{S}, x : S}{M}{\gvEndOutput}}
%% {\gvj{\Phi}{\gvServeOld{s}{x}{M}}{\gvEndOutput}}

%% \inferrule
%% { }
%% {\gvj{\Phi, s : \gvService{S}}{\gvRequest{s}}{S}}
%% \end{mathpar}


\newpage

\section{From GV to CP}
~

Session types
\begin{equations}
\gvtocp{\gvOutput{T}{S}}        &=& \cpPar{\cpDual{\gvtocp{T}}}{\gvtocp{S}} \\
\gvtocp{\gvInput{T}{S}}         &=& \cpTimes{\gvtocp{T}}{\gvtocp{S}} \\
\gvtocp{\gvPlus{\la_i:S_i}{i}}   &=& \cpWith{\la_i:\gvtocp{S_i}}{i} \\
\gvtocp{\gvChoice{\la_i:S_i}{i}} &=& \cpPlus{\la_i:\gvtocp{S_i}}{i} \\
\gvtocp{\gvEndOutput}              &=& \cpBottom \\
\gvtocp{\gvEndInput}               &=& \cpOne \\[1ex]

\gvtocp{X}                       &=& X \\
\gvtocp{\gvOutputType{X}{S}}     &=& \cpForall{X}{\gvtocp{S}} \\
\gvtocp{\gvInputType{X}{S}}      &=& \cpExists{X}{\gvtocp{S}} \\[1ex]

\gvtocp{\gvServer{S}}  &=& \cpWhyNot{\gvtocp{S}} \\
\gvtocp{\gvService{S}} &=& \cpOfCourse{\gvtocp{S}} \\[1ex]
\end{equations}

Non-session types
\begin{equations}
\gvtocp{\gvLinFun{T}{U}} &=& \cpPar{\cpDual{\gvtocp{T}}}{\gvtocp{U}} \\
\gvtocp{\gvUnFun{T}{U}} &=& \cpOfCourse{(\cpPar{\cpDual{\gvtocp{T}}}{\gvtocp{U}})} \\
\gvtocp{\gvTimes{T}{U}} &=& \cpTimes{\gvtocp{T}}{\gvtocp{U}} \\
\gvtocp{\gvUnitType} &=& \cpOfCourse{(\cpWith{}{})} \\
\end{equations}

Terms
\begin{equations}
\gvtocp{\gvSendType{S}{(M : \cpForall{X}{S'})}}z &=&
  \cpCut{(x:\cpExists{X}{\cpDual{\gvtocp{S'}}})}{\cpSendType{x}{\gvtocp{S}}{\cpLink{x}{z}}}{\gvtocp{M}x} \\
\gvtocp{\gvReceiveType{(M : \cpExists{X}{S'})}}z &=&
  \cpCut{(x:\cpForall{X}{\cpDual{\gvtocp{S'}}})}{\cpReceiveType{x}{X}{\cpLink{x}{z}}}{\gvtocp{M}x} \\
\\[1ex]
\gvtocp{\gvLink{M}{N}}z &=& \cpCut{x}{\gvtocp{M}x}{\cpCut{y}{\gvtocp{N}y}{\cpEmptyIn{z}{\cpLink{x}{y}}}} \\
\gvtocp{\gvServeOld{s}{x}{M}}z &=&
  \cpEmptyIn{z}
            {\cpServe{s}{x}
                     {\cpCut{y}{\cpEmptyOut{y}}{\gvtocp{M}y}}} \\
\gvtocp{\gvRequest{s}}z &=& \cpRequest{s}{x}{\cpLink{x}{z}} \\
\end{equations}

Judgements
\begin{equations}
\gvtocp{\gvj{\Phi}{M}{T}} &=& \cpj{\gvtocp{M}z}{\cpDual{\gvtocp{\Phi}}, z:\gvtocp{T}}
\end{equations}


%% Theorem:

%%   [[((A))]] = ~A
%%   [[((P |- G))]] = Q |- G, z : bot
%%     where nu z.(z[].0|Q) --> P

%%   (([[S]])) = ~S
%%   (([[Phi |- M : S]] z)) = Phi |- N : end!
%%     where
%%       nu w.(w[].0|[[N]]w) --> [[M]]z

\section{Alternative translations from GV to CP}

\subsection{Dualising the interpretation of judgements}

It is possible to avoid the dualisation of session types in the type
translation by dualising the interpretation of judgements.

Judgements
\begin{equations}
\gvtocps{\gvj{\Phi}{M}{T}} &=& \cpj{\gvtocp{M} z}{\gvtocps{\Phi}, z:\cpDual{(\gvtocps{T})}}
\end{equations}

Session types
\begin{equations}
\gvtocps{\gvOutput{T}{S}}        &=& \cpTimes{\cpDual{\gvtocps{T}}}{\gvtocps{S}} \\
\gvtocps{\gvInput{T}{S}}         &=& \cpPar{\gvtocps{T}}{\gvtocps{S}} \\
\gvtocps{\gvPlus{\la_i:S_i}{i}}   &=& \cpPlus{\la_i:\gvtocps{S_i}}{i} \\
\gvtocps{\gvChoice{\la_i:S_i}{i}} &=& \cpWith{\la_i:\gvtocps{S_i}}{i} \\
\gvtocps{\gvEndOutput}              &=& \cpOne \\
\gvtocps{\gvEndInput}               &=& \cpBottom \\[1ex]

\gvtocps{\gvServer{S}}  &=& \cpOfCourse{\gvtocps{S}} \\
\gvtocps{\gvService{S}} &=& \cpWhyNot{\gvtocps{S}} \\[1ex]
\end{equations}


The idea is that the term translation stays exactly the same. This
approach fits with the view of $z$ as a negative continuation
parameter. It yields a straightforward interpretation of session
types, but then the interpretation of non-session types (linear
functions, unrestricted functions, tensor, and unit), becomes dual to
what one would normally expect.

Non-session types
\begin{equations}
\gvtocps{\gvLinFun{T}{U}} &=& \cpTimes{\gvtocp{T}}{\cpDual{\gvtocp{U}}} \\
\gvtocps{\gvUnFun{T}{U}} &=& \cpWhyNot{(\cpTimes{\gvtocp{T}}{\cpDual{\gvtocp{U}}})} \\
\gvtocps{\gvTimes{T}{U}} &=& \cpPar{\cpDual{\gvtocp{T}}}{\cpDual{\gvtocp{U}}} \\
\gvtocps{\gvUnitType} &=& \cpWhyNot{(\cpPlus{}{})} \\
\end{equations}

\subsection{Adapting the translation on terms}

As an alternative to dualising the interpretation of non-session
types, we can attempt to keep the standard interpretation of
non-session types and instead adapt the translation on terms.

Judgements
\begin{equations}
\gvtocpd{\gvj{\Phi}{M}{T}} &=& \cpj{\gvtocpd{M} z}{\gvtocpd{\Phi}, z:{\gvtocpd{T}}}
\end{equations}

This looks like it might work if we add the Mix rule to CP along with
another rule which can be derived from BiCut, but which appears to
be weaker.

\begin{mathpar}
\inferrule
{\cpj{P}{\G, y:A, z:C} \\ \cpj{Q}{\D, x:B, z:\cpDual{C}}}
{\cpj{\cpCutOutput{z}{x}{y}{P}{Q}}{\G, \D, x : \cpTimes{A}{B}}}
\end{mathpar}

%%   [[
%%   Phi |- L : T -o U  un(Phi)
%%   --------------------------
%%   Phi |- L : T -> U
%%   ]] z
%% =
%%   [[L]]y |- [[Phi]], y:~[[T -o U]]
%%   --------------------------------------------
%%   ?z[y].[[L]]y |- [[Phi]], z:?(~[[T -o U]])

%%   [[
%%   Phi |- L : T -> U
%%   -----------------
%%   Phi |- L : T -o U
%%   ]] z
%% =
%%                                            x <-> z |- x:[[T -o U]], z:~([[T -o U]])
%%                                         ---------------------------------------------------
%%   [[L]]y |- [[Phi]], y:?(~[[T -o U]])   !y(x).x <-> z |- y:!([[T -o U]]), z:~([[T -o U]])
%%   ------------------------------------------------------------------------------------------
%%   nu y.([[L]]y | !y(x).x <-> z) |- [[Phi]], z:~[[T -o U]]
%%
%% Oops! z can't appear inside the server output!


%% z : [[T]] * ~[[U]]
%% [[\x.M]]z = nu y.z[x].([[M]]y | y <-> z)
%% [[\x.M]]z = nu y x.([[M]]y | z[w].(w <-> x | y <-> z))

%% z : ~[[U]]
%% [[L M]]z = nu y.([[L]]y | y(x).([[M]]x | y <-> z))

%% z : ~[[T]] || ~[[U]]
%% [[(M, N)]]z = z(x).([[M]]x | [[N]]z)

%% z : ~[[V]]
%% [[let (x,y)=M in N]]z = nu w.([[M]]w | nu y.w[x].([[N]]z | w <-> y))

%% Cutting an output with a private channel against an input with a
%% mix would appear to yield a term containing a plain bicut and a mix

%%    nu x.(x[y].nu z.(P | Q) | x(y).(R | S))
%%  -->
%%    nu y z.(P | nu x.(Q | (R | S)))


Non-session terms
\begin{equations}
\gvtocpd{\lambda x:T.M}z &=&
  \cpCutOutput{y:{\cpDual{\gvtocpd{U}}}}{z}{x:{\gvtocpd{T}}}
              {\gvtocpd{M}y}{\cpLink{y}{z}} \\
\gvtocpd{L~M}z &=&
  \cpCut{y:\cpTimes{\gvtocpd{T}}{\cpDual{\gvtocpd{U}}}}
        {\gvtocpd{L}y}
        {\cpInput{y}{x:\cpDual{\gvtocpd{U}}}{\cpMix{\gvtocpd{M}x}{\cpLink{y}{z}}}} \\
\gvtocpd{\gvPair{M}{N}}z &=&
  \cpInput{z}{x:\cpDual{\gvtocpd{T}}}{\cpMix{\gvtocpd{M}x}{\gvtocpd{N}z}} \\
\gvtocpd{\gvLet{\gvPair{x}{y}}{M}{N}}z &=&
  \cpCut{w:\cpPar{\cpDual{\gvtocpd{T}}}{\cpDual{\gvtocpd{U}}}}
    {\gvtocpd{M}w}
    {\cpCutOutput{y:\gvtocpd{U}}{w}{x:\gvtocpd{T}}{\gvtocpd{N}z}{\cpLink{w}{y}}} \\
\end{equations}

Where this approach seems to completely break down is in the
translation of the elimination rule for unrestricted functions. We
might reasonably hope to simulate linear lambdas using output rather
than input, but it seems unreasonable to expect to simulate
unrestricted lambda application using a linear server rather than an
unrestricted client.

\subsection{Compiling away non-session types}

Another option is to compile away non-session types in GV as a
pre-processing step, where the type translation is given by
$\cptogv{\gvtocp{-}}$ and the term translation by
$\cptogv{\gvtocp{-}z}$.

%% T -o U --> ~[[T]] || [[U]] --> ?~T*.U*
%% T -> U --> !(~[[T]] || [[U]]) --> $(?~T*.U*)
%% T * U --> [[T]] * [[U]] --> !~T*.U*
%% Unit --> !&{} --> $&{}

%% Hmmm... Looks like things are the wrong way round in the GV to CP
%% translation: input types should be negated and output types
%% should't.

We could simply compose the translations as described, but then it
would seem that we would have to perform a global CPS transformation
on all terms including the session typing constructs. This would be
rather disappointing, as then we would appear to have to effectively
perform a CPS transformation twice on such terms in order to generate
a CP term.

% channel passing translation
\newcommand{\gvtogv}[1]{({#1})^\star}

We can do better, though, by performing a local transformation. The
key observation is that we can locally abstract over the continuation
channel $z$ in a term $M$ using $\gvWith{z}{M}{z}$.

This is where the dualisation of types arises: the type of the whole
expression must be dual to the type of $z$ in $M$. For instance, we
implement a lambda of type $\gvLinFun{T}{U}$ with a channel $z$ of
type $\gvInput{\gvDual{\gvtogv{T}}}{\gvtogv{U}}$, but the interface to
the lambda is the other end of the channel $z$ which has type
$\gvOutput{\gvtogv{T}}{\gvDual{\gvtogv{U}}}$ (and application becomes
simply sending the argument along this channel).

\begin{equations}
\gvtogv{\gvLinFun{T}{U}} &=& \gvOutput{\gvtogv{T}}{\gvDual{\gvtogv{U}}} \\
\gvtogv{\gvUnFun{T}{U}} &=& \gvService{(\gvOutput{\gvtogv{T}}{\gvDual{\gvtogv{U}}})} \\
\gvtogv{\gvTimes{T}{U}} &=& \gvInput{\gvtogv{T}}{\gvDual{\gvtogv{U}}} \\
\gvtogv{\gvUnitType} &=& \gvService{(\gvPlus{}{})} \\
\end{equations}%

\begin{equations}
\gvtogv{\gvj{\Phi}{M}{T}} &=& \gvj{\gvtogv{\Phi}}{\gvtogv{M}}{\gvtogv{T}} \\
\end{equations}%

\begin{equations}
\gvtogv{\gvLam{x}{M}} &=& \gvWith{z}{\gvLet{\gvPair{x}{z}}{\gvReceive{z}}{\gvLink{\gvtogv{M}}{z}}}{z} \\
\gvtogv{\gvApp{L}{M}} &=& \gvSend{\gvtogv{M}}{\gvtogv{L}} \\
\gvtogv{\gvTimes{M}{N}} &=&
  \gvWith{z}
    {\gvLink{(\gvSend{\gvtogv{M}}{z})}{\gvtogv{N}}}
    {z} \\
\gvtogv{\gvLet{\gvPair{x}{y}}{M}{N}} &=&
    \gvLet{\gvPair{x}{y}}{\gvReceive{\gvtogv{M}}}{\gvtogv{N}} \\
\gvtogv{\gvReceive{M}} &=& M \\
\gvtogv{\gvUnit} &=&
    \gvWith{z}
    {\gvServeOld{z}{x}{\gvCase{x}{\row{}{}}}}
    {z} \\
%% Unnecessary as we don't have a linear unit!
%%
%% \gvtogv{\gvLet{\gvUnit}{M}{N}} &=&
%%   \gvLet{z}{\gvtogv{M}}{\gvtogv{N}} \\
\gvtogv{L : \gvUnFun{T}{U}} &=&
  \gvWith{z}{\gvServeOld{z}{y}{\gvLink{\gvtogv{L}}{y}}}{z} \\
\gvtogv{L : \gvLinFun{T}{U}} &=& \gvRequest{\gvtogv{L}} \\
\end{equations}

A problem we run into is that $\gvReceive{M}$ has tensor type, and yet
our translation is supposed to compile away non-session types,
including tensors. Similarly, $\gvTerminate{M}$ has unit type. The
problem illustrates an irregularity in GV. All of the typing rules for
the other session typing constructs mention only session types.

Dealing with $\key{terminate}$ is easy. We just amend our target
language such that $\gvTerminate{M}$ has type
$\gvService{(\gvPlus{}{})}$, the interpretation of the unit type.
%
Dealing with $\key{receive}$ is a little harder. We still need some
way of binding the two values returned by $\key{receive}$. The
solution is to fuse $\key{receive}$ with the pair elimination
construct. Notice that this is more or less what CP server input does
already. Because we interpret $\gvTimes{T}{U}$ as
$\gvInput{\gvtogv{T}}{\gvDual{\gvtogv{U}}}$, instances of
$\key{receive}$ from the source term are all erased. The only
instances of $\key{receive}$ in the target term arise from
interpreting lambdas and pair elimination. This may seem strange until
one considers that the only way to use the pair resulting from a
$\key{receive}$ in GV is to eliminate it. The transformation shunts
each receive up to the point at which the resulting pair is
eliminated.

\begin{mathpar}
\inferrule
  {\gvj{\Phi}{M}{\gvEndInput}}
  {\gvj{\Phi}{\gvTerminate{M}}{\gvService{(\gvPlus{}{})}}}

\inferrule
  {\gvj{\Phi}{M}{\gvInput{T}{S}} \\ \gvj{\Psi, x:T, y:S}{N}{U}}
  {\gvj{\Phi, \Psi}{\gvLet{\gvPair{x}{y}}{\gvReceive{M}}{N}}{U}}
\end{mathpar}

Another alternative is to get rid of terminate altogether and change
$\gvEndInput$ to be an unrestricted session type. Correspondingly, we
could also interpret the unit type as $\gvEndInput$ and $\gvUnit$ as
$\gvWith{x}{x}{x}$. Making $\gvEndInput$ unrestricted makes sense as
$\gvEndInput = \cptogv{\cpBottom}$, and weakening and contraction are
derivable for $\cpBottom$ in CP.

\newpage

%------------------------------------------------------------------------------
%% \appendix

%------------------------------------------------------------------------------
% Index
%\printindex

%------------------------------------------------------------------------------
\end{document}

Composing the translations

(([[T -o U]])) = ?~(([[T]])).(([[U]]))
(([[T * U]])) = !(([[T]])).(([[U]]))




\x.M --> ((z(x).[[M]]z))  --> let (x,z)=receive z in (([[M]]z))
[[L M]]z --> nu y.([[L]]y | y[x].([[M]]x | y <-> z)) -->
       with y connect
         (([[L]]y))
       to
         with x connect
           (([[M]]x))
         to
           let y=send x y in link y z
(M,N) --> z[y].([[M]]y | [[N]]z) --> with y connect (([[M]]y)) to let z = send y z in (([[N]]z))
let (x, y) = M in N
   --> nu y.([[M]]y | y(x).[[N]]z)
   --> with y connect
         (([[M]]y))
       to
         let (x, y) = receive y in (([[N]]z))

Phi |- L : T -o U  un(Phi)
--------------------------
Phi |- L : T -> U
  --> !z(y).[[L]]y
  --> serve z(y) = (([[L]]y))

Phi |- L : T -> U
-----------------
Phi |- L : T -o U
  --> nu y.([[L]]y | ?y[x].x <-> z)
  --> with y connect
        (([[L]]z))
      to
        with x connect link (request y) x to link x z
  ==
     with y connect
       (([[L]]z))
     to
       link (request y) z

A problem is that we appear to have to CPS transform everything
globally - including the session typing constructs. For instance:

send M N --> nu x.(x[y].([[M]]y | x <-> z) | [[N]]x)
         --> with x connect
               with y connect
                 (([[M]]y))
               to
                 let x = send y x in link x z
             to
               (([[N]]))x

send (\v.v) w -->
    with x connect
      with y connect
        let (v,y) = receive y in link v y
      to
        let x = send y x in link x z
    to
      link w x
  ==
    with y connect
      let (v,y) = receive y in link v y
    to
      let w = send y w in link w z

If we do this as a pre-processing step, then we effectively end up
doing a CPS transformation twice! Can we do some kind of local CPS
transformation:

send (\v.v) w -->
    with y connect
      let (v,y) = receive y in link v y
    to
      send y w
  ==
    send
      (with y connect
        let (v,y) = receive y in link v y
       to
         y)
    w


let syntactic sugar after translating away lambdas:

  let x = M in N
  ==
  send M (with z connect let (x,z)=receive z in link N z to z)



Attempting to undualise the GV to CP translation on types

[[T -o U]] = [[~T || U]]

z : [[T]] * ~[[U]]
[[\x.N]]z = nu y:[[U]].z[x].([[N]]y|y <-> z)



P |- x : A, y : B
----------------------------------------------------
y[x].(P | nu r s.(r <-> x | s <-> y))) |- y : A * B


P |- x : A, x : C     Q |- x : ~C, y : B
----------------------------------------
     nu x.y[z].(P | Q) |- y : A * B

z : ~[[U]]
[[L M]]z = nu y.([[L]]y | y(x).([[M]]x | y <-> z))



y(x).x().y <->z  |- y : bot || 1, z:bot

y(x).y <->z  |- y : 1 || 1, z:bot


[[L]]y |- [[Phi]],y:[[T]]*~[[U]]   ? |- [[Psi]],y:~[[T]] || [[U]],z:~[[U]]
--------------------------------------------------------------------------
? |- [[Phi]],[[Psi]],z:~[[U]]



P |- G,x:~A

? |- G,x:~A,y:B,z:~B
----------------------------------
y(x).? |- y:~A || B,z:~B

z : ~[[T]] || ~[[U]]
[[(M, N)]]z = z(x).([[M]]x || [[N]]z)


x(y).x(z).x().y <-> z |- x:1||(bot || bot)



nu y1 : !top * !top . (foo <-> y1 |  y1(x2).!z0(y3).y3.case(){}) |- foo : ~(!top * !top),z0:!top


  foo : ?#+{}.#+{}, z0 : $&{}
|-
  with y1 : !#+{}.$&{}
  connect
    link foo y1
  to
    let (x2, y1)=receive y1 in serve z0 (y3)=case y3 of {}
: end!


((!top*!top)) = !~((!top)).((!top)) = !#+{}.$&{}

foo : ?#+{}.#+{}, z0 : $&{} |- with y1 : !#+{}.$&{} connect link foo y1 to let (x2, y1)=receive y1 in serve z0 (y3)=case y3 of {} : end!

New version of terminate:

[[terminate M]](z : !top) = nu (x:1).([[M]]x|x().!z(y).y.case())

Let unit:

[[ let () = m in n ]]z = [[ (\().n)m ]] z
  = nu y.(y(x).[[n]]y | y[x].([[m]]x | y <-> z))
  = nu x.(nu y.([[n]]y | y <-> z) | [[m]]x)
  = nu x.([[m]]x | [[n]]z)

Rules for sendType and receiveType

G |- M : ??X.S'
---------------------------
G |- sendType S M : S'[S/X]

G |- M : !!X.S'   X notin FV(G)
-------------------------------
G |- receiveType M : S'

[[sendType S M]](z : S'[S/X]) = nu (x:exists X.[[S']]).(x[S].x <-> z | [[M]]x)
[[receiveType M]](z : S')     = nu.(x:forall X.[[S']]).(x(X).x <-> z | [[M]]x)
