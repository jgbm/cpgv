% -*- fill-column: 100 -*-

% easychair.tex,v 3.2 2012/05/15
%
% Select appropriate paper format in your document class as
% instructed by your conference organizers. Only withtimes
% and notimes can be used in proceedings created by EasyChair
%
% The available formats are 'letterpaper' and 'a4paper' with
% the former being the default if omitted as in the example
% below.
%
\documentclass{easychair}
%\documentclass[debug]{easychair}
%\documentclass[verbose]{easychair}
%\documentclass[notimes]{easychair}
%\documentclass[withtimes]{easychair}
%\documentclass[a4paper]{easychair}
%\documentclass[letterpaper]{easychair}

% This provides the \BibTeX macro
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{color}
\usepackage{doc}
\usepackage{makeidx}
\usepackage{stmaryrd}
\usepackage{mathpartir}
\usepackage{xspace}

% In order to save space or manage large tables or figures in a
% landcape-like text, you can use the rotating and pdflscape
% packages. Uncomment the desired from the below.
%
% \usepackage{rotating}
% \usepackage{pdflscape}

% If you plan on including some algorithm specification, we recommend
% the below package. Read more details on the custom options of the
% package documentation.
%
% \usepackage{algorithm2e}


%%% macros

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}

\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}

\newcommand{\bl}{\ba{@{}c@{}}}
\newcommand{\el}{\ea}

\newenvironment{equations}{\[\ba{@{}r@{~}c@{~}l@{}}}{\ea\]}
\newenvironment{eqs}{\ba{@{}r@{~}c@{~}l@{}}}{\ea}



\newcommand{\key}{\mathsf}

\newcommand{\set}[1]{\{ #1 \}}


\newcommand{\gvtocp}[1]{\llbracket{#1}\rrbracket}
\newcommand{\cptogv}[1]{\llparenthesis{#1}\rrparenthesis}

\newcommand{\row}[2]{\set{#1}_{#2}}

\newcommand{\gvOutput}[2]{\mathord{!}{#1}.{#2}}
\newcommand{\gvInput}[2]{\mathord{?}{#1}.{#2}}
\newcommand{\gvEndOutput}{\key{end}_!}
\newcommand{\gvEndInput}{\key{end}_?}
\newcommand{\gvPlus}[2]{\oplus \row{#1}{#2}}
\newcommand{\gvChoice}[2]{\binampersand \row{#1}{#2}}
\newcommand{\gvServer}[1]{\flat {#1}}
\newcommand{\gvService}[1]{\sharp {#1}}
\newcommand{\gvDual}[1]{\overline{#1}}
\newcommand{\gvOutputType}[2]{![{#1}].{#2}}
\newcommand{\gvInputType}[2]{?[{#1}].{#2}}

\newcommand{\cpj}[2]{{#1} \vdash {#2}}
\newcommand{\gvj}[3]{{#1} \vdash {#2} : {#3}}

\newcommand{\la}{l}
\newcommand{\G}{\Gamma}
\newcommand{\D}{\Delta}

\newcommand{\lolli}{\multimap}

\newcommand{\gvLinFun}[2]{{#1} \lolli {#2}}
\newcommand{\gvUnFun}[2]{{#1} \to {#2}}
\newcommand{\gvTimes}[2]{{#1} \otimes {#2}}
\newcommand{\gvUnitType}{\key{Unit}}

\newcommand{\gvUnit}{\key{unit}}
\newcommand{\gvLink}[2]{\key{link}~{#1}~{#2}}
\newcommand{\gvLam}[2]{\lambda {#1}.{#2}}
\newcommand{\gvApp}[2]{{#1}~{#2}}
\newcommand{\gvPair}[2]{({#1},{#2})}
\newcommand{\gvLet}[3]{\key{let}~{#1}={#2}~\key{in}~{#3}}
\newcommand{\gvSend}[2]{\key{send}~{#1}~{#2}}
\newcommand{\gvReceive}[1]{\key{receive}~{#1}}
\newcommand{\gvSelect}[2]{\key{select}~{#1}~{#2}}
\newcommand{\gvCase}[2]{\key{case}~{#1}~\key{of}~{#2}}

\newcommand{\gvFork}[2]{\key{fork}~{#1}.{#2}}

\newcommand{\gvWith}[3]{\key{with}~{#1}~\key{connect}~{#2}~\key{to}~{#3}}
\newcommand{\gvTerminate}[1]{\key{terminate}~{#1}}


% receive with continuation
\newcommand{\gvReceiveK}[4]{\gvLet{\gvPair{#1}{#2}}{\gvReceive{#3}}{#4}}

\newcommand{\gvSendType}[2]{\key{sendType}~{#1}~{#2}}
\newcommand{\gvReceiveType}[2]{\key{receiveType}~{#1}.{#2}}


\newcommand{\gvServeOld}[3]{\key{defServer}~{#1}({#2})={#3}}

\newcommand{\gvServe}[2]{\key{serve}~{#1}.{#2}}
\newcommand{\gvRequest}[1]{\key{request}~{#1}}

\newcommand{\cpLink}[2]{{#1} \leftrightarrow {#2}}
\newcommand{\cpCut}[3]{\nu {#1}.({#2} \mid {#3})}
\newcommand{\cpOutput}[4]{{#1}[{#2}].({#3} \mid {#4})}
\newcommand{\cpInput}[3]{{#1}({#2}).{#3}}
\newcommand{\cpInject}[3]{{#1}[{#2}].{#3}}
\newcommand{\cpCase}[2]{{#1}.\key{case}~{#2}}
\newcommand{\cpServe}[3]{!{#1}({#2}).{#3}}
\newcommand{\cpRequest}[3]{?{#1}[{#2}].{#3}}
\newcommand{\cpEmptyOut}[1]{{#1}[].0}
\newcommand{\cpEmptyIn}[2]{{#1}().{#2}}
\newcommand{\cpSendType}[3]{{#1}[{#2}].{#3}}
\newcommand{\cpReceiveType}[3]{{#1}({#2}).{#3}}


\newcommand{\cpTimes}[2]{{#1} \otimes {#2}}
\newcommand{\cpPar}[2]{{#1} \mathbin{\bindnasrepma} {#2}}
\newcommand{\cpPlus}[2]{\oplus \row{#1}{#2}}
\newcommand{\cpWith}[2]{\binampersand \row{#1}{#2}}
\newcommand{\cpOne}{1}
\newcommand{\cpBottom}{\bot}
\newcommand{\cpOfCourse}[1]{\mathord{!}{#1}}
\newcommand{\cpWhyNot}[1]{\mathord{?}{#1}}
\newcommand{\cpDual}[1]{{#1}^\bot}
\newcommand{\cpExists}[2]{\exists {#1}.{#2}}
\newcommand{\cpForall}[2]{\forall {#1}.{#2}}

\newcommand{\cpZero}{0}    % 0   == +{}
\newcommand{\cpTop}{\top}  % top == &{}

\newcommand{\un}[1]{\mathit{un}(#1)}
\newcommand{\lin}[1]{\mathit{lin}(#1)}

\newcommand{\FV}[1]{\mathit{FV}(#1)}
\newcommand{\subst}[3]{{#1}[{#2}/{#3}]}

\newcommand{\gvtocps}[1]{\gvtocp{#1}}
\newcommand{\gvtocpd}[1]{\gvtocp{#1}}

\newcommand{\cpMix}[2]{({#1} \mid {#2})}
\newcommand{\cpCutOutput}[5]{{#2}[{#3}].\nu{#1}.\cpMix{#4}{#5}}

\newcommand{\last}{LAST\xspace}

\newcommand{\hgv}{HGV\xspace}
\newcommand{\hgvpi}{HGV$\pi$\xspace}

\newcommand{\lampi}[1]{({#1})^\star}
\newcommand{\hgvcp}[1]{\llbracket{#1}\rrbracket}

\newcommand{\hgvcpl}{\left\llbracket}
\newcommand{\hgvcpr}{\right\rrbracket}

\newcommand{\redto}{\longrightarrow}
\newcommand{\eqto}{\equiv}

%\newcommand{\infr}[3][]{\inferrule*[right={#1}]{#2}{#3}}
%\newcommand{\infr}[3][]{\inferrule[#1]{#2}{#3}}
\newcommand{\infr}[3][]{\inferrule{#2}{#3}} % save space by getting rid of labels

\newcommand{\todo}[1]{\textbf{\color{red}TODO: #1}}

%\makeindex

%% Document
%%
\begin{document}

\title{Sessions as propositions}
\titlerunning{Sessions as propositions}

\author{
  Sam Lindley
  \and
  J. Garrett Morris
}

\institute{The University of Edinburgh \\
  \email{\{Sam.Lindley,Garrett.Morris\}@ed.ac.uk}
}

\authorrunning{Lindley and Morris}

\clearpage

\maketitle


\begin{abstract}
  Recently, Wadler presented a continuation-passing translation from a session-typed functional
  language, GV, to a process calculus based on classical linear logic, CP. However, this translation
  is one-way: CP is more expressive than GV. We propose an extension of GV, called \hgv, and give
  translations showing that it is as expressive as CP. The new translations shed light both on the
  original translation from GV to CP, and on the limitations in expressiveness of GV.
\end{abstract}

\section{Introduction}
\label{sect:introduction}

Linear logic has long been regarded as a potential typing discipline for concurrency.
Girard~\cite{Girard87} observes that the connectives of linear logic can be interpreted as parallel
computation. Abramsky~\cite{Abramsky92} and Bellin and Scott~\cite{BellinScott94} interpret linear
logic proofs as processes in Milner's $\pi$-calculus. While they provide $\pi$-calculus
interprations of all linear logic proofs, they do not provide a proof-theoretic interpretation for
arbitrary $\pi$-calculus terms. Caires and Pfenning~\cite{CairesPfenning10} observe that the
multiplicative connectives can be interpreted as session types. Their process calculus, based on
intuitionistic linear logic, is closer to $\pi$-calculus than are traditional session-typed
languages. Wadler~\cite{Wadler12} shows that a core session-typed linear functional language, GV,
patterned after a similar language due to Gay and Vasconcelos~\cite{GayVasconcelos10}, may be
translated into a process calculus, CP, whose terms are proofs in classical linear logic.  However,
GV is less expressive than CP: there are proofs which do not correspond to any GV program.

Our primary contribution is \hgv (Harmonious GV), a version of GV extended with constructs for
session forwarding, replication, and polymorphism. We identify \hgvpi, the session-typed fragment of
\hgv, and give a type-preserving translations from \hgv to \hgvpi ($\lampi{-}$); this translation
depends crucially on the new constructs of \hgv.  We show that \hgv is sufficient to express all
linear logic proofs by giving type-preserving translations from \hgvpi to CP ($\hgvcp{-}$), and from
CP to \hgvpi ($\cptogv{-}$). Factoring the translation of \hgv into CP through $\lampi{-}$
simplifies the presentation, and illuminates regularities that are not apparent in Wadler's original
translation of GV into CP.  Finally, we show that \hgv, \hgvpi, and CP are all equally expressive.

%%  We have implemented prototypes for all of these languages.


%% %To demonstrate \hgv's expressiveness,
%% We give both a direct translation from CP into \hgv and extend Wadler's continuation-passing
%% translation from GV into CP to one from \hgv into CP.

%% As CP only describes process communication, our translation maps all of CP into the session-oriented
%% fragment of HGV (which we call \hgvpi), avoiding the functional features of \hgv entirely. Thus, by
%% composing the translation from \hgv to CP with that from CP to \hgvpi, we can obtain a translation
%% of the functional features of \hgv into their process counterparts
%% %%
%% %% Because the translation from \hgv to CP is continuation-passing, the composed translation from \hgv
%% %% into \hgvpi is also continuation-passing.
%% %%
%% As an alternative approach, we give a direct translation from \hgv to \hgvpi. Our translations
%% illustrate several points. First, they show the increased expressivity of \hgv: as GV's session
%% types contains no notion of replication or recursion, they cannot express the non-linear features of
%% its functional fragment; \hgv, in contrast, can be reduced to \hgvpi. Second, factoring the
%% translation of \hgv into CP over that from \hgv into \hgvpi simplifies the translation, and
%% illuminates regularities that are not apparent in Wadler's original translation.

\section{The \hgv Language}
\label{sect:hgv}

This section describes our session-typed language \hgv, constrasting it with Gay and Vasconcelos's
functional language for asynchronous session types~\cite{GayVasconcelos10}, which we call \last, and
Wadler's GV~\cite{Wadler12}.  In designing \hgv, we have opted for programming convenience over
uniformity, while insisting on a tight correspondence with linear logic.
%
The session types of \hgv are given by the following grammar:
\begin{equations}
  S & ::= & \gvOutput{T}{S} \mid \gvInput{T}{S} \mid
           \gvPlus{\la_i:S_i}{i} \mid \gvChoice{\la_i:S_i}{i} \mid
           \gvEndOutput \mid \gvEndInput
    \mid X \mid \gvDual{X} \mid
            \gvOutputType{X}{S} \mid \gvInputType{X}{S} \mid
            \gvServer{S} \mid \gvService{S}
\end{equations}%
Types for input ($\gvInput{T}{S}$), output ($\gvOutput{T}{S}$), selection ($\gvPlus{\la_i:S_i}{i}$)
and choice ($\gvChoice{\la_i:S_i}{i}$) are standard. Like GV, but unlike \last, we distinguish
output ($\gvEndOutput$) and input ($\gvEndInput$) session ends; this matches the situation in linear
logic, where there is no conveniently self-dual proposition to represent the end of a
session. Variables and their duals ($X,\gvDual{X}$) and type input ($\gvInputType{X}{S}$) and output
($\gvOutputType{X}{S}$), permit definition of polymorphic sessions. We include a notion of
replicated sessions, corresponding to exponentials in linear logic: a channel of type
$\gvService{S}$ is a ``service'', providing any number of channels of type $S$; a channel of type
$\gvServer{S}$ is the ``server'' providing such a service.
%
Each session type $S$ has a dual $\gvDual{S}$ (with the obvious dual for variables $X$):
\[
\bl
  \gvDual{\gvOutput{T}{S}} = \gvInput{T}{\gvDual{S}}
\qquad
  \gvDual{\gvPlus{\la_i:S_i}{i}} = \gvChoice{\la_i:\gvDual{S_i}}{i}
\qquad
  \gvDual{\gvEndOutput} = \gvEndInput
\qquad
  \gvDual{\gvOutputType{X}{S}} = \gvInputType{X}{\gvDual{S}}
\qquad
  \gvDual{\gvService{S}} = \gvServer{\gvDual{S}}
\\
  \gvDual{\gvInput{T}{S}} = \gvOutput{T}{\gvDual{S}}
\qquad
  \gvDual{\gvChoice{\la_i:S_i}{i}} = \gvPlus{\la_i:\gvDual{S_i}}{i}
\qquad
  \gvDual{\gvEndInput} = \gvEndOutput
\qquad
  \gvDual{\gvInputType{X}{S}} = \gvOutputType{X}{\gvDual{S}}
\qquad
  \gvDual{\gvServer{S}} = \gvService{\gvDual{S}}
\\
\el
\]
Note that dualisation leaves input and output types unchanged.  In addition to sessions, \hgv's
types include linear pairs, and linear and unlimited functions:
\[
T,U,V ::= S \mid \gvTimes{T}{U} \mid \gvLinFun{T}{U} \mid \gvUnFun{T}{U}
\]
%
Every type $T$ is either linear ($\lin{T}$) or unlimited ($\un{T}$); the only unlimited types are
services ($\un{\gvService{S}}$), unlimited functions ($\un{\gvUnFun{T}{U}}$), and end input session
types ($\un{\gvEndInput}$).
%
In GV, $\gvEndInput$ is linear. We choose to make it unlimited in \hgv because then we can dispense
with GV's explicit $\key{terminate}$ construct while maintaining a strong correspondence with
CP---$\gvEndInput$ corresponds to $\cpBottom$ in CP, for which weakening and contraction are
derivable.

\begin{figure}
\begin{mathpar}
\infr[Id]
{ }
{\gvj{x:T}{x}{T}}

\infr[Weaken]
{\gvj{\Phi}{N}{U} \\ \un{T}}
{\gvj{\Phi,x:T}{N}{U}}

\infr[Contract]
{\gvj{\Phi,x:T,x':T}{N}{U} \\ \un{T}}
{\gvj{\Phi,x:T}{\subst{N}{x}{x'}}{U}}
\end{mathpar}%
\hrule
\begin{mathpar}
\infr[$\lolli$-I]
{\gvj{\Phi,x:T}{N}{U}}
{\gvj{\Phi}{\gvLam{x}{N}}{\gvLinFun{T}{U}}}

\infr[$\lolli$-E]
{\gvj{\Phi}{L}{\gvLinFun{T}{U}} \\ \gvj{\Psi}{M}{T}}
{\gvj{\Phi,\Psi}{\gvApp{L}{M}}{U}}

\infr[$\to$-I]
{\gvj{\Phi}{L}{\gvLinFun{T}{U}} \\ \un{\Phi}}
{\gvj{\Phi}{L}{\gvUnFun{T}{U}}}

\infr[$\to$-E]
{\gvj{\Phi}{L}{\gvUnFun{T}{U}}}
{\gvj{\Phi}{L}{\gvLinFun{T}{U}}}

\infr[$\otimes$-I]
{\gvj{\Phi}{M}{T} \\ \gvj{\Psi}{N}{U}}
{\gvj{\Phi,\Psi}{\gvPair{M}{N}}{\gvTimes{T}{U}}}

\infr[$\otimes$-E]
{\gvj{\Phi}{M}{\gvTimes{T}{U}} \\ \gvj{\Psi,x:T,y:U}{N}{V}}
{\gvj{\Phi,\Psi}{\gvLet{\gvPair{x}{y}}{M}{N}}{V}}
\end{mathpar}%
\hrule
\begin{mathpar}
\infr[Send]
{\gvj{\Phi}{M}{T} \\ \gvj{\Psi}{N}{\gvOutput{T}{S}}}
{\gvj{\Phi}{\gvSend{M}{N}}{S}}

\infr[Receive]
{\gvj{\Phi}{M}{\gvInput{T}{S}}}
{\gvj{\Phi}{\gvReceive{M}}{\gvTimes{T}{S}}}
\\

\infr[Select]
{\gvj{\Phi}{M}{\gvPlus{\la_i:S_i}{i}}}
{\gvj{\Phi}{\gvSelect{\la_j}{M}}{S_j}}

\infr[Case]
{\gvj{\Phi}{M}{\gvChoice{\la_i:S_i}{i}} \\ \row{\gvj{\Psi,x:S_i}{N_i}{T}}{i}}
{\gvj{\Phi,\Psi}{\gvCase{M}{\row{\la_i(x).N_i}{i}}}{T}}
\\

\infr[Fork]
{\gvj{\Phi,x:S}{M}{\gvEndOutput}}
{\gvj{\Phi}{\gvFork{x}{M}}{\gvDual{S}}}

%% \infr[Connect]
%% {\gvj{\Phi,x:S}{M}{\gvEndOutput} \\ \gvj{\Psi,x:\gvDual{S}}{N}{T}}
%% {\gvj{\Phi,\Psi}{\gvWith{x}{M}{N}}{T}}

\infr[Link]
{\gvj{\Phi}{M}{S} \\ \gvj{\Phi}{N}{\gvDual{S}}}
{\gvj{\Phi}{\gvLink{M}{N}}{\gvEndOutput}}

\infr[SendType]
{\gvj{\Phi}{M}{\gvOutputType{X}{S'}}}
{\gvj{\Phi}{\gvSendType{S}{M}}{\subst{S'}{S}{X}}}

\infr[ReceiveType]
{\gvj{\Phi}{M}{\gvInputType{X}{S}} \\ X \notin \FV{\Phi}}
{\gvj{\Phi}{\gvReceiveType{X}{M}}{S}}

\infr[Serve]
{\gvj{\Phi,x : S}{M}{\gvEndOutput} \\ \un{\Phi}}
{\gvj{\Phi}{\gvServe{x}{M}}{\gvService{\gvDual{S}}}}

\infr[Request]
{\gvj{\Phi}{M}{\gvService{S}}}
{\gvj{\Phi}{\gvRequest{M}}{S}}
\end{mathpar}%

\caption{Typing rules for \hgv}
\label{fig:hgv-typing}

\end{figure}

Figure~\ref{fig:hgv-typing} gives the terms and typing rules for \hgv; the first block contains the
structural rules, the second contains the (standard) rules for lambda terms, and the third contains
the session-typed fragment.  The $\key{fork}$ construct provides session initiation, filling the
role of GV's $\key{with}\dots\key{connect}$ structure, but without the asymmetry of the latter.  The
two are interdefinable, as follows:
\[
\gvFork{x}{M} \equiv \gvWith{x}{M}{x} \qquad \gvWith{x}{M}{N} \equiv \gvLet{x}{\gvFork{x}{M}}{N}
\]
We add a construct $\gvLink{M}{N}$ to implement channel forwarding; this form is provided in neither
GV nor \last, but is necessary to match the expressive power of CP. (Note that while we could define
session forwarding in GV or LAST for any particular session type, it is not possible to do so in a
generic fashion.)  We add terms $\gvSendType{S}{M}$ and $\gvReceiveType{X}{M}$ to provide session
polymorphism, and $\gvServe{x}{M}$ and $\gvRequest{M}$ for replicated sessions. Note that, as the
body $M$ of $\gvServe{x}{M}$ may be arbitrarily replicated, it can only refer to the unlimited
portion of the environment.
%
Channels of type $\gvService{S}$ offer arbitrarily many sessions of type $S$; correspondingly,
channels of type $\gvServer{S}$ must consume arbitrarily many $S$ sessions.  The rule for
$\gvServe{x}{M}$ parallels that for $\key{fork}$: it defines the server (which replicates $M$) and
returns the channel by which it may be used (of type $\gvDual{\gvServer{S}} =
\gvService{\gvDual{S}}$).  As a consequence, there is no term of type $\gvServer{S}$.  We
experimented with having such a term, but found that it was always used immediately inside a
$\key{fork}$, suggesting that the construct we adopted would be more natural.  The original
construct could be recovered by a combination of $\key{fork}$ and $\key{serve}$.

%% We argue that the new features add expressive power to \hgv. Channel forwarding may be implemented in
%% a type-directed fashion for any monomorphic channel in either GV or \last, but neither allows a
%% generic description of forwarding, nor one that would account for polymorphic sessions. GV supports
%% no notion of replication; \last provides recursive sessions instead of replication, which do not
%% admit an interpretation in linear logic.

% \todo{Say something about unlimited functions and replication.}
% Or not...


\section{From \hgv to \hgvpi}
\label{sect:hgv-to-hgvpi}

The language \hgvpi is the restriction of \hgv to session types, that is, \hgv without $\lolli$,
$\to$, or $\otimes$. In order to avoid $\otimes$, we disallow plain $\gvReceive{M}$, but do permit
it to be fused with a pair elimination $\gvReceiveK{x}{y}{M}{N}$. We can simulate all non-session
types as session types via a translation from \hgv to \hgvpi. The translation on types is given by
the homomorphic extension of the following equations:
\[
\lampi{\gvLinFun{T}{U}} = \gvOutput{\lampi{T}}{\gvDual{\lampi{U}}} \qquad
\lampi{\gvUnFun{T}{U}} = \gvService{(\gvOutput{\lampi{T}}{\gvDual{\lampi{U}}})} \qquad
\lampi{\gvTimes{T}{U}} = \gvInput{\lampi{T}}{\gvDual{\lampi{U}}}
\]%
Each target type is the \emph{interface} to the simulated source type. A linear function is
simulated by input on a channel; its interface is output on the other end of the channel. An
unlimited function is simulated by a server; its interface is the service on the other end of that
channel. A tensor is simulated by output on a channel; its interface is input on the other end of
that channel.
%
This duality between implementation and interface explains the flipping of types in Wadler's
original CPS translation from GV to CP.
%
The translation on terms is given by the homomorphic extension of the following equations:
\begin{equations}
\lampi{\gvLam{x}{M}} &=& \gvFork{z}{\gvLet{\gvPair{x}{z}}{\gvReceive{z}}{\gvLink{\lampi{M}}{z}}} \\
\lampi{\gvApp{L}{M}} &=& \gvSend{\lampi{M}}{\lampi{L}} \\
\lampi{\gvTimes{M}{N}} &=&
  \gvFork{z}
    {\gvLink{(\gvSend{\lampi{M}}{z})}{\lampi{N}}} \\
\lampi{\gvLet{\gvPair{x}{y}}{M}{N}} &=&
    \gvLet{\gvPair{x}{y}}{\gvReceive{\lampi{M}}}{\lampi{N}} \\
\lampi{L : \gvUnFun{T}{U}} &=&
  \gvFork{z}{\gvLink{z}{(\gvServe{y}{\gvLink{\lampi{L}}{y}})}} \\
\lampi{L : \gvLinFun{T}{U}} &=& \gvRequest{\lampi{L}} \\
\lampi{\gvReceive{M}} &=& \lampi{M} \\
\end{equations}%
Formally, this is a translation on derivations. We write type annotations to indicate $\to$
introduction and elimination. For all other cases, it is unambiguous to give the translation on
plain term syntax. Each introduction form translates to an interface $\gvFork{z}{M}$ of type
$\gvDual{S}$, where $M : \gvEndOutput$ provides the implementation, with $z : S$ bound in $M$.
We can extend the translation on types to a translation on contexts:
\begin{equations}
\lampi{x_1:T_1, \dots, x_n:T_n} &=& x_1:\lampi{T_1}, \dots, x_n:\lampi{T_n} \\
\end{equations}%
Finally, it is straightforward to verify that our translation preserves typing.
\begin{theorem}
If $\gvj{\Phi}{M}{T}$ then $\gvj{\lampi{\Phi}}{\lampi{M}}{\lampi{T}}$.
\end{theorem}

%% \begin{equations}
%% \lampi{\gvj{\Phi}{M}{T}} &=& \gvj{\lampi{\Phi}}{\lampi{M}}{\lampi{T}} \\
%% \end{equations}%



\section{From \hgvpi to CP}
\label{sect:hgvpi-to-cp}

\begin{figure}
\begin{mathpar}
\infr[Ax]
{ }
{\cpj{\cpLink{w}{x}}{w:\cpDual{A},x:A}}

\infr[Cut]
{\cpj{P}{\G,x:A} \\ \cpj{Q}{\D,x:\cpDual{A}}}
{\cpj{\cpCut{x}{P}{Q}}{\G,\D}}

\infr[$\otimes$]
  {\cpj{P}{\G,y:A} \\ \cpj{Q}{\D,x:B}}
  {\cpj{\cpOutput{x}{y}{P}{Q}}{\G,\D,x:\cpTimes{A}{B}}}

\infr[$\bindnasrepma$]
{\cpj{R}{\Theta,y:A,x:B}}
{\cpj{\cpInput{x}{y}{R}}{\Theta,x:\cpPar{A}{B}}}

\infr[$\oplus$]
{\cpj{P}{\G,x:A_i}}
{\cpj{\cpInject{x}{\la_i}{P}}{\G,x:\cpPlus{\la_i:A_i}{i}}}

\infr[$\binampersand$]
{\row{\cpj{Q_i}{\D,x_i:A_i}}{i}}
{\cpj{\cpCase{x}{\row{\la_i.Q_i}{i}}}{\D,x:\cpWith{\la_i:A_i}{i}}}

\infr[$!$]
{\cpj{P}{\cpWhyNot{\G},y:A}}
{\cpj{\cpServe{x}{y}{P}}{\cpWhyNot{\G},x:\cpOfCourse{A}}}

\infr[$?$]
{\cpj{Q}{\D,y:A}}
{\cpj{\cpRequest{x}{y}{Q}}{\D,x:\cpWhyNot{A}}}

\infr[Weaken]
{\cpj{Q}{\D}}
{\cpj{Q}{\D,x:\cpWhyNot{A}}}

\infr[Contract]
{\cpj{Q}{\D,x:\cpWhyNot{A},x':\cpWhyNot{A}}}
{\cpj{\subst{Q}{x}{x'}}{\D,x:\cpWhyNot{A}}}

\infr[$\exists$]
{\cpj{P}{\G,x:\subst{B}{A}{X}}}
{\cpj{\cpSendType{x}{A}{P}}{\G,x:\cpExists{X}{B}}}

\infr[$\forall$]
{\cpj{Q}{\D,x:B} \\ X \notin \D}
{\cpj{\cpReceiveType{x}{X}{Q}}{\D,x:\cpForall{X}{B}}}

\infr[$\cpOne$]
{ }
{\cpj{\cpEmptyOut{x}}{x:\cpOne}}

\infr[$\cpBottom$]
{\cpj{P}{\G}}
{\cpj{\cpEmptyIn{x}{P}}{\G,x:\cpBottom}}
\end{mathpar}
\caption{Typing rules for CP}\label{fig:cp-typing}
\end{figure}

We give the typing rules of CP in Figure~\ref{fig:cp-typing}; a full description of CP, including
its cut reduction, can be found in Wadler's work~\cite{Wadler12}.  Note that the propositions of CP
are exactly those of classical linear logic, as are the cut rules (if we ignore the terms). Thus, CP
enjoys all of the standard meta theoretic properties of classical linear logic, including confluence
and weak normalisation.
%
A minor syntactic difference between our presentation and Wadler's is that our sum ($\oplus$) and
choice ($\binampersand$) types are $n$-ary, matching the corresponding session types in \hgv,
whereas he presents binary and nullary versions of sum and choice.
%
Duality on CP types ($\cpDual{(-)}$) is standard:
\[
\bl
  \cpDual{(\cpTimes{A}{B})} = \cpPar{\cpDual{A}}{\cpDual{B}}
~~
  \cpDual{(\cpPlus{\la_i:A_i}{i})} = \cpWith{\la_i:\cpDual{A_i}}{i}
~~
  \cpDual{\cpOne} = \cpBottom
~~
  \cpDual{(\cpExists{X}{B})} = \cpForall{X}{\cpDual{B}}
~~
  \cpDual{(\cpOfCourse{A})} = \cpWhyNot{\cpDual{A}}
\\
  \cpDual{(\cpPar{A}{B})} = \cpTimes{\cpDual{A}}{\cpDual{B}}
~~
  \cpDual{(\cpWith{\la_i:A_i}{i})} = \cpPlus{\la_i:\cpDual{A_i}}{i}
~~
  \cpDual{\cpBottom} = \cpOne
~~
  \cpDual{(\cpForall{X}{B})} = \cpExists{X}{\cpDual{B}}
~~
  \cpDual{(\cpWhyNot{A})} = \cpOfCourse{\cpDual{A}}
\\
\el
\]

We now give a translation from \hgvpi to CP. Post composing this with the embedding of \hgv in
\hgvpi yields a semantics for \hgv.
%
The translation on session types is as follows:
\[
\ba{@{}c@{\qquad}c@{\qquad}c@{\qquad}c@{}}
\begin{eqs}
\hgvcp{\gvOutput{T}{S}}         &=& \cpTimes{\cpDual{\hgvcp{T}}}{\hgvcp{S}} \\
\hgvcp{\gvInput{T}{S}}          &=& \cpPar{\hgvcp{T}}{\hgvcp{S}} \\
\hgvcp{\gvEndOutput}  &=& \cpOne \\
\end{eqs}
&
\begin{eqs}
\hgvcp{\gvPlus{\la_i:S_i}{i}}   &=& \cpPlus{\la_i:\hgvcp{S_i}}{i} \\
\hgvcp{\gvChoice{\la_i:S_i}{i}} &=& \cpWith{\la_i:\hgvcp{S_i}}{i} \\
\hgvcp{\gvEndInput}   &=& \cpBottom \\
\end{eqs}
&
\begin{eqs}
\hgvcp{\gvServer{S}}  &=& \cpOfCourse{\hgvcp{S}} \\
\hgvcp{\gvService{S}} &=& \cpWhyNot{\hgvcp{S}} \\
\hgvcp{X}                   &=& X \\
\end{eqs}
&
\begin{eqs}
\hgvcp{\gvOutputType{X}{S}} &=& \cpExists{X}{\hgvcp{S}} \\
\hgvcp{\gvInputType{X}{S}}  &=& \cpForall{X}{\hgvcp{S}} \\
\hgvcp{\gvDual{X}}          &=& \cpDual{X} \\
\end{eqs}
\ea
\]
The translation is homomorphic except for output, where the output type is dualised. This accounts
for the discrepancy between $\gvDual{\gvOutput{T}{S}} = \gvInput{T}{\gvDual{S}}$ and
$\cpDual{(\cpTimes{A}{B})} = \cpPar{\cpDual{A}}{\cpDual{B}}$.
%
%% We could just have well have decided to dualise input types instead of output types in our
%% translation.

The translation on terms is formally specified as a CPS translation on derivations as in Wadler's
presentation. We provide the full translations of weakening and contraction for $\gvEndInput$, as
these steps are implicit in the syntax of GV terms.  The other constructs depend only on the
immediate syntactic structure, so we abbreviate their translations as mappings on plain terms:
%
\begin{equations}
\hgvcpl \inferrule{\gvj{\Phi}{N}{S}}{\gvj{\Phi,x:\gvEndInput}{N}{S}} \hgvcpr\!\!z &=&
  \inferrule
    {\cpj{\hgvcp{N}z}{\hgvcp{\Phi},z:\cpDual{\hgvcp{S}}}}
    {\cpj{\cpEmptyIn{x}{\hgvcp{N}z}}{\hgvcp{\Phi},x:\cpBottom,z:\cpDual{\hgvcp{S}}}}
\\[3ex]
\hgvcpl \inferrule{\gvj{\Phi,x:\gvEndInput,x':\gvEndInput}{N}{S}}
                          {\gvj{\Phi,x:\gvEndInput}{\subst{N}{x}{x'}}{S}} \hgvcpr\!\!z &=&
  \inferrule
    {\cpj{\hgvcp{N}z}{\hgvcp{\Phi},x:\cpBottom,x':\cpBottom,z:\cpDual{\hgvcp{S}}}}
    {\cpj{\cpCut{x'}{\hgvcp{N}z}{\cpEmptyOut{x'}}}{\hgvcp{\Phi},x:\cpBottom,z:\cpDual{\hgvcp{S}}}}
\\[3ex]
\hgvcp{x}z &=& \cpLink{x}z \\
\hgvcp{\gvSend{M}{N}}z &=& \cpCut{x}{\cpOutput{x}{y}{\hgvcp{M}y}{\cpLink{x}{z}}}{\hgvcp{N}x} \\
\hgvcp{\gvReceiveK{x}{y}{M}{N}}z &=&
  \cpCut{y}{\hgvcp{M}y}{\cpInput{y}{x}{\hgvcp{N}z}} \\
\hgvcp{\gvSelect{\la}{M}}z &=&
  \cpCut{x}{\hgvcp{M}x}{\cpInject{x}{\la}{\cpLink{x}{z}}} \\
\hgvcp{\gvCase{M}{\row{\la_i(x).N_i}{i}}}z &=&
  \cpCut{x}{\hgvcp{M}x}{\cpCase{x}{\row{\la_i.\hgvcp{N_i}z}{i}}} \\
\hgvcp{\gvFork{x}{M}}z &=&
  \cpCut{x}{\cpCut{y}{\hgvcp{M}y}{\cpEmptyOut{y}}}{\cpLink{x}{z}} \\
\hgvcp{\gvLink{M}{N}}z &=& \cpEmptyIn{z}{\cpCut{x}{\hgvcp{M}x}{\hgvcp{N}x}} \\
\hgvcp{\gvSendType{S}{M}}z &=&
  \cpCut{x}{\hgvcp{M}x}{\cpSendType{x}{\hgvcp{S}}{\cpLink{x}{z}}} \\
\hgvcp{\gvReceiveType{X}{M}}z &=&
  \cpCut{x}{\hgvcp{M}x}{\cpReceiveType{x}{X}{\cpLink{x}{z}}} \\
\hgvcp{\gvServe{y}{M}}z &=&
   \cpServe{z}{y}
      {\cpCut{x}{\hgvcp{M}x}{\cpEmptyOut{x}}} \\
\hgvcp{\gvRequest{M}}z &=& \cpCut{x}{\hgvcp{M}x}{\cpRequest{x}{y}{\cpLink{y}{z}}} \\
\end{equations}%
Channel $z$ provides a continuation, consuming the output of the process representing the original
\hgvpi term.
%
The translation on contexts is pointwise.
\begin{equations}
\hgvcp{x_1:T_1, \dots, x_n:T_n} &=& x_1:\hgvcp{T_1}, \dots, x_n:\hgvcp{T_n} \\
\end{equations}%
As with the translation from \hgv to \hgvpi, we can show that this translation preserves typing.
\begin{theorem}
If $\gvj{\Phi}{M}{S}$ then $\cpj{\hgvcp{M}}{\hgvcp{\Phi},z:\cpDual{\hgvcp{S}}}$.
\end{theorem}

\section{From CP to \hgvpi}
\label{sect:cp-to-hgvpi}

%In order to demonstrate that CP and \hgvpi (and indeed \hgv) are equally expressive
We now present the translation $\cptogv{-}$ from CP to \hgvpi. The translation on types is as
follows:
%% \[
%% \ba{@{}c@{\qquad}c@{\qquad}c@{}}
%% \begin{eqs}
%% \cptogv{\cpTimes{A}{B}} &=& \gvOutput{\gvDual{\cptogv{A}}}{\cptogv{B}} \\
%% \cptogv{\cpPar{A}{B}}   &=& \gvInput{\cptogv{A}}{\cptogv{B}} \\
%% \cptogv{\cpPlus{\la_i:A_i}{i}} &=& \gvPlus{\la_i:\cptogv{A_i}}{i}  \\
%% \cptogv{\cpWith{\la_i:A_i}{i}} &=& \gvChoice{\la_i:\cptogv{A_i}}{i} \\
%% \end{eqs}
%% &
%% \begin{eqs}
%% \cptogv{\cpOne}         &=& \gvEndOutput \\
%% \cptogv{\cpBottom}      &=& \gvEndInput \\
%% \cptogv{\cpOfCourse{A}} &=& \gvServer{\cptogv{A}} \\
%% \cptogv{\cpWhyNot{A}}   &=& \gvService{\cptogv{A}} \\
%% \end{eqs}
%% &
%% \begin{eqs}
%% \cptogv{\cpExists{X}{A}} &=& \gvOutputType{X}{\cptogv{A}} \\
%% \cptogv{\cpForall{X}{A}} &=& \gvInputType{X}{\cptogv{A}} \\
%% \cptogv{X}               &=& X \\
%% \cptogv{\cpDual{X}}      &=& \gvDual{X} \\
%% \end{eqs}
%% \ea
%% \]
\[
\ba{@{}c@{\qquad}c@{\qquad}c@{\qquad}c@{}}
\begin{eqs}
\cptogv{\cpTimes{A}{B}} &=& \gvOutput{\gvDual{\cptogv{A}}}{\cptogv{B}} \\
\cptogv{\cpPar{A}{B}}   &=& \gvInput{\cptogv{A}}{\cptogv{B}} \\
\cptogv{\cpOne}         &=& \gvEndOutput \\
\end{eqs}
&
\begin{eqs}
\cptogv{\cpPlus{\la_i:A_i}{i}} &=& \gvPlus{\la_i:\cptogv{A_i}}{i}  \\
\cptogv{\cpWith{\la_i:A_i}{i}} &=& \gvChoice{\la_i:\cptogv{A_i}}{i} \\
\cptogv{\cpBottom}      &=& \gvEndInput \\
\end{eqs}
&
\begin{eqs}
\cptogv{\cpExists{X}{A}} &=& \gvOutputType{X}{\cptogv{A}} \\
\cptogv{\cpForall{X}{A}} &=& \gvInputType{X}{\cptogv{A}} \\
\cptogv{X}               &=& X \\
\end{eqs}
&
\begin{eqs}
\cptogv{\cpWhyNot{A}}    &=& \gvService{\cptogv{A}} \\
\cptogv{\cpOfCourse{A}}  &=& \gvServer{\cptogv{A}} \\
\cptogv{\cpDual{X}}      &=& \gvDual{X} \\
\end{eqs}
\ea
\]
The translation on terms is as follows.  We have made use of $\key{let}$ expressions to simplify the
presentation of the translation; these can be expanded to \hgvpi by observing that
\[
\gvLet{x}{M}{N} \equiv \lampi{(\lambda x.N) M} \equiv \gvSend{M}{(\gvFork{z}{\gvReceiveK{x}{z}{z}{\gvLink{N}{z}}})}.
\]
\[
%\ba{@{}c@{\qquad}c@{\qquad}c@{}}
\begin{eqs}
  %% \gvLet{z}{\gvTerminate{x}}{\cptogv{P}} \\[1ex]
%\end{eqs}
%&
%\begin{eqs}
\cptogv{\cpOutput{x}{y}{P}{Q}} &=&
  \gvLet{x}{\gvSend{(\gvFork{y}{\cptogv{P}})}{x}}{\cptogv{Q}} \\
\cptogv{\cpInput{x}{y}{P}} &=&
  \gvLet{\gvPair{y}{x}}{\gvReceive{x}}{\cptogv{P}} \\
\cptogv{\cpInject{x}{\la}{P}} &=&
  \gvLet{x}{\gvSelect{\la}{x}}{\cptogv{P}} \\
\cptogv{\cpCase{x}{\row{\la_i.P_i}{i}}} &=&
  \gvCase{x}{\row{\la_i(x).\cptogv{P_i}}{i}} \\
\cptogv{\cpEmptyOut{x}} &=& x \\
\cptogv{\cpEmptyIn{x}{P}} &=& \cptogv{P} \\
\cptogv{\cpCut{x}{P}{Q}} &=&
  \gvLet{x}{\gvFork{x}{\cptogv{P}}}{\cptogv{Q}} \\
\cptogv{\cpLink{x}{y}} &=& \gvLink{x}{y} \\

\cptogv{\cpSendType{x}{A}{P}} &=&
  \gvLet{x}{\gvSendType{\cptogv{A}}{x}}{\cptogv{P}} \\
\cptogv{\cpReceiveType{x}{X}{P}} &=&
  \gvLet{x}{\gvReceiveType{X}{x}}{\cptogv{P}} \\

%% \end{eqs}%
%% \]%
%% \[
%% \begin{eqs}
\cptogv{\cpServe{s}{x}{P}} &=&
  \gvLink{s}{(\gvServe{x}{\cptogv{P}})} \\
\cptogv{\cpRequest{s}{x}{P}} &=&
  \gvLet{x}{\gvFork{x}{\gvLink{(\gvRequest{s})}{x}}}{\cptogv{P}} \\
\end{eqs}
%\ea
\]
Again, we can extend the translation on types to a translation on contexts, and show that the
translation preserves typing.
\begin{theorem}
If $\cpj{P}{\G}$ then $\gvj{\cptogv{\G}}{\cptogv{P}}{\gvEndOutput}$.
\end{theorem}


\section{Correctness}
\label{sect:correctness}

If we extend $\hgvcp{-}$ to non-session types, as in Wadler's original presentation, then it is
straightforward to show that this monolithic translation factors through $\lampi{-}$.
\begin{theorem}
\label{th:factor}
$\hgvcp{\lampi{M}}z \redto^* \hgvcp{M}z$
\end{theorem}
\noindent
The key soundness property of our translations is that if we translate a term from CP to \hgvpi and
back, then we obtain a term equivalent to the one we started with.
\begin{theorem}
\label{th:soundness}
%% ~
%% \begin{enumerate}
%% \item $\hgvcp{\cptogv{A}} = A$.
%% \item
If $\cpj{P}{\G}$ then $\cpCut{z}{\cpEmptyOut{z}}{\hgvcp{\cptogv{P}}z} \redto^* P$.
%%\end{enumerate}
\end{theorem}
\noindent
Together, Theorem~\ref{th:factor}~and~\ref{th:soundness} tell us that \hgv, \hgvpi, and CP are
equally expressive.

%% SL: commented out for space-saving

%% , in the sense that every $X$ program can always be translated to an equivalent
%% $Y$ program, where $X,Y \in \{$\hgv, \hgvpi, CP$\}$.

%% It is interesting also to consider Felleisen's more refined notion of
%% expressivity~\cite{Felleisen91}.  Both $\lampi{-}$ and $\cptogv{-}$ are local translations, thus
%% both \hgv and CP are macro-expressible~\cite{Felleisen91} in \hgvpi. However, the apparent need for
%% CPS in translating from \hgvpi to CP indicates that \hgvpi is not macro-expressible in CP; hence
%% \hgvpi is more expressive (in the Felleisen sense) than CP.
%


%% As we do not give a semantics for \hgv, other than by translation to
%% CP, there is no point in considering the composition of the
%% translations the other way round.



%% Judgements
%% \begin{equations}
%% \hgvcp{\gvj{\Phi}{M}{T}} &=& \cpj{\hgvcp{M}z}{\hgvcp{\Phi}, z:\cpDual{\hgvcp{T}}}
%% \end{equations}



\section{Conclusions and Future Work}
\label{sect:conclusion}

We have proposed a session-typed functional language, \hgv, building on similar languages of
Wadler~\cite{Wadler12} and of Gay and Vasconcelos~\cite{GayVasconcelos10}. We have shown that \hgv
is sufficient to encode arbitrary linear logic proofs, completing the correspondence between linear
logic and session types. We have also given an embedding of all of \hgv into its session-typed
fragment, simplifying translation from \hgv to CP.

We highlight several areas of future work.  First, the semantics of \hgv is given only by cut
elimination in CP. We would like to give \hgv a semantics directly, in terms of reductions of
configurations of processes, and then prove a formal correspondence with cut elimination in CP.
Second, replication has limited expressive power compared to recursion; in particular, it cannot
express services whose behavior changes over time or in response to client requests.  We believe
that the study of fixed points in linear logic provides a mechanism to support more expressive
recursive behavior without sacrificing the logical interpretation of \hgv.  Finally, as classical
linear logic proofs, and hence CP processes, enjoy confluence, \hgv programs are deterministic. We
hope to identify natural extensions of \hgv that give rise to non-determinism, and thus allow
programs to exhibit more interesting concurrent behaviour, while preserving the underlying
connection to linear logic.

\paragraph{Acknowledgements}
We would like to thank Philip Wadler for his suggestions on the direction of this work, and for his
helpful feedback on the results. This work was funded by EPSRC grant number EP/K034413/1.

\label{sect:bib}
\bibliographystyle{plain}
\bibliography{cpgv}


\end{document}


\appendix

\section{Typing rules for CP}
\label{sect:cp-typing}


\section{Cut reduction for CP}
\label{sect:cp-cut}

\paragraph{Structural cut equivalences}

\begin{equations}
\cpCut{x}{P}{Q} &\eqto& \cpCut{x}{Q}{P} \\
\cpCut{y}{\cpCut{x}{P}{Q}}{R} &\eqto& \cpCut{x}{P}{\cpCut{y}{Q}{R}} \\
\end{equations}%
%
The cut relation $\redto$ is interpreted modulo both $\alpha$-equivalence and structural cut
equivalence. It is given by the compatible closure of the cut rules and commuting conversions
defined below. We write $\redto^*$ for the transitive reflexive closure of $\redto$.

\paragraph{Cut rules}

\begin{equations}
\cpCut{x}{\cpLink{w}{x}}{P}
  &\redto& \subst{P}{w}{x} \\
\cpCut{x}{\cpOutput{x}{y}{P}{Q}}{\cpInput{x}{y}{R}}
  &\redto& \cpCut{y}{P}{\cpCut{x}{Q}{R}} \\
\cpCut{x}{\cpInject{x}{\la_j}{P}}{\cpCase{x}{\row{\la_i.Q_i}{i}}}
  &\redto& \cpCut{x}{P}{Q_j} \\
\cpCut{x}{\cpServe{x}{y}{P}}{\cpRequest{x}{y}{Q}}
  &\redto& \cpCut{y}{P}{Q} \\
\cpCut{x}{\cpServe{x}{y}{P}}{Q}
  &\redto& Q, \quad x \notin \FV{Q} \\
\cpCut{x}{\cpServe{x}{y}{P}}{\subst{Q}{x}{x'}}
  &\redto& \cpCut{x}{\cpServe{x}{y}{P}}{\cpCut{x'}{\cpServe{x'}{y}{P}}{Q}} \\
\cpCut{x}{\cpSendType{x}{A}{P}}{\cpReceiveType{x}{X}{Q}}
  &\redto& \cpCut{x}{P}{\subst{Q}{A}{X}} \\
\cpCut{x}{\cpEmptyOut{x}}{\cpEmptyIn{x}{P}}
  &\redto& P \\
\end{equations}%

\paragraph{Commuting conversions}

\begin{equations}
\cpCut{z}{\cpOutput{x}{y}{P}{Q}}{R}
  &\redto& \cpOutput{x}{y}{\cpCut{z}{P}{R}}{Q}, \quad z \in \FV{P} \\
\cpCut{z}{\cpOutput{x}{y}{P}{Q}}{R}
  &\redto& \cpOutput{x}{y}{P}{\cpCut{z}{Q}{R}}, \quad z \in \FV{Q} \\
\cpCut{z}{\cpInput{x}{y}{P}}{Q}
  &\redto& \cpInput{x}{y}{\cpCut{z}{P}{Q}} \\
\cpCut{z}{\cpInject{x}{\la}{P}}{Q}
  &\redto& \cpInject{x}{\la}{\cpCut{z}{P}{Q}} \\
\cpCut{z}{\cpCase{x}{\row{\la_i.Q_i}{i}}}{R}
  &\redto& \cpCase{x}{\row{\la_i.\cpCut{z}{Q_i}{R}}{i}} \\
\cpCut{z}{\cpServe{x}{y}{P}}{Q}
  &\redto& \cpServe{x}{y}{\cpCut{z}{P}{Q}} \\
\cpCut{z}{\cpRequest{x}{y}{P}}{Q}
  &\redto& \cpRequest{x}{y}{\cpCut{z}{P}{Q}} \\
\cpCut{z}{\cpSendType{x}{A}{P}}{Q}
  &\redto& \cpSendType{x}{A}{\cpCut{z}{P}{Q}} \\
\cpCut{z}{\cpReceiveType{x}{X}{P}}{Q}
  &\redto& \cpReceiveType{x}{X}{\cpCut{z}{P}{Q}} \\
\cpCut{z}{\cpEmptyIn{x}{P}}{Q}
  &\redto& \cpEmptyIn{x}{\cpCut{z}{P}{Q}} \\
\end{equations}%

\section{Design choices for \hgv}
\label{sect:design}

We briefly summarise the rationale for some of the design choices for \hgv.

\paragraph{Fork vs connect}

We choose the $\key{fork}$ construct in place of GV's equivalent $\key{connect}$ construct because
it has a simpler typing rule and seems just as convenient to use.
\begin{mathpar}
\infr[Fork]
{\gvj{\Phi,x:S}{M}{\gvEndOutput}}
{\gvj{\Phi}{\gvFork{x}{M}}{\gvDual{S}}}

\infr[Connect]
{\gvj{\Phi,x:S}{M}{\gvEndOutput} \\ \gvj{\Psi,x:\gvDual{S}}{N}{T}}
{\gvj{\Phi,\Psi}{\gvWith{x}{M}{N}}{T}}
\end{mathpar}%
%
The two constructs are interdefinable as follows:
\[
\gvFork{x}{M} \equiv \gvWith{x}{M}{x} \qquad \gvWith{x}{M}{N} \equiv \gvLet{x}{\gvFork{x}{M}}{N}
\]

\paragraph{Weakening and contraction for $\gvEndInput$ vs explicit termination}

GV has an explicit $\key{terminate}$ construct for handling an end input session type. This is
inconvenient and unnecessary for programming in practice as a term of this type never carries any
data. Thus, instead we choose to make $\gvEndInput$ unlimited, admitting weakening and contraction.
%
\begin{mathpar}
\infr[Terminate-$\otimes$]
  {\gvj{\Phi}{M}{\gvTimes{T}{\gvEndInput}}}
  {\gvj{\Phi}{\gvTerminate{M}}{T}}
%% \infr[Terminate-$\gvUnitType$]
%%   {\gvj{\Phi}{M}{\gvEndInput}}
%%   {\gvj{\Phi}{\gvTerminate{M}}{\gvUnitType}}
\end{mathpar}%
%
We can simulate explicit termination as follows:
\[
\gvTerminate{M} \equiv \gvLet{\gvPair{x}{y}}{M}{x} \\
\]
One can also go the other way using $\key{terminate}$ to simulate weakening and contraction on
variables of type $\gvEndInput$.

\paragraph{Service creation vs server definition}

The typing rule for $\key{serve}$ is anomolous because it has a service type in its conclusion
rather than a server type in a premise. An alternative is to provide a $\key{defServer}$ construct
that specifies the definition of a server. We prefer the former rule because we find it more
convenient to program with than the more uniform alternative.
\begin{mathpar}
\infr[Serve]
{\gvj{\Phi,x : S}{M}{\gvEndOutput} \\ \un{\Phi}}
{\gvj{\Phi}{\gvServe{x}{M}}{\gvService{\gvDual{S}}}}

\infr[ServeDef]
{\gvj{\Phi}{N}{\gvServer{S}} \\ \gvj{\Psi,x:S}{M}{\gvEndOutput} \\ \un{\Psi}}
{\gvj{\Phi,\Psi}{\gvServeOld{N}{x}{M}}{\gvEndOutput}}
\end{mathpar}%
%
The two constructs are interdefinable:
\[
\gvServe{x}{M} \equiv \gvFork{y}{\gvServeOld{y}{x}{M}}
\qquad
\gvServeOld{N}{x}{M} \equiv \gvLink{N}{(\gvServe{x}{M})}
\]

\section{Extension of $\hgvcp{-}$ to non-session types}
\label{sect:hgvcp-ext}

\paragraph{Types}

\begin{equations}
\hgvcp{\gvLinFun{T}{U}} &=& \cpDual{(\cpPar{\cpDual{\hgvcp{T}}}{\hgvcp{U}})} \\
\hgvcp{\gvUnFun{T}{U}} &=& \cpDual{(\cpOfCourse{(\cpPar{\cpDual{\hgvcp{T}}}{\hgvcp{U}})})} \\
\hgvcp{\gvTimes{T}{U}} &=& \cpDual{(\cpTimes{\hgvcp{T}}{\hgvcp{U}})} \\
\end{equations}%
The outer duals appear here because, as in Section~\ref{sect:hgv-to-hgvpi}, we must expose
\emph{interfaces} rather than implementations of simulated types.

\paragraph{Terms}

\begin{equations}
\hgvcp{\gvLam{x}{N}}z &=& \cpInput{z}{x}{\hgvcp{N}z} \\
\hgvcp{\gvApp{L}{M}}z &=& \cpCut{y}{\hgvcp{L}y}{\cpOutput{y}{x}{\hgvcp{M}x}{\cpLink{y}{z}}} \\
\hgvcp{L : \gvUnFun{T}{U}}z &=& \cpServe{z}{y}{\hgvcp{L}y} \\
\hgvcp{L : \gvLinFun{T}{U}}z &=& \cpCut{y}{\hgvcp{L}y}{\cpRequest{y}{x}{\cpLink{x}{z}}} \\
\hgvcp{\gvPair{M}{N}}z &=& \cpOutput{z}{y}{\hgvcp{M}y}{\hgvcp{N}z} \\
\hgvcp{\gvLet{\gvPair{x}{y}}{M}{N}}z
  &=& \cpCut{y}{\hgvcp{M}y}{\cpInput{y}{x}{\hgvcp{N}z}} \\
\end{equations}%
%
As in the definition of $\lampi{-}$ in Section~\ref{sect:hgv-to-hgvpi}, we write type annotations to
indicate $\to$ introduction and elimination.

%% \appendix

%% \subsection{GV extensions}

%% \begin{mathpar}
%% \inferrule
%% {\gvj{\Phi}{M}{\gvInputType{X}{S}}}
%% {\gvj{\Phi}{\gvSendType{S}{M}}{S'[S/X]}}

%% \inferrule
%% {\gvj{\Phi}{M}{\gvOutputType{X}{S}} \\ X \notin \FV{\Phi}}
%% {\gvj{\Phi}{\gvReceiveType M}{S'}}
%% \end{mathpar}

%% \begin{mathpar}
%% \inferrule
%% {\gvj{\Phi}{M}{S} \\ \gvj{\Phi}{N}{\gvDual{S}}}
%% {\gvj{\Phi}{\gvLink{M}{N}}{\gvEndOutput}}

%% \inferrule
%% {\gvj{\Phi, s : \gvServer{S}, x : S}{M}{\gvEndOutput}}
%% {\gvj{\Phi}{\gvServeOld{s}{x}{M}}{\gvEndOutput}}

%% \inferrule
%% { }
%% {\gvj{\Phi, s : \gvService{S}}{\gvRequest{s}}{S}}
%% \end{mathpar}


%% \newpage

%% \section{From GV to CP}
%% ~

%% Session types
%% \begin{equations}
%% \gvtocp{\gvOutput{T}{S}}        &=& \cpPar{\cpDual{\gvtocp{T}}}{\gvtocp{S}} \\
%% \gvtocp{\gvInput{T}{S}}         &=& \cpTimes{\gvtocp{T}}{\gvtocp{S}} \\
%% \gvtocp{\gvPlus{\la_i:S_i}{i}}   &=& \cpWith{\la_i:\gvtocp{S_i}}{i} \\
%% \gvtocp{\gvChoice{\la_i:S_i}{i}} &=& \cpPlus{\la_i:\gvtocp{S_i}}{i} \\
%% \gvtocp{\gvEndOutput}              &=& \cpBottom \\
%% \gvtocp{\gvEndInput}               &=& \cpOne \\[1ex]

%% \gvtocp{X}                       &=& X \\
%% \gvtocp{\gvOutputType{X}{S}}     &=& \cpForall{X}{\gvtocp{S}} \\
%% \gvtocp{\gvInputType{X}{S}}      &=& \cpExists{X}{\gvtocp{S}} \\[1ex]

%% \gvtocp{\gvServer{S}}  &=& \cpWhyNot{\gvtocp{S}} \\
%% \gvtocp{\gvService{S}} &=& \cpOfCourse{\gvtocp{S}} \\[1ex]
%% \end{equations}

%% Non-session types
%% \begin{equations}
%% \gvtocp{\gvLinFun{T}{U}} &=& \cpPar{\cpDual{\gvtocp{T}}}{\gvtocp{U}} \\
%% \gvtocp{\gvUnFun{T}{U}} &=& \cpOfCourse{(\cpPar{\cpDual{\gvtocp{T}}}{\gvtocp{U}})} \\
%% \gvtocp{\gvTimes{T}{U}} &=& \cpTimes{\gvtocp{T}}{\gvtocp{U}} \\
%% \gvtocp{\gvUnitType} &=& \cpOfCourse{(\cpWith{}{})} \\
%% \end{equations}

%% Terms
%% \begin{equations}
%% \gvtocp{\gvSendType{S}{(M : \cpForall{X}{S'})}}z &=&
%%   \cpCut{(x:\cpExists{X}{\cpDual{\gvtocp{S'}}})}{\cpSendType{x}{\gvtocp{S}}{\cpLink{x}{z}}}{\gvtocp{M}x} \\
%% \gvtocp{\gvReceiveType{X}{M}}z &=&
%%   \cpCut{(x:\cpForall{X}{\cpDual{\gvtocp{S'}}})}{\cpReceiveType{x}{X}{\cpLink{x}{z}}}{\gvtocp{M}x} \\
%% \\[1ex]
%% \gvtocp{\gvLink{M}{N}}z &=& \cpCut{x}{\gvtocp{M}x}{\cpCut{y}{\gvtocp{N}y}{\cpEmptyIn{z}{\cpLink{x}{y}}}} \\
%% \gvtocp{\gvServeOld{s}{x}{M}}z &=&
%%   \cpEmptyIn{z}
%%             {\cpServe{s}{x}
%%                      {\cpCut{y}{\cpEmptyOut{y}}{\gvtocp{M}y}}} \\
%% \gvtocp{\gvRequest{s}}z &=& \cpRequest{s}{x}{\cpLink{x}{z}} \\
%% \end{equations}

%% Horrible verbose versions of the rules for sending and receiving types
%% \begin{mathpar}
%% \left\llbracket
%%   \inferrule
%%      {\gvj{\Phi}{M}{\gvOutputType{X}{S}}}
%%      {\gvj{\Phi}{\gvSendType{S'}{M}}{\subst{S}{S'}{X}}}
%% \right\rrbracket z =
%%   \inferrule*
%%     {
%%       \inferrule*
%%         {}
%%         {\cpj{\hgvcp{M}x}{\hgvcp{\Phi},x:\cpForall{X}{\cpDual{\hgvcp{S}}}}}
%%       \\
%%       \inferrule*
%%         {\inferrule*
%%            { }
%%            {\cpj{\cpLink{x}{z}}
%%              {\hgvcp{\Phi},x:\hgvcp{\subst{S}{S'}{X}},
%%                            z:\cpDual{\hgvcp{\subst{S}{S'}{X}}}}}}
%%         {\cpj{\cpSendType{x}{\hgvcp{S'}}{\cpLink{x}{z}}}
%%              {\hgvcp{\Phi},x:\cpExists{X}{\hgvcp{S}},
%%                            z:\cpDual{\hgvcp{\subst{S}{S'}{X}}}}}
%%     }
%%     {\cpj{\cpCut{x}{\hgvcp{M}x}{\cpSendType{x}{\hgvcp{S'}}{\cpLink{x}{z}}}}
%%          {\hgvcp{\Phi},z:\cpDual{\hgvcp{\subst{S}{S'}{X}}}}}
%% \\
%% \left\llbracket
%%   \inferrule
%%      {\gvj{\Phi}{M}{\gvInputType{X}{S}} \\ X \notin \FV{\Phi}}
%%      {\gvj{\Phi}{\gvReceiveType{X}{M}}{S}}
%% \right\rrbracket z =
%%   \inferrule*
%%     {\inferrule*
%%        {}
%%        {\cpj{\hgvcp{M}x}{\hgvcp{\Phi},x:\cpExists{X}{\cpDual{\hgvcp{S}}}}}
%%      \\
%%      \inferrule*
%%        {\inferrule*
%%             { }
%%             {\cpj{\cpLink{x}{z}}
%%               {\hgvcp{\Phi},x:\hgvcp{S}
%%                            ,z:\cpDual{\hgvcp{S}}}}
%%         \\ X \notin \FV{\hgvcp{\Phi}}
%%        }
%%        {\cpj{\cpReceiveType{x}{X}{\cpLink{x}{z}}}
%%           {\hgvcp{\Phi},x:\cpForall{X}{\hgvcp{S}}
%%                        ,z:\cpDual{\hgvcp{S}}}}
%%     }
%%     {\cpj{\cpCut{x}{\hgvcp{M}x}{\cpReceiveType{x}{X}{\cpLink{x}{z}}}}
%%          {\hgvcp{\Phi},z:\cpDual{\hgvcp{S}}}} \\
%% \end{mathpar}

%% Judgements
%% \begin{equations}
%% \gvtocp{\gvj{\Phi}{M}{T}} &=& \cpj{\gvtocp{M}z}{\cpDual{\gvtocp{\Phi}}, z:\gvtocp{T}}
%% \end{equations}


%% %% Theorem:

%% %%   [[((A))]] = ~A
%% %%   [[((P |- G))]] = Q |- G, z : bot
%% %%     where nu z.(z[].0|Q) --> P

%% %%   (([[S]])) = ~S
%% %%   (([[Phi |- M : S]] z)) = Phi |- N : end!
%% %%     where
%% %%       nu w.(w[].0|[[N]]w) --> [[M]]z

%% \section{Alternative translations from GV to CP}

%% \subsection{Dualising the interpretation of judgements}

%% It is possible to avoid the dualisation of session types in the type
%% translation by dualising the interpretation of judgements.

%% Judgements
%% \begin{equations}
%% \gvtocps{\gvj{\Phi}{M}{T}} &=& \cpj{\gvtocp{M} z}{\gvtocps{\Phi}, z:\cpDual{(\gvtocps{T})}}
%% \end{equations}

%% Session types
%% \begin{equations}
%% \gvtocps{\gvOutput{T}{S}}        &=& \cpTimes{\cpDual{\gvtocps{T}}}{\gvtocps{S}} \\
%% \gvtocps{\gvInput{T}{S}}         &=& \cpPar{\gvtocps{T}}{\gvtocps{S}} \\
%% \gvtocps{\gvPlus{\la_i:S_i}{i}}   &=& \cpPlus{\la_i:\gvtocps{S_i}}{i} \\
%% \gvtocps{\gvChoice{\la_i:S_i}{i}} &=& \cpWith{\la_i:\gvtocps{S_i}}{i} \\
%% \gvtocps{\gvEndOutput}              &=& \cpOne \\
%% \gvtocps{\gvEndInput}               &=& \cpBottom \\[1ex]

%% \gvtocps{\gvServer{S}}  &=& \cpOfCourse{\gvtocps{S}} \\
%% \gvtocps{\gvService{S}} &=& \cpWhyNot{\gvtocps{S}} \\[1ex]
%% \end{equations}


%% The idea is that the term translation stays exactly the same. This
%% approach fits with the view of $z$ as a negative continuation
%% parameter. It yields a straightforward interpretation of session
%% types, but then the interpretation of non-session types (linear
%% functions, unrestricted functions, tensor, and unit), becomes dual to
%% what one would normally expect.

%% Non-session types
%% \begin{equations}
%% \gvtocps{\gvLinFun{T}{U}} &=& \cpTimes{\gvtocp{T}}{\cpDual{\gvtocp{U}}} \\
%% \gvtocps{\gvUnFun{T}{U}} &=& \cpWhyNot{(\cpTimes{\gvtocp{T}}{\cpDual{\gvtocp{U}}})} \\
%% \gvtocps{\gvTimes{T}{U}} &=& \cpPar{\cpDual{\gvtocp{T}}}{\cpDual{\gvtocp{U}}} \\
%% \gvtocps{\gvUnitType} &=& \cpWhyNot{(\cpPlus{}{})} \\
%% \end{equations}

%% \subsection{Adapting the translation on terms}

%% As an alternative to dualising the interpretation of non-session
%% types, we can attempt to keep the standard interpretation of
%% non-session types and instead adapt the translation on terms.

%% Judgements
%% \begin{equations}
%% \gvtocpd{\gvj{\Phi}{M}{T}} &=& \cpj{\gvtocpd{M} z}{\gvtocpd{\Phi}, z:{\gvtocpd{T}}}
%% \end{equations}

%% This looks like it might work if we add the Mix rule to CP along with
%% another rule which can be derived from BiCut, but which appears to
%% be weaker.

%% \begin{mathpar}
%% \inferrule
%% {\cpj{P}{\G, y:A, z:C} \\ \cpj{Q}{\D, x:B, z:\cpDual{C}}}
%% {\cpj{\cpCutOutput{z}{x}{y}{P}{Q}}{\G, \D, x : \cpTimes{A}{B}}}
%% \end{mathpar}

%% %%   [[
%% %%   Phi |- L : T -o U  un(Phi)
%% %%   --------------------------
%% %%   Phi |- L : T -> U
%% %%   ]] z
%% %% =
%% %%   [[L]]y |- [[Phi]], y:~[[T -o U]]
%% %%   --------------------------------------------
%% %%   ?z[y].[[L]]y |- [[Phi]], z:?(~[[T -o U]])

%% %%   [[
%% %%   Phi |- L : T -> U
%% %%   -----------------
%% %%   Phi |- L : T -o U
%% %%   ]] z
%% %% =
%% %%                                            x <-> z |- x:[[T -o U]], z:~([[T -o U]])
%% %%                                         ---------------------------------------------------
%% %%   [[L]]y |- [[Phi]], y:?(~[[T -o U]])   !y(x).x <-> z |- y:!([[T -o U]]), z:~([[T -o U]])
%% %%   ------------------------------------------------------------------------------------------
%% %%   nu y.([[L]]y | !y(x).x <-> z) |- [[Phi]], z:~[[T -o U]]
%% %%
%% %% Oops! z can't appear inside the server output!


%% %% z : [[T]] * ~[[U]]
%% %% [[\x.M]]z = nu y.z[x].([[M]]y | y <-> z)
%% %% [[\x.M]]z = nu y x.([[M]]y | z[w].(w <-> x | y <-> z))

%% %% z : ~[[U]]
%% %% [[L M]]z = nu y.([[L]]y | y(x).([[M]]x | y <-> z))

%% %% z : ~[[T]] || ~[[U]]
%% %% [[(M, N)]]z = z(x).([[M]]x | [[N]]z)

%% %% z : ~[[V]]
%% %% [[let (x,y)=M in N]]z = nu w.([[M]]w | nu y.w[x].([[N]]z | w <-> y))

%% %% Cutting an output with a private channel against an input with a
%% %% mix would appear to yield a term containing a plain bicut and a mix

%% %%    nu x.(x[y].nu z.(P | Q) | x(y).(R | S))
%% %%  -->
%% %%    nu y z.(P | nu x.(Q | (R | S)))


%% Non-session terms
%% \begin{equations}
%% \gvtocpd{\lambda x:T.M}z &=&
%%   \cpCutOutput{y:{\cpDual{\gvtocpd{U}}}}{z}{x:{\gvtocpd{T}}}
%%               {\gvtocpd{M}y}{\cpLink{y}{z}} \\
%% \gvtocpd{L~M}z &=&
%%   \cpCut{y:\cpTimes{\gvtocpd{T}}{\cpDual{\gvtocpd{U}}}}
%%         {\gvtocpd{L}y}
%%         {\cpInput{y}{x:\cpDual{\gvtocpd{U}}}{\cpMix{\gvtocpd{M}x}{\cpLink{y}{z}}}} \\
%% \gvtocpd{\gvPair{M}{N}}z &=&
%%   \cpInput{z}{x:\cpDual{\gvtocpd{T}}}{\cpMix{\gvtocpd{M}x}{\gvtocpd{N}z}} \\
%% \gvtocpd{\gvLet{\gvPair{x}{y}}{M}{N}}z &=&
%%   \cpCut{w:\cpPar{\cpDual{\gvtocpd{T}}}{\cpDual{\gvtocpd{U}}}}
%%     {\gvtocpd{M}w}
%%     {\cpCutOutput{y:\gvtocpd{U}}{w}{x:\gvtocpd{T}}{\gvtocpd{N}z}{\cpLink{w}{y}}} \\
%% \end{equations}

%% Where this approach seems to completely break down is in the
%% translation of the elimination rule for unrestricted functions. We
%% might reasonably hope to simulate linear lambdas using output rather
%% than input, but it seems unreasonable to expect to simulate
%% unrestricted lambda application using a linear server rather than an
%% unrestricted client.

%% \subsection{Compiling away non-session types}

%% Another option is to compile away non-session types in GV as a
%% pre-processing step, where the type translation is given by
%% $\cptogv{\gvtocp{-}}$ and the term translation by
%% $\cptogv{\gvtocp{-}z}$.

%% %% T -o U --> ~[[T]] || [[U]] --> ?~T*.U*
%% %% T -> U --> !(~[[T]] || [[U]]) --> $(?~T*.U*)
%% %% T * U --> [[T]] * [[U]] --> !~T*.U*
%% %% Unit --> !&{} --> $&{}

%% %% Hmmm... Looks like things are the wrong way round in the GV to CP
%% %% translation: input types should be negated and output types
%% %% should't.

%% We could simply compose the translations as described, but then it
%% would seem that we would have to perform a global CPS transformation
%% on all terms including the session typing constructs. This would be
%% rather disappointing, as then we would appear to have to effectively
%% perform a CPS transformation twice on such terms in order to generate
%% a CP term.

%% % channel passing translation
%% \newcommand{\gvtogv}[1]{({#1})^\star}

%% We can do better, though, by performing a local transformation. The
%% key observation is that we can locally abstract over the continuation
%% channel $z$ in a term $M$ using $\gvWith{z}{M}{z}$.

%% This is where the dualisation of types arises: the type of the whole
%% expression must be dual to the type of $z$ in $M$. For instance, we
%% implement a lambda of type $\gvLinFun{T}{U}$ with a channel $z$ of
%% type $\gvInput{\gvDual{\gvtogv{T}}}{\gvtogv{U}}$, but the interface to
%% the lambda is the other end of the channel $z$ which has type
%% $\gvOutput{\gvtogv{T}}{\gvDual{\gvtogv{U}}}$ (and application becomes
%% simply sending the argument along this channel).

%% \begin{equations}
%% \gvtogv{\gvLinFun{T}{U}} &=& \gvOutput{\gvtogv{T}}{\gvDual{\gvtogv{U}}} \\
%% \gvtogv{\gvUnFun{T}{U}} &=& \gvService{(\gvOutput{\gvtogv{T}}{\gvDual{\gvtogv{U}}})} \\
%% \gvtogv{\gvTimes{T}{U}} &=& \gvInput{\gvtogv{T}}{\gvDual{\gvtogv{U}}} \\
%% \gvtogv{\gvUnitType} &=& \gvService{(\gvPlus{}{})} \\
%% \end{equations}%

%% \begin{equations}
%% \gvtogv{\gvj{\Phi}{M}{T}} &=& \gvj{\gvtogv{\Phi}}{\gvtogv{M}}{\gvtogv{T}} \\
%% \end{equations}%

%% \begin{equations}
%% \gvtogv{\gvLam{x}{M}} &=& \gvWith{z}{\gvLet{\gvPair{x}{z}}{\gvReceive{z}}{\gvLink{\gvtogv{M}}{z}}}{z} \\
%% \gvtogv{\gvApp{L}{M}} &=& \gvSend{\gvtogv{M}}{\gvtogv{L}} \\
%% \gvtogv{\gvTimes{M}{N}} &=&
%%   \gvWith{z}
%%     {\gvLink{(\gvSend{\gvtogv{M}}{z})}{\gvtogv{N}}}
%%     {z} \\
%% \gvtogv{\gvLet{\gvPair{x}{y}}{M}{N}} &=&
%%     \gvLet{\gvPair{x}{y}}{\gvReceive{\gvtogv{M}}}{\gvtogv{N}} \\
%% \gvtogv{\gvReceive{M}} &=& M \\
%% \gvtogv{\gvUnit} &=&
%%     \gvWith{z}
%%     {\gvServeOld{z}{x}{\gvCase{x}{\row{}{}}}}
%%     {z} \\
%% %% Unnecessary as we don't have a linear unit!
%% %%
%% %% \gvtogv{\gvLet{\gvUnit}{M}{N}} &=&
%% %%   \gvLet{z}{\gvtogv{M}}{\gvtogv{N}} \\
%% \gvtogv{L : \gvUnFun{T}{U}} &=&
%%   \gvWith{z}{\gvServeOld{z}{y}{\gvLink{\gvtogv{L}}{y}}}{z} \\
%% \gvtogv{L : \gvLinFun{T}{U}} &=& \gvRequest{\gvtogv{L}} \\
%% \end{equations}

%% A problem we run into is that $\gvReceive{M}$ has tensor type, and yet
%% our translation is supposed to compile away non-session types,
%% including tensors. Similarly, $\gvTerminate{M}$ has unit type. The
%% problem illustrates an irregularity in GV. All of the typing rules for
%% the other session typing constructs mention only session types.

%% Dealing with $\key{terminate}$ is easy. We just amend our target
%% language such that $\gvTerminate{M}$ has type
%% $\gvService{(\gvPlus{}{})}$, the interpretation of the unit type.
%% %
%% Dealing with $\key{receive}$ is a little harder. We still need some
%% way of binding the two values returned by $\key{receive}$. The
%% solution is to fuse $\key{receive}$ with the pair elimination
%% construct. Notice that this is more or less what CP server input does
%% already. Because we interpret $\gvTimes{T}{U}$ as
%% $\gvInput{\gvtogv{T}}{\gvDual{\gvtogv{U}}}$, instances of
%% $\key{receive}$ from the source term are all erased. The only
%% instances of $\key{receive}$ in the target term arise from
%% interpreting lambdas and pair elimination. This may seem strange until
%% one considers that the only way to use the pair resulting from a
%% $\key{receive}$ in GV is to eliminate it. The transformation shunts
%% each receive up to the point at which the resulting pair is
%% eliminated.

%% \begin{mathpar}
%% \inferrule
%%   {\gvj{\Phi}{M}{\gvEndInput}}
%%   {\gvj{\Phi}{\gvTerminate{M}}{\gvService{(\gvPlus{}{})}}}

%% \inferrule
%%   {\gvj{\Phi}{M}{\gvInput{T}{S}} \\ \gvj{\Psi, x:T, y:S}{N}{U}}
%%   {\gvj{\Phi, \Psi}{\gvLet{\gvPair{x}{y}}{\gvReceive{M}}{N}}{U}}
%% \end{mathpar}

%% Another alternative is to get rid of terminate altogether and change
%% $\gvEndInput$ to be an unrestricted session type. Correspondingly, we
%% could also interpret the unit type as $\gvEndInput$ and $\gvUnit$ as
%% $\gvWith{x}{x}{x}$. Making $\gvEndInput$ unrestricted makes sense as
%% $\gvEndInput = \cptogv{\cpBottom}$, and weakening and contraction are
%% derivable for $\cpBottom$ in CP.

%------------------------------------------------------------------------------
%%

%------------------------------------------------------------------------------
% Index
%\printindex

%------------------------------------------------------------------------------

d{document}


Composing the translations

(([[T -o U]])) = ?~(([[T]])).(([[U]]))
(([[T * U]])) = !(([[T]])).(([[U]]))




\x.M --> ((z(x).[[M]]z))  --> let (x,z)=receive z in (([[M]]z))
[[L M]]z --> nu y.([[L]]y | y[x].([[M]]x | y <-> z)) -->
       with y connect
         (([[L]]y))
       to
         with x connect
           (([[M]]x))
         to
           let y=send x y in link y z
(M,N) --> z[y].([[M]]y | [[N]]z) --> with y connect (([[M]]y)) to let z = send y z in (([[N]]z))
let (x, y) = M in N
   --> nu y.([[M]]y | y(x).[[N]]z)
   --> with y connect
         (([[M]]y))
       to
         let (x, y) = receive y in (([[N]]z))

Phi |- L : T -o U  un(Phi)
--------------------------
Phi |- L : T -> U
  --> !z(y).[[L]]y
  --> serve z(y) = (([[L]]y))

Phi |- L : T -> U
-----------------
Phi |- L : T -o U
  --> nu y.([[L]]y | ?y[x].x <-> z)
  --> with y connect
        (([[L]]z))
      to
        with x connect link (request y) x to link x z
  ==
     with y connect
       (([[L]]z))
     to
       link (request y) z

A problem is that we appear to have to CPS transform everything
globally - including the session typing constructs. For instance:

send M N --> nu x.(x[y].([[M]]y | x <-> z) | [[N]]x)
         --> with x connect
               with y connect
                 (([[M]]y))
               to
                 let x = send y x in link x z
             to
               (([[N]]))x

send (\v.v) w -->
    with x connect
      with y connect
        let (v,y) = receive y in link v y
      to
        let x = send y x in link x z
    to
      link w x
  ==
    with y connect
      let (v,y) = receive y in link v y
    to
      let w = send y w in link w z

If we do this as a pre-processing step, then we effectively end up
doing a CPS transformation twice! Can we do some kind of local CPS
transformation:

send (\v.v) w -->
    with y connect
      let (v,y) = receive y in link v y
    to
      send y w
  ==
    send
      (with y connect
        let (v,y) = receive y in link v y
       to
         y)
    w


let syntactic sugar after translating away lambdas:

  let x = M in N
  ==
  send M (with z connect let (x,z)=receive z in link N z to z)



Attempting to undualise the GV to CP translation on types

[[T -o U]] = [[~T || U]]

z : [[T]] * ~[[U]]
[[\x.N]]z = nu y:[[U]].z[x].([[N]]y|y <-> z)



P |- x : A, y : B
----------------------------------------------------
y[x].(P | nu r s.(r <-> x | s <-> y))) |- y : A * B


P |- x : A, x : C     Q |- x : ~C, y : B
----------------------------------------
     nu x.y[z].(P | Q) |- y : A * B

z : ~[[U]]
[[L M]]z = nu y.([[L]]y | y(x).([[M]]x | y <-> z))



y(x).x().y <->z  |- y : bot || 1, z:bot

y(x).y <->z  |- y : 1 || 1, z:bot


[[L]]y |- [[Phi]],y:[[T]]*~[[U]]   ? |- [[Psi]],y:~[[T]] || [[U]],z:~[[U]]
--------------------------------------------------------------------------
? |- [[Phi]],[[Psi]],z:~[[U]]



P |- G,x:~A

? |- G,x:~A,y:B,z:~B
----------------------------------
y(x).? |- y:~A || B,z:~B

z : ~[[T]] || ~[[U]]
[[(M, N)]]z = z(x).([[M]]x || [[N]]z)


x(y).x(z).x().y <-> z |- x:1||(bot || bot)



nu y1 : !top * !top . (foo <-> y1 |  y1(x2).!z0(y3).y3.case(){}) |- foo : ~(!top * !top),z0:!top


  foo : ?#+{}.#+{}, z0 : $&{}
|-
  with y1 : !#+{}.$&{}
  connect
    link foo y1
  to
    let (x2, y1)=receive y1 in serve z0 (y3)=case y3 of {}
: end!


((!top*!top)) = !~((!top)).((!top)) = !#+{}.$&{}

foo : ?#+{}.#+{}, z0 : $&{} |- with y1 : !#+{}.$&{} connect link foo y1 to let (x2, y1)=receive y1 in serve z0 (y3)=case y3 of {} : end!

New version of terminate:

[[terminate M]](z : !top) = nu (x:1).([[M]]x|x().!z(y).y.case())

Let unit:

[[ let () = m in n ]]z = [[ (\().n)m ]] z
  = nu y.(y(x).[[n]]y | y[x].([[m]]x | y <-> z))
  = nu x.(nu y.([[n]]y | y <-> z) | [[m]]x)
  = nu x.([[m]]x | [[n]]z)

Rules for sendType and receiveType

G |- M : ??X.S'
---------------------------
G |- sendType S M : S'[S/X]

G |- M : !!X.S'   X notin FV(G)
-------------------------------
G |- receiveType M : S'

[[sendType S M]](z : S'[S/X]) = nu (x:exists X.[[S']]).(x[S].x <-> z | [[M]]x)
[[receiveType M]](z : S')     = nu.(x:forall X.[[S']]).(x(X).x <-> z | [[M]]x)


%% Each type $T$ is classified as either linear ($\lin{T}$) or unlimited
%% ($\un{T}$).
%% \[
%% \begin{array}{l}
%% \lin{\gvOutput{T}{S}}  \quad \lin{\gvInput{T}{S}} \quad
%% \lin{\gvPlus{\la_i:S_i}{i}} \quad \lin{\gvChoice{\la_i:S_i}{i}} \quad
%% \lin{\gvEndOutput} \quad \un{\gvEndInput} \\
%% \lin{X} \quad
%% \lin{\gvOutputType{X}{S}} \quad \lin{\gvInputType{X}{S}} \quad
%% \lin{\gvServer{S}} \quad \un{\gvService{S}} \\
%% \lin{\gvTimes{T}{U}} \quad \lin{\gvLinFun{T}{U}} \quad \un{\gvUnFun{T}{U}}
%% \end{array}
%% \]
%% The only unlimited type constructors are those for end input,
%% services, and unlimited functions.

%% Apart from the extensions, the two differences in the types of GV are
%% that there is no unit type (called $\gvUnitType$ in GV), and
%% $\gvEndInput$ is unlimited. We omit unit because it is isomorphic to
%% both $\gvEndInput$ and $\gvService{(\gvPlus{}{})}$.

%% TODO: fork vs with

%% The terms and typing rules for \hgv are given in
%% Figure~\ref{fig:hgv-typing}. The first three rules are structural. The
%% next six rules cover the non-session fragment of \hgv. The remaining
%% rules cover the session fragment of \hgv.

%% Notice that the non-session and session fragments are orthogonal, in
%% that the non-session rules mention only non-session type constructors,
%% and the session rules mention only session type constructors. This is
%% a useful property which does not hold of the original GV. As we shall
%% see, it enables us to compile away the non-session fragment into the
%% session fragment.

%% Vanilla GV, has session constructs $\key{receive}$ and
%% $\key{terminate}$, both of whose typing rules mention non-session
%% types.
%% \begin{mathpar}
%% \inferrule[Receive-$\otimes$]
%% {\gvj{\Phi}{M}{\gvInput{T}{S}}}
%% {\gvj{\Phi}{\gvReceive{M}}{\gvTimes{T}{S}}}

%% \inferrule[Terminate-$\otimes$]
%% {\gvj{\Phi}{M}{\gvTimes{T}{\gvEndInput}}}
%% {\gvj{\Phi}{\gvTerminate{M}}{T}}
%% \end{mathpar}
%% \hgv dispenses with $\key{terminate}$ by making $\gvEndOutput$
%% unlimited, and builds a pair binding into $\key{receive}$, thus
%% immediately eliminating the tensor.

%% The final five typing rules of Figure~\ref{fig:hgv-typing} extend the
%% functionality of \hgv with respect to GV: $\gvLink{M}{N}$ links
%% channel $M$ to channel $N$, $\gvSendType{S}{M}$ sends session type $S$
%% along $M$, $\gvReceiveType{M}$ receives a type along $M$,
%% $\gvServe{x}{M}$ defines a server as $M$ parameterised by channel $x$,
%% and $\gvRequest{M}$ requests a fresh instance of service $M$.
%% %

%% We argue that each of the five new constructs adds expressive power to
%% GV.
%% %
%% It seems clear that the ability to send and receive types adds
%% expressive power.
%% %
%% One can straightforwardly simulate $\gvLink{M}{N}$ in terms of other
%% constructs for monomorphic types, but not for polymorphic types.
%% %
%% There are parallels between servers and unlimited functions. One might
%% expect to be able to simulate the former in terms of the latter --- a
%% server is much like an unlimited function parameterised by a
%% channel. A key difference is that functions are not session types, so
%% cannot appear everywhere that a server type can.
%% %% Maybe not...
%% %%
%% %% We believe that servers can be simulated by unlimited functions,
%% %% but only if one performs a global translation.
%% %
%% %% A key difference is that we can disassociate a server declaration
%% %% ($\gvWith{s}{\dots}{\dots}$) from its definition
%% %% ($\gvServeOld{s}{x}{\dots}$). Thus, servers support a very limited
%% %% form of linear dynamic binding, which functions do not. We believe
%% %% that servers can be simulated by unlimited functions, but only if one
%% %% performs a global translation similar to closure conversion.
%% %
%% %% In fact, we will be more interested in going the other way,
%% %% translating away functions as sessions.
