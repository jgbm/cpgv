% -*- fill-column: 100 -*-

% easychair.tex,v 3.2 2012/05/15
%
% Select appropriate paper format in your document class as
% instructed by your conference organizers. Only withtimes
% and notimes can be used in proceedings created by EasyChair
%
% The available formats are 'letterpaper' and 'a4paper' with
% the former being the default if omitted as in the example
% below.
%
\documentclass{easychair}
%\documentclass[debug]{easychair}
%\documentclass[verbose]{easychair}
%\documentclass[notimes]{easychair}
%\documentclass[withtimes]{easychair}
%\documentclass[a4paper]{easychair}
%\documentclass[letterpaper]{easychair}

% This provides the \BibTeX macro
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{color}
\usepackage{doc}
\usepackage{makeidx}
\usepackage{stmaryrd}
\usepackage{mathpartir}
\usepackage{xspace}

% In order to save space or manage large tables or figures in a
% landcape-like text, you can use the rotating and pdflscape
% packages. Uncomment the desired from the below.
%
% \usepackage{rotating}
% \usepackage{pdflscape}

% If you plan on including some algorithm specification, we recommend
% the below package. Read more details on the custom options of the
% package documentation.
%
% \usepackage{algorithm2e}


%%% macros

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}

\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}

\newcommand{\bl}{\ba{@{}c@{}}}
\newcommand{\el}{\ea}

\newenvironment{equations}{\[\ba{@{}r@{~}c@{~}l@{}}}{\ea\]}
\newenvironment{eqs}{\ba{@{}r@{~}c@{~}l@{}}}{\ea}



\newcommand{\key}{\mathsf}

\newcommand{\set}[1]{\{ #1 \}}


\newcommand{\gvtocp}[1]{\llbracket{#1}\rrbracket}
\newcommand{\cptogv}[1]{\llparenthesis{#1}\rrparenthesis}

\newcommand{\row}[2]{\set{#1}_{#2}}

\newcommand{\gvOutput}[2]{\mathord{!}{#1}.{#2}}
\newcommand{\gvInput}[2]{\mathord{?}{#1}.{#2}}
\newcommand{\gvEndOutput}{\key{end}_!}
\newcommand{\gvEndInput}{\key{end}_?}
\newcommand{\gvPlus}[2]{\oplus \row{#1}{#2}}
\newcommand{\gvChoice}[2]{\binampersand \row{#1}{#2}}
\newcommand{\gvServer}[1]{\flat {#1}}
\newcommand{\gvService}[1]{\sharp {#1}}
\newcommand{\gvDual}[1]{\overline{#1}}
\newcommand{\gvOutputType}[2]{![{#1}].{#2}}
\newcommand{\gvInputType}[2]{?[{#1}].{#2}}

\newcommand{\cpj}[2]{{#1} \vdash {#2}}
\newcommand{\gvj}[3]{{#1} \vdash {#2} : {#3}}

\newcommand{\la}{l}
\newcommand{\G}{\Gamma}
\newcommand{\D}{\Delta}

\newcommand{\lolli}{\multimap}

\newcommand{\gvLinFun}[2]{{#1} \lolli {#2}}
\newcommand{\gvUnFun}[2]{{#1} \to {#2}}
\newcommand{\gvTimes}[2]{{#1} \otimes {#2}}
\newcommand{\gvUnitType}{\key{Unit}}

\newcommand{\gvUnit}{\key{unit}}
\newcommand{\gvLink}[2]{\key{link}~{#1}~{#2}}
\newcommand{\gvLam}[2]{\lambda {#1}.{#2}}
\newcommand{\gvApp}[2]{{#1}~{#2}}
\newcommand{\gvPair}[2]{({#1},{#2})}
\newcommand{\gvLet}[3]{\key{let}~{#1}={#2}~\key{in}~{#3}}
\newcommand{\gvSend}[2]{\key{send}~{#1}~{#2}}
\newcommand{\gvReceive}[1]{\key{receive}~{#1}}
\newcommand{\gvSelect}[2]{\key{select}~{#1}~{#2}}
\newcommand{\gvCase}[2]{\key{case}~{#1}~\key{of}~{#2}}

\newcommand{\gvFork}[2]{\key{fork}~{#1}.{#2}}

\newcommand{\gvWith}[3]{\key{with}~{#1}~\key{connect}~{#2}~\key{to}~{#3}}
\newcommand{\gvTerminate}[1]{\key{terminate}~{#1}}


% receive with continuation
\newcommand{\gvReceiveK}[4]{\gvLet{\gvPair{#1}{#2}}{\gvReceive{#3}}{#4}}

\newcommand{\gvSendType}[2]{\key{sendType}~{#1}~{#2}}
\newcommand{\gvReceiveType}[2]{\key{receiveType}~{#1}~{#2}}


\newcommand{\gvServeOld}[3]{\key{serve'}~{#1}({#2})={#3}}

\newcommand{\gvServe}[2]{\key{serve}~{#1}.{#2}}
\newcommand{\gvRequest}[1]{\key{request}~{#1}}

\newcommand{\cpLink}[2]{{#1} \leftrightarrow {#2}}
\newcommand{\cpCut}[3]{\nu {#1}.({#2} \mid {#3})}
\newcommand{\cpOutput}[4]{{#1}[{#2}].({#3} \mid {#4})}
\newcommand{\cpInput}[3]{{#1}({#2}).{#3}}
\newcommand{\cpInject}[3]{{#1}[{#2}].{#3}}
\newcommand{\cpCase}[2]{{#1}.\key{case}~{#2}}
\newcommand{\cpServe}[3]{!{#1}({#2}).{#3}}
\newcommand{\cpRequest}[3]{?{#1}[{#2}].{#3}}
\newcommand{\cpEmptyOut}[1]{{#1}[].0}
\newcommand{\cpEmptyIn}[2]{{#1}().{#2}}
\newcommand{\cpSendType}[3]{{#1}[{#2}].{#3}}
\newcommand{\cpReceiveType}[3]{{#1}({#2}).{#3}}


\newcommand{\cpTimes}[2]{{#1} \otimes {#2}}
\newcommand{\cpPar}[2]{{#1} \mathbin{\bindnasrepma} {#2}}
\newcommand{\cpPlus}[2]{\oplus \row{#1}{#2}}
\newcommand{\cpWith}[2]{\binampersand \row{#1}{#2}}
\newcommand{\cpOne}{1}
\newcommand{\cpBottom}{\bot}
\newcommand{\cpOfCourse}[1]{\mathord{!}{#1}}
\newcommand{\cpWhyNot}[1]{\mathord{?}{#1}}
\newcommand{\cpDual}[1]{{#1}^\bot}
\newcommand{\cpExists}[2]{\exists {#1}.{#2}}
\newcommand{\cpForall}[2]{\forall {#1}.{#2}}

\newcommand{\cpZero}{0}    % 0   == +{}
\newcommand{\cpTop}{\top}  % top == &{}

\newcommand{\un}[1]{\mathit{un}(#1)}
\newcommand{\lin}[1]{\mathit{lin}(#1)}

\newcommand{\FV}[1]{\mathit{FV}(#1)}
\newcommand{\subst}[3]{{#1}[{#2}/{#3}]}

\newcommand{\gvtocps}[1]{\gvtocp{#1}}
\newcommand{\gvtocpd}[1]{\gvtocp{#1}}

\newcommand{\cpMix}[2]{({#1} \mid {#2})}
\newcommand{\cpCutOutput}[5]{{#2}[{#3}].\nu{#1}.\cpMix{#4}{#5}}

\newcommand{\last}{LAST\xspace}

\newcommand{\hgv}{HGV\xspace}
\newcommand{\hgvpi}{HGV$\pi$\xspace}

\newcommand{\lampi}[1]{({#1})^\star}
\newcommand{\hgvcp}[1]{\llbracket{#1}\rrbracket}

\newcommand{\hgvcpl}{\left\llbracket}
\newcommand{\hgvcpr}{\right\rrbracket}

%\newcommand{\infr}[3][]{\inferrule*[right={#1}]{#2}{#3}}
%\newcommand{\infr}[3][]{\inferrule[#1]{#2}{#3}}
\newcommand{\infr}[3][]{\inferrule{#2}{#3}} % save space by getting rid of labels

\newcommand{\todo}[1]{\textbf{\color{red}TODO: #1}}

%\makeindex

%% Document
%%
\begin{document}

\title{Sessions as propositions}

% \titlerunning{} has to be set to either the main title or its shorter
% version for the running heads. When processed by
% EasyChair, this command is mandatory: a document without \titlerunning
% will be rejected by EasyChair

\titlerunning{Sessions as propositions}

% Authors are joined by \and. Their affiliations are given by \inst, which indexes
% into the list defined using \institute
%
\author{
  Sam Lindley
  \and
  J. Garrett Morris
}
%% \author{
%% Serguei A. Mokhov\inst{1}\thanks{Designed and implemented the class style}
%% \and
%%     Geoff Sutcliffe\inst{2}\thanks{Did numerous tests and provided a lot of suggestions}
%% \and
%%    Andrei Voronkov\inst{3}\thanks{Masterminded EasyChair and created versions
%%      3.0--3.1 of the class style}\\
%% \and
%%    Graham Gough\inst{3}\thanks{Changed author list format.}\\
%% }


% Institutes for affiliations are also joined by \and,
\institute{The University of Edinburgh \\
           \email{Sam.Lindley@ed.ac.uk, Garrett.Morris@ed.ac.uk}
}
%% \institute{
%%   Concordia University,
%%   Montreal, Quebec, Canada\\
%%   \email{mokhov@cse.concordia.ca}
%% \and
%%    University of Miami,
%%    Miami, Florida, U.S.A.\\
%%    \email{geoff@cs.miami.edu}\\
%% \and
%%    University of Manchester,
%%    Manchester, U.K.\\
%%    \email{andrei@voronkov.com, graham@cs.man.ac.uk}\\
%%  }
%  \authorrunning{} has to be set for the shorter version of the authors' names;
% otherwise a warning will be rendered in the running heads. When processed by
% EasyChair, this command is mandatory: a document without \authorrunning
% will be rejected by EasyChair

\authorrunning{Lindley and Morris}


\clearpage

\maketitle


\begin{abstract}
Recently, Wadler presented a continuation-passing translation from a session-typed functional
language, called GV, to a process calculus, called CP, based on classical linear logic. However,
this translation is one-way: CP is more expressive than GV. We propose an extension to GV, called
\hgv, which bridges the expressiveness gap.
%%  We provide direct translations from CP into the session
%% fragment of \hgv, called \hgvpi, and from \hgv to \hgvpi. We prove that the original
%% continuation-passing translation from GV to CP factors through the direct translation to \hgvpi. The
%% new translations shed light both on the original translation from GV to CP, and on the limitations
%% in expressiveness of GV.
\end{abstract}


%\section{To mention}
%
%Processing in EasyChair - number of pages.
%
%Examples of how EasyChair processes papers. Caveats (replacement of EC
%class, errors).

% \pagestyle{empty}


\section{Introduction}

Linear logic has long been regarded as a potential typing discipline for concurrent programming.
Girard~\cite{Girard87} observes that the connectives of linear logic can be interpreted as parallel
computation. Abramsky~\cite{Abramsky92} and Bellin and Scott~\cite{BellinScott94} interpret linear
logic proofs as processes in Milner's $\pi$-calculus.
%
%% While they provide $\pi$-calculus
%% interprations of all linear logic proofs, they do not provide a proof-theoretic interpretation for
%% arbitrary $\pi$-calculus terms.
%
Caires and Pfenning~\cite{CairesPfenning10} observe that the multiplicative connectives can be
interpreted as session types. Their process calculus, based on intuitionistic linear logic, is
closer to $\pi$-calculus than traditional session-typed languages. Wadler~\cite{Wadler12} shows that
a core session-typed linear functional language, GV, patterned after a similar language due to Gay
and Vasconcelos~\cite{GayVasconcelos10}, may be translated into a process calculus, CP, whose terms
are proofs in classical linear logic.
%
%% Wadler's work shows that linear session-typed programs can be interpreted as proofs in classical
%% linear logic.
%
As GV is less expressive than CP, there are proofs which do not correspond to any GV program.

Our primary contribution is an extended version of GV, called \hgv, sufficient to express all proofs
in classical linear logic.
%
We identify the session-typed fragment of \hgv, called \hgvpi and
%
give type-preserving translations from \hgv to \hgvpi ($\lampi{-}$), from \hgvpi to CP
($\hgvcp{-}$), and from CP to \hgvpi ($\cptogv{-}$).
%
%% Factoring the translation of \hgv into CP through $\lampi{-}$ simplifies the presentation, and
%% illuminates regularities that are not apparent in Wadler's original translation.
%
We prove that \hgv, \hgvpi, and CP are all equally expressive.



%% %To demonstrate \hgv's expressiveness,
%% We give both a direct translation from CP into \hgv and extend Wadler's continuation-passing
%% translation from GV into CP to one from \hgv into CP.

%% As CP only describes process communication, our translation maps all of CP into the session-oriented
%% fragment of HGV (which we call \hgvpi), avoiding the functional features of \hgv entirely. Thus, by
%% composing the translation from \hgv to CP with that from CP to \hgvpi, we can obtain a translation
%% of the functional features of \hgv into their process counterparts
%% %%
%% %% Because the translation from \hgv to CP is continuation-passing, the composed translation from \hgv
%% %% into \hgvpi is also continuation-passing.
%% %%
%% As an alternative approach, we give a direct translation from \hgv to \hgvpi. Our translations
%% illustrate several points. First, they show the increased expressivity of \hgv: as GV's session
%% types contains no notion of replication or recursion, they cannot express the non-linear features of
%% its functional fragment; \hgv, in contrast, can be reduced to \hgvpi. Second, factoring the
%% translation of \hgv into CP over that from \hgv into \hgvpi simplifies the translation, and
%% illuminates regularities that are not apparent in Wadler's original translation.

\section{The \hgv Language}

This section describes our session-typed language \hgv, constrasting it with Gay and Vasconcelos's
functional language for asynchronous session types~\cite{GayVasconcelos10}, which we call \last, and
Wadler's GV~\cite{Wadler12}. 
%% \hgv's features are closer to those of \last, but it retains a type
%% system corresponding closely to linear logic. 
In designing \hgv, we have sometimes opted for programming convenience over uniformity, while
insisting on a tight correspondence with linear logic.
%
The session types of \hgv are given by the following grammar.
\begin{equations}
  S & ::= & \gvOutput{T}{S} \mid \gvInput{T}{S} \mid
           \gvPlus{\la_i:S_i}{i} \mid \gvChoice{\la_i:S_i}{i} \mid
           \gvEndOutput \mid \gvEndInput
    \mid X \mid \gvDual{X} \mid
            \gvOutputType{X}{S} \mid \gvInputType{X}{S} \mid
            \gvServer{S} \mid \gvService{S}
\end{equations}%
Types for input ($\gvInput{T}{S}$), output ($\gvOutput{T}{S}$), selection ($\gvPlus{\la_i:S_i}{i}$)
and choice ($\gvChoice{\la_i:S_i}{i}$) are standard. Like GV, but unlike \last, we distinguish
output ($\gvEndOutput$) and input ($\gvEndInput$) session ends; this matches the situation in linear
logic, where there is no conveniently self-dual proposition to represent the end of a
session. Variables and their duals ($X,\gvDual{X}$) and type input ($\gvInputType{X}{S}$) and
output ($\gvOutputType{X}{S}$), permit definition of polymorphic sessions. We include a notion of
replicated sessions, corresponding to exponentials in linear logic: a session of type
$\gvService{S}$ is a ``service'', providing any number of copies of a session of type $S$; a session
of type $\gvServer{S}$ is the ``server'' providing that service.
%
Duals (written overline) for \hgv session types are standard:
%, with the expected addition for services and theirservers:
\[
\bl
  \gvDual{\gvOutput{T}{S}} = \gvInput{T}{\gvDual{S}}
\qquad
  \gvDual{\gvPlus{\la_i:S_i}{i}} = \gvChoice{\la_i:\gvDual{S_i}}{i}
\qquad
  \gvDual{\gvEndOutput} = \gvEndInput
\qquad
  \gvDual{\gvOutputType{X}{S}} = \gvInputType{X}{\gvDual{S}}
\qquad
  \gvDual{\gvService{S}} = \gvServer{\gvDual{S}}
\\
  \gvDual{\gvInput{T}{S}} = \gvOutput{T}{\gvDual{S}}
\qquad
  \gvDual{\gvChoice{\la_i:S_i}{i}} = \gvPlus{\la_i:\gvDual{S_i}}{i}
\qquad
  \gvDual{\gvEndInput} = \gvEndOutput
\qquad
  \gvDual{\gvInputType{X}{S}} = \gvOutputType{X}{\gvDual{S}}
\qquad
  \gvDual{\gvServer{S}} = \gvService{\gvDual{S}}
\\
\el
\]
Note that dualisation leaves input and output types unchanged.  In addition to sessions, \hgv's
types include linear pairs, and linear and unlimited functions:
\[
T,U,V ::= S \mid \gvTimes{T}{U} \mid \gvLinFun{T}{U} \mid \gvUnFun{T}{U}
\]
%
Every type $T$ is either linear ($\lin{T}$) or unlimited ($\un{T}$); the only unlimited types are
services ($\un{\gvService{S}}$), unlimited functions ($\un{\gvUnFun{T}{U}}$), and end input session
types ($\un{\gvEndInput}$).
%
In GV, $\gvEndInput$ is linear. We choose to make it unlimited in \hgv because then we can dispense
with GV's explicit $\key{terminate}$ construct,
%% yielding a language that is more convenient to
%% program with,
while maintaining a strong correspondence with CP---$\gvEndInput$ corresponds to $\cpBottom$ in CP,
for which weakening and contraction rules are derivable.

\begin{figure}
\begin{mathpar}
\infr[Id]
{ }
{\gvj{x:T}{x}{T}}

\infr[Weaken]
{\gvj{\Phi}{N}{U} \\ \un{T}}
{\gvj{\Phi,x:T}{N}{U}}

\infr[Contract]
{\gvj{\Phi,x:T,x':T}{N}{U} \\ \un{T}}
{\gvj{\Phi,x:T}{\subst{N}{x}{x'}}{U}}
\\

%% \end{mathpar}%
%% \hrule
%% \begin{mathpar}
\infr[Send]
{\gvj{\Phi}{M}{T} \\ \gvj{\Psi}{N}{\gvOutput{T}{S}}}
{\gvj{\Phi}{\gvSend{M}{N}}{S}}
%% \infr[Receive]
%% {\gvj{\Phi}{M}{\gvInput{T}{S}} \\ \gvj{\Psi,x:T,y:S}{N}{V}}
%% {\gvj{\Phi,\Psi}{\gvReceiveK{x}{y}{M}{N}}{V}}

\infr[Receive]
{\gvj{\Phi}{M}{\gvInput{T}{S}}}
{\gvj{\Phi}{\gvReceive{M}}{\gvTimes{T}{S}}}
\\

\infr[Select]
{\gvj{\Phi}{M}{\gvPlus{\la_i:S_i}{i}}}
{\gvj{\Phi}{\gvSelect{\la_j}{M}}{S_j}}

\infr[Case]
{\gvj{\Phi}{M}{\gvChoice{\la_i:S_i}{i}} \\ \row{\gvj{\Psi,x:S_i}{N_i}{T}}{i}}
{\gvj{\Phi,\Psi}{\gvCase{M}{\row{\la_i(x).N_i}{i}}}{T}}
\\

\infr[Fork]
{\gvj{\Phi,x:S}{M}{\gvEndOutput}}
{\gvj{\Phi}{\gvFork{x}{M}}{\gvDual{S}}}

%% \infr[Connect]
%% {\gvj{\Phi,x:S}{M}{\gvEndOutput} \\ \gvj{\Psi,x:\gvDual{S}}{N}{T}}
%% {\gvj{\Phi,\Psi}{\gvWith{x}{M}{N}}{T}}

\infr[Link]
{\gvj{\Phi}{M}{S} \\ \gvj{\Phi}{N}{\gvDual{S}}}
{\gvj{\Phi}{\gvLink{M}{N}}{\gvEndOutput}}

\infr[SendType]
{\gvj{\Phi}{M}{\gvOutputType{X}{S}}}
{\gvj{\Phi}{\gvSendType{S}{M}}{\subst{S'}{S}{X}}}

\infr[ReceiveType]
{\gvj{\Phi}{M}{\gvInputType{X}{S}} \\ X \notin \FV{\Phi}}
{\gvj{\Phi}{\gvReceiveType{X}{M}}{S}}

\infr[Serve]
{\gvj{\Phi,x : S}{M}{\gvEndOutput} \\ \un{\Phi}}
{\gvj{\Phi}{\gvServe{x}{M}}{\gvService{\gvDual{S}}}}

\infr[Request]
{\gvj{\Phi}{M}{\gvService{S}}}
{\gvj{\Phi}{\gvRequest{M}}{S}}
\end{mathpar}%

\caption{Typing rules for \hgv}
\label{fig:hgv-typing}

\end{figure}

Figure~\ref{fig:hgv-typing} gives the terms and typing rules for the session-typed fragment of \hgv;
the rules for its functional fragment are standard, and included in Appendix~\ref{sect:hgv-omitted}.
The $\key{fork}$ construct fills the role of GV's $\key{with}\dots\key{connect}$ structure, but
without the asymmetry of the latter.  The two are interdefinable, as follows:
\[
\gvFork{x}{M} \equiv \gvWith{x}{M}{x} \qquad \gvWith{x}{M}{N} \equiv \gvLet{x}{\gvFork{x}{M}}{N}
\]
We add a construct $\gvLink{M}{N}$ to implement channel forwarding; this form is provided in neither
GV nor \last, but is necessary to match the expressive power of CP. we add terms $\gvSendType{S}{M}$
and $\gvReceiveType{X}{M}$ to provide session polymorphism, and $\gvServe{x}{M}$ and $\gvRequest{M}$
for replicated sessions. Note that, as the body $M$ of $\gvServe{x}{M}$ may be arbitrarily
replicated, it can only refer to the unlimited portion of the environment.
%
The rule for $\key{serve}$ parallels that for $\key{fork}$: as $\gvFork{x}{M}$ returns the dual of
the channel defined by $M$, so $\gvServe{x}{M}$ returns the dual of the server defined by
replicating the behavior of $M$.

%% BEGONE, FOUL BEAST!
%%
%% The rule for $\key{serve}$ is anomolous because it mentions a service type but no server type. We
%% choose the current rule because we find it more convenient than the more uniform alternative:
%% \[
%% \bl
%% \infr[Serve']
%% {\gvj{\Phi}{M}{\gvServer{S}} \\ \gvj{\Psi,y:S}{N}{\gvEndOutput} \\ \un{\Psi}}
%% {\gvj{\Phi,\Psi}{\gvServeOld{M}{x}{N}}{\gvEndOutput}}
%% \\[3ex]
%% \gvServe{y}{M} \equiv \gvFork{x}{\gvServeOld{x}{y}{M}}
%% \qquad
%% \gvServeOld{M}{x}{N} \equiv \gvLink{M}{(\gvServe{x}{N})}
%% \\
%% \el
%% \]

%% We argue that the new features add expressive power to \hgv. Channel forwarding may be implemented in
%% a type-directed fashion for any monomorphic channel in either GV or \last, but neither allows a
%% generic description of forwarding, nor one that would account for polymorphic sessions. GV supports
%% no notion of replication; \last provides recursive sessions instead of replication, which do not
%% admit an interpretation in linear logic.

% \todo{Say something about unlimited functions and replication.}
% Or not...


\section{From \hgv to \hgvpi}

The language \hgvpi is the restriction of \hgv to session types, that is, \hgv without $\lolli$,
$\to$, or $\otimes$. In order to avoid $\otimes$, we disallow plain $\gvReceive{M}$, but do permit
it to be fused with a pair elimination $\gvReceiveK{x}{y}{M}{N}$. We can simulate all non-session
types as session types via a translation from \hgv to \hgvpi. The translation on types is given by
the homomorphic extension of the following equations:
\[
\lampi{\gvLinFun{T}{U}} = \gvOutput{\lampi{T}}{\gvDual{\lampi{U}}} \qquad
\lampi{\gvUnFun{T}{U}} = \gvService{(\gvOutput{\lampi{T}}{\gvDual{\lampi{U}}})} \qquad
\lampi{\gvTimes{T}{U}} = \gvInput{\lampi{T}}{\gvDual{\lampi{U}}}
\]%
Each target type is the \emph{interface} to the simulated source type. A linear function is
simulated by input on a channel; its interface is output on the other end of the channel. An
unlimited function is simulated by a server; its interface is the service on the other end of that
channel. A tensor is simulated by output on a channel; its interface is input on the other end of
that channel.
%
This duality between implementation and interface explains the flipping of types in Wadler's
original CPS translation from GV to CP.
%
The translation on terms is given by the homomorphic extension of the following equations:
\begin{equations}
\lampi{\gvLam{x}{M}} &=& \gvFork{z}{\gvLet{\gvPair{x}{z}}{\gvReceive{z}}{\gvLink{\lampi{M}}{z}}} \\
\lampi{\gvApp{L}{M}} &=& \gvSend{\lampi{M}}{\lampi{L}} \\
\lampi{\gvTimes{M}{N}} &=&
  \gvFork{z}
    {\gvLink{(\gvSend{\lampi{M}}{z})}{\lampi{N}}} \\
\lampi{\gvLet{\gvPair{x}{y}}{M}{N}} &=&
    \gvLet{\gvPair{x}{y}}{\gvReceive{\lampi{M}}}{\lampi{N}} \\
\lampi{L : \gvUnFun{T}{U}} &=&
  \gvFork{z}{\gvLink{z}{(\gvServe{y}{\gvLink{\lampi{L}}{y}})}} \\
\lampi{L : \gvLinFun{T}{U}} &=& \gvRequest{\lampi{L}} \\
\lampi{\gvReceive{M}} &=& \lampi{M} \\
\end{equations}%
Formally, this is a translation on derivations. We write type annotations for the cases of $\to$
introduction and elimination. For all other cases, it is unambiguous to give the translation on
plain term syntax. Each introduction form translates to an interface $\gvFork{z}{M}$ of type
$\gvDual{S}$, where $M : \gvEndOutput$ provides the implementation, with $z : S$ bound in $M$.
%
The translation on contexts is pointwise.
%% \begin{equations}
%% \lampi{x_1:T_1, \dots, x_n:T_n} &=& x_1:\lampi{T_1}, \dots, x_n:\lampi{T_n} \\
%% \end{equations}%
%It is straightforward to verify that
The translation preserves typing.
\begin{theorem}
If $\gvj{\Phi}{M}{T}$ then $\gvj{\lampi{\Phi}}{\lampi{M}}{\lampi{T}}$.
\end{theorem}

%% \begin{equations}
%% \lampi{\gvj{\Phi}{M}{T}} &=& \gvj{\lampi{\Phi}}{\lampi{M}}{\lampi{T}} \\
%% \end{equations}%



\section{From \hgvpi to CP}

Due to lack of space we omit a complete description of CP. We have included the typing rules in
Appendix~\ref{sect:cp-typing}; a full description, including the definition of the cut relation
$\Longrightarrow$, can be found in Wadler's work~\cite{Wadler12}. Note that the propositions of CP
are exactly those of classical linear logic, as are the cut rules (if we ignore the terms). Thus, CP
enjoys all of the standard meta theoretic properties of classical linear logic.
%% , including confluence and weak
%% normalisation.
%
A minor syntactic difference between our presentation and Wadler's is that our sum ($\oplus$) and
choice ($\binampersand$) types are $n$-ary, as with the corresponding session types in \hgv.
%% The choice is superficial, but we choose the $n$-ary variants for greater uniformity between
%% CP and \hgv.
%
Duality on CP types ($\cpDual{(-)}$) is standard.
\[
\bl
  \cpDual{(\cpTimes{A}{B})} = \cpPar{\cpDual{A}}{\cpDual{B}}
~~
  \cpDual{(\cpPlus{\la_i:A_i}{i})} = \cpWith{\la_i:\cpDual{A_i}}{i}
~~
  \cpDual{\cpOne} = \cpBottom
~~
  \cpDual{(\cpExists{X}{B})} = \cpForall{X}{\cpDual{B}}
~~
  \cpDual{(\cpOfCourse{A})} = \cpWhyNot{\cpDual{A}}
\\
  \cpDual{(\cpPar{A}{B})} = \cpTimes{\cpDual{A}}{\cpDual{B}}
~~
  \cpDual{(\cpWith{\la_i:A_i}{i})} = \cpPlus{\la_i:\cpDual{A_i}}{i}
~~
  \cpDual{\cpBottom} = \cpOne
~~
  \cpDual{(\cpForall{X}{B})} = \cpExists{X}{\cpDual{B}}
~~
  \cpDual{(\cpWhyNot{A})} = \cpOfCourse{\cpDual{A}}
\\
\el
\]

We now give a translation from \hgvpi to CP. Post composing this with the embedding of \hgv in
\hgvpi yields a semantics for \hgv.
%
The translation on session types is as follows:
%% \[
%% \ba{@{}c@{\qquad}c@{\qquad}c@{}}
%% \begin{eqs}
%% \hgvcp{\gvOutput{T}{S}}         &=& \cpTimes{\cpDual{\hgvcp{T}}}{\hgvcp{S}} \\
%% \hgvcp{\gvInput{T}{S}}          &=& \cpPar{\hgvcp{T}}{\hgvcp{S}} \\
%% \hgvcp{\gvPlus{\la_i:S_i}{i}}   &=& \cpPlus{\la_i:\hgvcp{S_i}}{i} \\
%% \hgvcp{\gvChoice{\la_i:S_i}{i}} &=& \cpWith{\la_i:\hgvcp{S_i}}{i} \\
%% \end{eqs}
%% &
%% \begin{eqs}
%% \hgvcp{\gvEndOutput}  &=& \cpOne \\
%% \hgvcp{\gvEndInput}   &=& \cpBottom \\
%% \hgvcp{\gvServer{S}}  &=& \cpOfCourse{\hgvcp{S}} \\
%% \hgvcp{\gvService{S}} &=& \cpWhyNot{\hgvcp{S}} \\
%% \end{eqs}
%% &
%% \begin{eqs}
%% \hgvcp{\gvOutputType{X}{S}} &=& \cpExists{X}{\hgvcp{S}} \\
%% \hgvcp{\gvInputType{X}{S}}  &=& \cpForall{X}{\hgvcp{S}} \\
%% \hgvcp{X}                   &=& X \\
%% \hgvcp{\gvDual{X}}          &=& \cpDual{X} \\
%% \end{eqs}
%% \ea
%% \]
\[
\ba{@{}c@{\qquad}c@{\qquad}c@{\qquad}c@{}}
\begin{eqs}
\hgvcp{\gvOutput{T}{S}}         &=& \cpTimes{\cpDual{\hgvcp{T}}}{\hgvcp{S}} \\
\hgvcp{\gvInput{T}{S}}          &=& \cpPar{\hgvcp{T}}{\hgvcp{S}} \\
\hgvcp{\gvEndOutput}  &=& \cpOne \\
\end{eqs}
&
\begin{eqs}
\hgvcp{\gvPlus{\la_i:S_i}{i}}   &=& \cpPlus{\la_i:\hgvcp{S_i}}{i} \\
\hgvcp{\gvChoice{\la_i:S_i}{i}} &=& \cpWith{\la_i:\hgvcp{S_i}}{i} \\
\hgvcp{\gvEndInput}   &=& \cpBottom \\
\end{eqs}
&
\begin{eqs}
\hgvcp{\gvServer{S}}  &=& \cpOfCourse{\hgvcp{S}} \\
\hgvcp{\gvService{S}} &=& \cpWhyNot{\hgvcp{S}} \\
\hgvcp{X}                   &=& X \\
\end{eqs}
&
\begin{eqs}
\hgvcp{\gvOutputType{X}{S}} &=& \cpExists{X}{\hgvcp{S}} \\
\hgvcp{\gvInputType{X}{S}}  &=& \cpForall{X}{\hgvcp{S}} \\
\hgvcp{\gvDual{X}}          &=& \cpDual{X} \\
\end{eqs}
\ea
\]
The translation is homomorphic except for output, where the output type is dualised. This accounts
for the discrepancy between $\gvDual{\gvOutput{T}{S}} = \gvInput{T}{\gvDual{S}}$ and
$\cpDual{(\cpTimes{A}{B})} = \cpPar{\cpDual{A}}{\cpDual{B}}$.
%
%% We could just have well have decided to dualise input types instead of output types in our
%% translation.

The translation on terms is formally specified as a CPS translation on derivations as in Wadler's
presentation. Due to lack of space, we write only the translation of weakening and contraction for
$\gvEndInput$ in this form. The other constructs depend only on the immediate syntactic structure,
so we can abbreviate their translations as mappings on plain terms.
%
\begin{mathpar}
\hgvcpl \inferrule{\gvj{\Phi}{N}{S}}{\gvj{\Phi,x:\gvEndInput}{N}{S}} \hgvcpr z =
  \inferrule
    {\cpj{\hgvcp{N}z}{\hgvcp{\Phi},z:\cpDual{\hgvcp{S}}}}
    {\cpj{\cpEmptyIn{x}{\hgvcp{N}z}}{\hgvcp{\Phi},x:\cpBottom,z:\cpDual{\hgvcp{S}}}}
\\
\hgvcpl \inferrule{\gvj{\Phi,x:\gvEndInput,x':\gvEndInput}{N}{S}}
                          {\gvj{\Phi,x:\gvEndInput}{\subst{N}{x}{x'}}{S}} \hgvcpr z =
  \inferrule
    {\cpj{\hgvcp{N}z}{\hgvcp{\Phi},x:\cpBottom,x':\cpBottom,z:\cpDual{\hgvcp{S}}}}
    {\cpj{\cpCut{x'}{\hgvcp{N}z}{\cpEmptyOut{x'}}}{\hgvcp{\Phi},x:\cpBottom,z:\cpDual{\hgvcp{S}}}}
\end{mathpar}
\vspace{-1ex}
\begin{equations}
\hgvcp{x}z &=& \cpLink{x}z \\
\hgvcp{\gvSend{M}{N}}z &=& \cpCut{x}{\cpOutput{x}{y}{\hgvcp{M}y}{\cpLink{x}{z}}}{\hgvcp{N}x} \\
\hgvcp{\gvReceiveK{y}{x}{M}{N}}z &=&
  \cpCut{x}{\hgvcp{M}x}{\cpInput{x}{y}{\hgvcp{N}z}} \\
%% \end{equations}%
%% \begin{equations}
\hgvcp{\gvSelect{\la}{M}}z &=&
  \cpCut{x}{\hgvcp{M}x}{\cpInject{x}{\la}{\cpLink{x}{z}}} \\
\hgvcp{\gvCase{M}{\row{\la_i(x).N_i}{i}}}z &=&
  \cpCut{x}{\hgvcp{M}x}{\cpCase{x}{\row{\la_i.N_i}{i}}} \\
\hgvcp{\gvFork{x}{M}}z &=&
  \cpCut{x}{\cpCut{y}{\hgvcp{M}y}{\cpEmptyOut{y}}}{\cpLink{x}{z}} \\
\hgvcp{\gvLink{M}{N}}z &=& \cpEmptyIn{z}{\cpCut{x}{\hgvcp{M}x}{\hgvcp{N}x}} \\
\hgvcp{\gvSendType{S}{M}}z &=&
  \cpCut{x}{\hgvcp{M}x}{\cpSendType{x}{\hgvcp{S}}{\cpLink{x}{z}}} \\
\hgvcp{\gvReceiveType{X}{M}}z &=&
  \cpCut{x}{\hgvcp{M}x}{\cpReceiveType{x}{X}{\cpLink{x}{z}}} \\
\hgvcp{\gvServe{y}{M}}z &=&
   \cpServe{z}{y}
      {\cpCut{x}{\hgvcp{M}x}{\cpEmptyOut{x}}} \\
\hgvcp{\gvRequest{M}}z &=& \cpCut{x}{\hgvcp{M}x}{\cpRequest{x}{y}{\cpLink{y}{z}}} \\
\end{equations}%
Channel $z$ provides a continuation, consuming the output of the process representing the original
\hgvpi term.
%
The translation on contexts is pointwise.
%% \begin{equations}
%% \hgvcp{x_1:T_1, \dots, x_n:T_n} &=& x_1:\hgvcp{T_1}, \dots, x_n:\hgvcp{T_n} \\
%% \end{equations}%
%It is straightforward to verify that
The translation preserves typing.
\begin{theorem}
If $\gvj{\Phi}{M}{S}$ then $\cpj{\hgvcp{M}}{\hgvcp{\Phi},z:\cpDual{\hgvcp{S}}}$.
\end{theorem}


\section{From CP to \hgvpi}

%In order to demonstrate that CP and \hgvpi (and indeed \hgv) are equally expressive
We now present the translation $\cptogv{-}$ from CP to \hgvpi. The translation on types is as
follows.
%% \[
%% \ba{@{}c@{\qquad}c@{\qquad}c@{}}
%% \begin{eqs}
%% \cptogv{\cpTimes{A}{B}} &=& \gvOutput{\gvDual{\cptogv{A}}}{\cptogv{B}} \\
%% \cptogv{\cpPar{A}{B}}   &=& \gvInput{\cptogv{A}}{\cptogv{B}} \\
%% \cptogv{\cpPlus{\la_i:A_i}{i}} &=& \gvPlus{\la_i:\cptogv{A_i}}{i}  \\
%% \cptogv{\cpWith{\la_i:A_i}{i}} &=& \gvChoice{\la_i:\cptogv{A_i}}{i} \\
%% \end{eqs}
%% &
%% \begin{eqs}
%% \cptogv{\cpOne}         &=& \gvEndOutput \\
%% \cptogv{\cpBottom}      &=& \gvEndInput \\
%% \cptogv{\cpOfCourse{A}} &=& \gvServer{\cptogv{A}} \\
%% \cptogv{\cpWhyNot{A}}   &=& \gvService{\cptogv{A}} \\
%% \end{eqs}
%% &
%% \begin{eqs}
%% \cptogv{\cpExists{X}{A}} &=& \gvOutputType{X}{\cptogv{A}} \\
%% \cptogv{\cpForall{X}{A}} &=& \gvInputType{X}{\cptogv{A}} \\
%% \cptogv{X}               &=& X \\
%% \cptogv{\cpDual{X}}      &=& \gvDual{X} \\
%% \end{eqs}
%% \ea
%% \]
\[
\ba{@{}c@{\qquad}c@{\qquad}c@{\qquad}c@{}}
\begin{eqs}
\cptogv{\cpTimes{A}{B}} &=& \gvOutput{\gvDual{\cptogv{A}}}{\cptogv{B}} \\
\cptogv{\cpPar{A}{B}}   &=& \gvInput{\cptogv{A}}{\cptogv{B}} \\
\cptogv{\cpOne}         &=& \gvEndOutput \\
\end{eqs}
&
\begin{eqs}
\cptogv{\cpPlus{\la_i:A_i}{i}} &=& \gvPlus{\la_i:\cptogv{A_i}}{i}  \\
\cptogv{\cpWith{\la_i:A_i}{i}} &=& \gvChoice{\la_i:\cptogv{A_i}}{i} \\
\cptogv{\cpBottom}      &=& \gvEndInput \\
\end{eqs}
&
\begin{eqs}
\cptogv{\cpExists{X}{A}} &=& \gvOutputType{X}{\cptogv{A}} \\
\cptogv{\cpForall{X}{A}} &=& \gvInputType{X}{\cptogv{A}} \\
\cptogv{X}               &=& X \\
\end{eqs}
&
\begin{eqs}
\cptogv{\cpWhyNot{A}}    &=& \gvService{\cptogv{A}} \\
\cptogv{\cpOfCourse{A}}  &=& \gvServer{\cptogv{A}} \\
\cptogv{\cpDual{X}}      &=& \gvDual{X} \\
\end{eqs}
\ea
\]
The translation on terms is as follows:
\[
%\ba{@{}c@{\qquad}c@{\qquad}c@{}}
\begin{eqs}
  %% \gvLet{z}{\gvTerminate{x}}{\cptogv{P}} \\[1ex]
%\end{eqs}
%&
%\begin{eqs}
\cptogv{\cpOutput{x}{y}{P}{Q}} &=&
  \gvLet{x}{\gvSend{(\gvFork{y}{\cptogv{P}})}{x}}{\cptogv{Q}} \\
\cptogv{\cpInput{x}{y}{P}} &=&
  \gvLet{\gvPair{y}{x}}{\gvReceive{x}}{\cptogv{P}} \\
\cptogv{\cpInject{x}{\la}{P}} &=&
  \gvLet{x}{\gvSelect{\la}{x}}{\cptogv{P}} \\
\cptogv{\cpCase{x}{\row{\la_i.P_i}{i}}} &=&
  \gvCase{x}{\row{\la_i(x).\cptogv{P_i}}{i}} \\
\cptogv{\cpEmptyOut{x}} &=& x \\
\cptogv{\cpEmptyIn{x}{P}} &=& \cptogv{P} \\
\cptogv{\cpCut{x}{P}{Q}} &=&
  \gvLet{x}{\gvFork{x}{\cptogv{P}}}{\cptogv{Q}} \\
\cptogv{\cpLink{x}{y}} &=& \gvLink{x}{y} \\

\cptogv{\cpSendType{x}{A}{P}} &=&
  \gvLet{x}{\gvSendType{\cptogv{A}}{x}}{\cptogv{P}} \\
\cptogv{\cpReceiveType{x}{X}{P}} &=&
  \gvLet{x}{\gvReceiveType{X}{x}}{\cptogv{P}} \\

%% \end{eqs}%
%% \]%
%% \[
%% \begin{eqs}
\cptogv{\cpServe{s}{x}{P}} &=&
  \gvLink{s}{(\gvServe{x}{\cptogv{P}})} \\
\cptogv{\cpRequest{s}{x}{P}} &=&
  \gvLet{x}{\gvFork{x}{\gvLink{(\gvRequest{s})}{x}}}{\cptogv{P}} \\
\end{eqs}
%\ea
\]
%
As a convenience we use the following syntactic sugar in the translation.
\[
\gvLet{x}{M}{N} \equiv \lampi{(\lambda x.N) M} \equiv \gvSend{M}{(\gvFork{z}{\gvReceiveK{x}{z}{z}{\gvLink{N}{z}}})}
\]


%% This may look surprising, but the $\gvLet{x}{M}{N}$ is commonly used as syntactic sugar for
%% $\gvApp{(\gvLam{x}{N})}{M}$, and the right hand side is identical to
%% $\lampi{\gvApp{(\gvLam{x}{N})}{M}}$ where the translation $\lampi{-}$ is defined in the next
%% section.
%
%% Judgements
%% \begin{equations}
%% \cptogv{\cpj{P}{\G}} = \gvj{\cptogv{\G}}{\cptogv{P}}{\gvEndOutput}
%% \end{equations}
%
The translation on contexts is pointwise.
%% \begin{equations}
%% \cptogv{x_1:A_1, \dots, x_n:A_n} &=& x_1:\cptogv{A_1}, \dots, x_n:\cptogv{A_n} \\
%% \end{equations}%
%It is straightforward to verify that
The translation preserves typing.
\begin{theorem}
If $\cpj{P}{\G}$ then $\gvj{\cptogv{\G}}{\cptogv{P}}{\gvEndOutput}$.
\end{theorem}


\section{Correctness}

If we extend $\hgvcp{-}$ to non-session types, as in Wadler's original presentation, then it is
straightforward to show that this monolithic translation factors through $\lampi{-}$.
\begin{theorem}
\label{th:factor}
$\hgvcp{\lampi{M}}z \Longrightarrow^* \hgvcp{M}z$
\end{theorem}
\noindent
The key soundness property of our translations is that if we translate a term from CP to \hgvpi and
back, then we obtain a term equivalent to the one we started with.
\begin{theorem}
\label{th:soundness}
%% ~
%% \begin{enumerate}
%% \item $\hgvcp{\cptogv{A}} = A$.
%% \item
If $\cpj{P}{\G}$ then $\cpCut{z}{\cpEmptyOut{z}}{\hgvcp{\cptogv{P}}z} \Longrightarrow^* P$.
%%\end{enumerate}
\end{theorem}
\noindent
Together, Theorem~\ref{th:factor}~and~\ref{th:soundness} tell us that \hgv, \hgvpi, and CP are
equally expressive.

%% SL: commented out for space-saving

%% , in the sense that every $X$ program can always be translated to an equivalent
%% $Y$ program, where $X,Y \in \{$\hgv, \hgvpi, CP$\}$.

%% It is interesting also to consider Felleisen's more refined notion of
%% expressivity~\cite{Felleisen91}.  Both $\lampi{-}$ and $\cptogv{-}$ are local translations, thus
%% both \hgv and CP are macro-expressible~\cite{Felleisen91} in \hgvpi. However, the apparent need for
%% CPS in translating from \hgvpi to CP indicates that \hgvpi is not macro-expressible in CP; hence
%% \hgvpi is more expressive (in the Felleisen sense) than CP.
%


%% As we do not give a semantics for \hgv, other than by translation to
%% CP, there is no point in considering the composition of the
%% translations the other way round.



%% Judgements
%% \begin{equations}
%% \hgvcp{\gvj{\Phi}{M}{T}} &=& \cpj{\hgvcp{M}z}{\hgvcp{\Phi}, z:\cpDual{\hgvcp{T}}}
%% \end{equations}



\section{Conclusions and Future Work}

We have proposed a session-typed functional language, \hgv, building on the similar languages of
Wadler and Gay and Vasconcelos. We have shown that \hgv is sufficient to encode arbitrary linear
logic proofs, completing the correspondence between linear logic and session typing. We have also
given an encoding of the non-session fragment of \hgv in terms of its session fragment, simplifying
translation from \hgv to CP.

We highlight several areas of future work.
%% \begin{itemize}
%% \item
The semantics of \hgv is given only by cut elimination in CP. We would like to give \hgv a semantics
directly, in terms of reductions of configurations of processes, and then prove a formal
correspondence with cut elimination in CP.
%% \item
Replication has limited expressive power compared to recursion
%% ; in particular, it cannot
%%   express services whose behavior changes over time or in response to client requests.
  We believe that the study of fixed points in linear logic provides a mechanism to support more
  expressive recursive behavior without sacrificing the logical interpretation of \hgv.
%% \item
 As classical linear logic proofs, and hence CP processes, enjoy confluence, \hgv programs are
  deterministic. We hope to identify natural extensions of \hgv that give rise to non-determinism,
  and thus allow programs to exhibit more interesting concurrent behaviour, while preserving the
  underlying connection to linear logic.
%% \end{itemize}

\label{sect:bib}
\bibliographystyle{plain}
%\bibliographystyle{alpha}
%\bibliographystyle{unsrt}
%\bibliographystyle{abbrv}
\bibliography{cpgv}



\appendix

\section{Omitted typing rules for HGV}\label{sect:hgv-omitted}

\begin{mathpar}
\infr[$\lolli$-I]
{\gvj{\Phi,x:T}{N}{U}}
{\gvj{\Phi}{\gvLam{x}{N}}{\gvLinFun{T}{U}}}

\infr[$\lolli$-E]
{\gvj{\Phi}{L}{\gvLinFun{T}{U}} \\ \gvj{\Psi}{M}{T}}
{\gvj{\Phi,\Psi}{\gvApp{L}{M}}{U}}

\infr[$\to$-I]
{\gvj{\Phi}{L}{\gvLinFun{T}{U}} \\ \un{\Phi}}
{\gvj{\Phi}{L}{\gvUnFun{T}{U}}}

\infr[$\to$-E]
{\gvj{\Phi}{L}{\gvUnFun{T}{U}}}
{\gvj{\Phi}{L}{\gvLinFun{T}{U}}}

\infr[$\otimes$-I]
{\gvj{\Phi}{M}{T} \\ \gvj{\Psi}{N}{U}}
{\gvj{\Phi,\Psi}{\gvPair{M}{N}}{\gvTimes{T}{U}}}

\infr[$\otimes$-E]
{\gvj{\Phi}{M}{\gvTimes{T}{U}} \\ \gvj{\Psi,x:T,y:U}{N}{V}}
{\gvj{\Phi,\Psi}{\gvLet{\gvPair{x}{y}}{M}{N}}{V}}
%%
%% \infr[Unit]
%% { }
%% {\gvj{}{\gvUnit}{\gvUnitType}}
%% \end{mathpar}%
%% \hrule
%% \begin{mathpar}
\end{mathpar}

\section{Typing rules for CP}\label{sect:cp-typing}

\begin{mathpar}
\infr[Ax]
{ }
{\cpj{\cpLink{w}{x}}{w:\cpDual{A},x:A}}

\infr[Cut]
{\cpj{P}{\G,x:A} \\ \cpj{Q}{\D,x:\cpDual{A}}}
{\cpj{\cpCut{x}{P}{Q}}{\G,\D}}

\infr[$\otimes$]
  {\cpj{P}{\G,y:A} \\ \cpj{Q}{\D,x:B}}
  {\cpj{\cpOutput{x}{y}{P}{Q}}{\G,\D,x:\cpTimes{A}{B}}}

\infr[$\bindnasrepma$]
{\cpj{R}{\Theta,y:A,x:B}}
{\cpj{\cpInput{x}{y}{R}}{\Theta,x:\cpPar{A}{B}}}

\infr[$\oplus$]
{\cpj{P}{\G,x:A_i}}
{\cpj{\cpInject{x}{\la_i}{P}}{\G,x:\cpPlus{\la_i:A_i}{i}}}

\infr[$\binampersand$]
{\row{\cpj{Q_i}{\D,x_i:A_i}}{i}}
{\cpj{\cpCase{x}{\row{\la_i.Q_i}{i}}}{\D,x:\cpWith{\la_i:A_i}{i}}}

\infr[$!$]
{\cpj{P}{\cpWhyNot{\G},y:A}}
{\cpj{\cpServe{x}{y}{P}}{\cpWhyNot{\G},x:\cpOfCourse{A}}}

\infr[$?$]
{\cpj{Q}{\D,y:A}}
{\cpj{\cpRequest{x}{y}{Q}}{\D,x:\cpWhyNot{A}}}

\infr[Weaken]
{\cpj{Q}{\D}}
{\cpj{Q}{\D,x:\cpWhyNot{A}}}

\infr[Contract]
{\cpj{Q}{\D,x:\cpWhyNot{A},x':\cpWhyNot{A}}}
{\cpj{\subst{Q}{x}{x'}}{\D,x:\cpWhyNot{A}}}

\infr[$\exists$]
{\cpj{P}{\G,x:\subst{B}{A}{X}}}
{\cpj{\cpSendType{x}{A}{P}}{\G,x:\cpExists{X}{B}}}

\infr[$\forall$]
{\cpj{Q}{\D,x:B} \\ X \notin \D}
{\cpj{\cpReceiveType{x}{X}{Q}}{\D,x:\cpForall{X}{B}}}

\infr[$\cpOne$]
{ }
{\cpj{\cpEmptyOut{x}}{x:\cpOne}}

\infr[$\cpBottom$]
{\cpj{P}{\G}}
{\cpj{\cpEmptyIn{x}{P}}{\G,x:\cpBottom}}
%
%% \infr[$\cpZero$]
%% {\cpj{}{}}
%% {\cpj{}{}}
%%
%% \infr[$\cpTop$]
%% {\cpj{}{}}
%% {\cpj{}{}}
\end{mathpar}



%% \appendix

%% \subsection{GV extensions}

%% \begin{mathpar}
%% \inferrule
%% {\gvj{\Phi}{M}{\gvInputType{X}{S}}}
%% {\gvj{\Phi}{\gvSendType{S}{M}}{S'[S/X]}}

%% \inferrule
%% {\gvj{\Phi}{M}{\gvOutputType{X}{S}} \\ X \notin \FV{\Phi}}
%% {\gvj{\Phi}{\gvReceiveType M}{S'}}
%% \end{mathpar}

%% \begin{mathpar}
%% \inferrule
%% {\gvj{\Phi}{M}{S} \\ \gvj{\Phi}{N}{\gvDual{S}}}
%% {\gvj{\Phi}{\gvLink{M}{N}}{\gvEndOutput}}

%% \inferrule
%% {\gvj{\Phi, s : \gvServer{S}, x : S}{M}{\gvEndOutput}}
%% {\gvj{\Phi}{\gvServeOld{s}{x}{M}}{\gvEndOutput}}

%% \inferrule
%% { }
%% {\gvj{\Phi, s : \gvService{S}}{\gvRequest{s}}{S}}
%% \end{mathpar}


%% \newpage

%% \section{From GV to CP}
%% ~

%% Session types
%% \begin{equations}
%% \gvtocp{\gvOutput{T}{S}}        &=& \cpPar{\cpDual{\gvtocp{T}}}{\gvtocp{S}} \\
%% \gvtocp{\gvInput{T}{S}}         &=& \cpTimes{\gvtocp{T}}{\gvtocp{S}} \\
%% \gvtocp{\gvPlus{\la_i:S_i}{i}}   &=& \cpWith{\la_i:\gvtocp{S_i}}{i} \\
%% \gvtocp{\gvChoice{\la_i:S_i}{i}} &=& \cpPlus{\la_i:\gvtocp{S_i}}{i} \\
%% \gvtocp{\gvEndOutput}              &=& \cpBottom \\
%% \gvtocp{\gvEndInput}               &=& \cpOne \\[1ex]

%% \gvtocp{X}                       &=& X \\
%% \gvtocp{\gvOutputType{X}{S}}     &=& \cpForall{X}{\gvtocp{S}} \\
%% \gvtocp{\gvInputType{X}{S}}      &=& \cpExists{X}{\gvtocp{S}} \\[1ex]

%% \gvtocp{\gvServer{S}}  &=& \cpWhyNot{\gvtocp{S}} \\
%% \gvtocp{\gvService{S}} &=& \cpOfCourse{\gvtocp{S}} \\[1ex]
%% \end{equations}

%% Non-session types
%% \begin{equations}
%% \gvtocp{\gvLinFun{T}{U}} &=& \cpPar{\cpDual{\gvtocp{T}}}{\gvtocp{U}} \\
%% \gvtocp{\gvUnFun{T}{U}} &=& \cpOfCourse{(\cpPar{\cpDual{\gvtocp{T}}}{\gvtocp{U}})} \\
%% \gvtocp{\gvTimes{T}{U}} &=& \cpTimes{\gvtocp{T}}{\gvtocp{U}} \\
%% \gvtocp{\gvUnitType} &=& \cpOfCourse{(\cpWith{}{})} \\
%% \end{equations}

%% Terms
%% \begin{equations}
%% \gvtocp{\gvSendType{S}{(M : \cpForall{X}{S'})}}z &=&
%%   \cpCut{(x:\cpExists{X}{\cpDual{\gvtocp{S'}}})}{\cpSendType{x}{\gvtocp{S}}{\cpLink{x}{z}}}{\gvtocp{M}x} \\
%% \gvtocp{\gvReceiveType{X}{M}}z &=&
%%   \cpCut{(x:\cpForall{X}{\cpDual{\gvtocp{S'}}})}{\cpReceiveType{x}{X}{\cpLink{x}{z}}}{\gvtocp{M}x} \\
%% \\[1ex]
%% \gvtocp{\gvLink{M}{N}}z &=& \cpCut{x}{\gvtocp{M}x}{\cpCut{y}{\gvtocp{N}y}{\cpEmptyIn{z}{\cpLink{x}{y}}}} \\
%% \gvtocp{\gvServeOld{s}{x}{M}}z &=&
%%   \cpEmptyIn{z}
%%             {\cpServe{s}{x}
%%                      {\cpCut{y}{\cpEmptyOut{y}}{\gvtocp{M}y}}} \\
%% \gvtocp{\gvRequest{s}}z &=& \cpRequest{s}{x}{\cpLink{x}{z}} \\
%% \end{equations}

%% Horrible verbose versions of the rules for sending and receiving types
%% \begin{mathpar}
%% \left\llbracket
%%   \inferrule
%%      {\gvj{\Phi}{M}{\gvOutputType{X}{S}}}
%%      {\gvj{\Phi}{\gvSendType{S'}{M}}{\subst{S}{S'}{X}}}
%% \right\rrbracket z =
%%   \inferrule*
%%     {
%%       \inferrule*
%%         {}
%%         {\cpj{\hgvcp{M}x}{\hgvcp{\Phi},x:\cpForall{X}{\cpDual{\hgvcp{S}}}}}
%%       \\
%%       \inferrule*
%%         {\inferrule*
%%            { }
%%            {\cpj{\cpLink{x}{z}}
%%              {\hgvcp{\Phi},x:\hgvcp{\subst{S}{S'}{X}},
%%                            z:\cpDual{\hgvcp{\subst{S}{S'}{X}}}}}}
%%         {\cpj{\cpSendType{x}{\hgvcp{S'}}{\cpLink{x}{z}}}
%%              {\hgvcp{\Phi},x:\cpExists{X}{\hgvcp{S}},
%%                            z:\cpDual{\hgvcp{\subst{S}{S'}{X}}}}}
%%     }
%%     {\cpj{\cpCut{x}{\hgvcp{M}x}{\cpSendType{x}{\hgvcp{S'}}{\cpLink{x}{z}}}}
%%          {\hgvcp{\Phi},z:\cpDual{\hgvcp{\subst{S}{S'}{X}}}}}
%% \\
%% \left\llbracket
%%   \inferrule
%%      {\gvj{\Phi}{M}{\gvInputType{X}{S}} \\ X \notin \FV{\Phi}}
%%      {\gvj{\Phi}{\gvReceiveType{X}{M}}{S}}
%% \right\rrbracket z =
%%   \inferrule*
%%     {\inferrule*
%%        {}
%%        {\cpj{\hgvcp{M}x}{\hgvcp{\Phi},x:\cpExists{X}{\cpDual{\hgvcp{S}}}}}
%%      \\
%%      \inferrule*
%%        {\inferrule*
%%             { }
%%             {\cpj{\cpLink{x}{z}}
%%               {\hgvcp{\Phi},x:\hgvcp{S}
%%                            ,z:\cpDual{\hgvcp{S}}}}
%%         \\ X \notin \FV{\hgvcp{\Phi}}
%%        }
%%        {\cpj{\cpReceiveType{x}{X}{\cpLink{x}{z}}}
%%           {\hgvcp{\Phi},x:\cpForall{X}{\hgvcp{S}}
%%                        ,z:\cpDual{\hgvcp{S}}}}
%%     }
%%     {\cpj{\cpCut{x}{\hgvcp{M}x}{\cpReceiveType{x}{X}{\cpLink{x}{z}}}}
%%          {\hgvcp{\Phi},z:\cpDual{\hgvcp{S}}}} \\
%% \end{mathpar}

%% Judgements
%% \begin{equations}
%% \gvtocp{\gvj{\Phi}{M}{T}} &=& \cpj{\gvtocp{M}z}{\cpDual{\gvtocp{\Phi}}, z:\gvtocp{T}}
%% \end{equations}


%% %% Theorem:

%% %%   [[((A))]] = ~A
%% %%   [[((P |- G))]] = Q |- G, z : bot
%% %%     where nu z.(z[].0|Q) --> P

%% %%   (([[S]])) = ~S
%% %%   (([[Phi |- M : S]] z)) = Phi |- N : end!
%% %%     where
%% %%       nu w.(w[].0|[[N]]w) --> [[M]]z

%% \section{Alternative translations from GV to CP}

%% \subsection{Dualising the interpretation of judgements}

%% It is possible to avoid the dualisation of session types in the type
%% translation by dualising the interpretation of judgements.

%% Judgements
%% \begin{equations}
%% \gvtocps{\gvj{\Phi}{M}{T}} &=& \cpj{\gvtocp{M} z}{\gvtocps{\Phi}, z:\cpDual{(\gvtocps{T})}}
%% \end{equations}

%% Session types
%% \begin{equations}
%% \gvtocps{\gvOutput{T}{S}}        &=& \cpTimes{\cpDual{\gvtocps{T}}}{\gvtocps{S}} \\
%% \gvtocps{\gvInput{T}{S}}         &=& \cpPar{\gvtocps{T}}{\gvtocps{S}} \\
%% \gvtocps{\gvPlus{\la_i:S_i}{i}}   &=& \cpPlus{\la_i:\gvtocps{S_i}}{i} \\
%% \gvtocps{\gvChoice{\la_i:S_i}{i}} &=& \cpWith{\la_i:\gvtocps{S_i}}{i} \\
%% \gvtocps{\gvEndOutput}              &=& \cpOne \\
%% \gvtocps{\gvEndInput}               &=& \cpBottom \\[1ex]

%% \gvtocps{\gvServer{S}}  &=& \cpOfCourse{\gvtocps{S}} \\
%% \gvtocps{\gvService{S}} &=& \cpWhyNot{\gvtocps{S}} \\[1ex]
%% \end{equations}


%% The idea is that the term translation stays exactly the same. This
%% approach fits with the view of $z$ as a negative continuation
%% parameter. It yields a straightforward interpretation of session
%% types, but then the interpretation of non-session types (linear
%% functions, unrestricted functions, tensor, and unit), becomes dual to
%% what one would normally expect.

%% Non-session types
%% \begin{equations}
%% \gvtocps{\gvLinFun{T}{U}} &=& \cpTimes{\gvtocp{T}}{\cpDual{\gvtocp{U}}} \\
%% \gvtocps{\gvUnFun{T}{U}} &=& \cpWhyNot{(\cpTimes{\gvtocp{T}}{\cpDual{\gvtocp{U}}})} \\
%% \gvtocps{\gvTimes{T}{U}} &=& \cpPar{\cpDual{\gvtocp{T}}}{\cpDual{\gvtocp{U}}} \\
%% \gvtocps{\gvUnitType} &=& \cpWhyNot{(\cpPlus{}{})} \\
%% \end{equations}

%% \subsection{Adapting the translation on terms}

%% As an alternative to dualising the interpretation of non-session
%% types, we can attempt to keep the standard interpretation of
%% non-session types and instead adapt the translation on terms.

%% Judgements
%% \begin{equations}
%% \gvtocpd{\gvj{\Phi}{M}{T}} &=& \cpj{\gvtocpd{M} z}{\gvtocpd{\Phi}, z:{\gvtocpd{T}}}
%% \end{equations}

%% This looks like it might work if we add the Mix rule to CP along with
%% another rule which can be derived from BiCut, but which appears to
%% be weaker.

%% \begin{mathpar}
%% \inferrule
%% {\cpj{P}{\G, y:A, z:C} \\ \cpj{Q}{\D, x:B, z:\cpDual{C}}}
%% {\cpj{\cpCutOutput{z}{x}{y}{P}{Q}}{\G, \D, x : \cpTimes{A}{B}}}
%% \end{mathpar}

%% %%   [[
%% %%   Phi |- L : T -o U  un(Phi)
%% %%   --------------------------
%% %%   Phi |- L : T -> U
%% %%   ]] z
%% %% =
%% %%   [[L]]y |- [[Phi]], y:~[[T -o U]]
%% %%   --------------------------------------------
%% %%   ?z[y].[[L]]y |- [[Phi]], z:?(~[[T -o U]])

%% %%   [[
%% %%   Phi |- L : T -> U
%% %%   -----------------
%% %%   Phi |- L : T -o U
%% %%   ]] z
%% %% =
%% %%                                            x <-> z |- x:[[T -o U]], z:~([[T -o U]])
%% %%                                         ---------------------------------------------------
%% %%   [[L]]y |- [[Phi]], y:?(~[[T -o U]])   !y(x).x <-> z |- y:!([[T -o U]]), z:~([[T -o U]])
%% %%   ------------------------------------------------------------------------------------------
%% %%   nu y.([[L]]y | !y(x).x <-> z) |- [[Phi]], z:~[[T -o U]]
%% %%
%% %% Oops! z can't appear inside the server output!


%% %% z : [[T]] * ~[[U]]
%% %% [[\x.M]]z = nu y.z[x].([[M]]y | y <-> z)
%% %% [[\x.M]]z = nu y x.([[M]]y | z[w].(w <-> x | y <-> z))

%% %% z : ~[[U]]
%% %% [[L M]]z = nu y.([[L]]y | y(x).([[M]]x | y <-> z))

%% %% z : ~[[T]] || ~[[U]]
%% %% [[(M, N)]]z = z(x).([[M]]x | [[N]]z)

%% %% z : ~[[V]]
%% %% [[let (x,y)=M in N]]z = nu w.([[M]]w | nu y.w[x].([[N]]z | w <-> y))

%% %% Cutting an output with a private channel against an input with a
%% %% mix would appear to yield a term containing a plain bicut and a mix

%% %%    nu x.(x[y].nu z.(P | Q) | x(y).(R | S))
%% %%  -->
%% %%    nu y z.(P | nu x.(Q | (R | S)))


%% Non-session terms
%% \begin{equations}
%% \gvtocpd{\lambda x:T.M}z &=&
%%   \cpCutOutput{y:{\cpDual{\gvtocpd{U}}}}{z}{x:{\gvtocpd{T}}}
%%               {\gvtocpd{M}y}{\cpLink{y}{z}} \\
%% \gvtocpd{L~M}z &=&
%%   \cpCut{y:\cpTimes{\gvtocpd{T}}{\cpDual{\gvtocpd{U}}}}
%%         {\gvtocpd{L}y}
%%         {\cpInput{y}{x:\cpDual{\gvtocpd{U}}}{\cpMix{\gvtocpd{M}x}{\cpLink{y}{z}}}} \\
%% \gvtocpd{\gvPair{M}{N}}z &=&
%%   \cpInput{z}{x:\cpDual{\gvtocpd{T}}}{\cpMix{\gvtocpd{M}x}{\gvtocpd{N}z}} \\
%% \gvtocpd{\gvLet{\gvPair{x}{y}}{M}{N}}z &=&
%%   \cpCut{w:\cpPar{\cpDual{\gvtocpd{T}}}{\cpDual{\gvtocpd{U}}}}
%%     {\gvtocpd{M}w}
%%     {\cpCutOutput{y:\gvtocpd{U}}{w}{x:\gvtocpd{T}}{\gvtocpd{N}z}{\cpLink{w}{y}}} \\
%% \end{equations}

%% Where this approach seems to completely break down is in the
%% translation of the elimination rule for unrestricted functions. We
%% might reasonably hope to simulate linear lambdas using output rather
%% than input, but it seems unreasonable to expect to simulate
%% unrestricted lambda application using a linear server rather than an
%% unrestricted client.

%% \subsection{Compiling away non-session types}

%% Another option is to compile away non-session types in GV as a
%% pre-processing step, where the type translation is given by
%% $\cptogv{\gvtocp{-}}$ and the term translation by
%% $\cptogv{\gvtocp{-}z}$.

%% %% T -o U --> ~[[T]] || [[U]] --> ?~T*.U*
%% %% T -> U --> !(~[[T]] || [[U]]) --> $(?~T*.U*)
%% %% T * U --> [[T]] * [[U]] --> !~T*.U*
%% %% Unit --> !&{} --> $&{}

%% %% Hmmm... Looks like things are the wrong way round in the GV to CP
%% %% translation: input types should be negated and output types
%% %% should't.

%% We could simply compose the translations as described, but then it
%% would seem that we would have to perform a global CPS transformation
%% on all terms including the session typing constructs. This would be
%% rather disappointing, as then we would appear to have to effectively
%% perform a CPS transformation twice on such terms in order to generate
%% a CP term.

%% % channel passing translation
%% \newcommand{\gvtogv}[1]{({#1})^\star}

%% We can do better, though, by performing a local transformation. The
%% key observation is that we can locally abstract over the continuation
%% channel $z$ in a term $M$ using $\gvWith{z}{M}{z}$.

%% This is where the dualisation of types arises: the type of the whole
%% expression must be dual to the type of $z$ in $M$. For instance, we
%% implement a lambda of type $\gvLinFun{T}{U}$ with a channel $z$ of
%% type $\gvInput{\gvDual{\gvtogv{T}}}{\gvtogv{U}}$, but the interface to
%% the lambda is the other end of the channel $z$ which has type
%% $\gvOutput{\gvtogv{T}}{\gvDual{\gvtogv{U}}}$ (and application becomes
%% simply sending the argument along this channel).

%% \begin{equations}
%% \gvtogv{\gvLinFun{T}{U}} &=& \gvOutput{\gvtogv{T}}{\gvDual{\gvtogv{U}}} \\
%% \gvtogv{\gvUnFun{T}{U}} &=& \gvService{(\gvOutput{\gvtogv{T}}{\gvDual{\gvtogv{U}}})} \\
%% \gvtogv{\gvTimes{T}{U}} &=& \gvInput{\gvtogv{T}}{\gvDual{\gvtogv{U}}} \\
%% \gvtogv{\gvUnitType} &=& \gvService{(\gvPlus{}{})} \\
%% \end{equations}%

%% \begin{equations}
%% \gvtogv{\gvj{\Phi}{M}{T}} &=& \gvj{\gvtogv{\Phi}}{\gvtogv{M}}{\gvtogv{T}} \\
%% \end{equations}%

%% \begin{equations}
%% \gvtogv{\gvLam{x}{M}} &=& \gvWith{z}{\gvLet{\gvPair{x}{z}}{\gvReceive{z}}{\gvLink{\gvtogv{M}}{z}}}{z} \\
%% \gvtogv{\gvApp{L}{M}} &=& \gvSend{\gvtogv{M}}{\gvtogv{L}} \\
%% \gvtogv{\gvTimes{M}{N}} &=&
%%   \gvWith{z}
%%     {\gvLink{(\gvSend{\gvtogv{M}}{z})}{\gvtogv{N}}}
%%     {z} \\
%% \gvtogv{\gvLet{\gvPair{x}{y}}{M}{N}} &=&
%%     \gvLet{\gvPair{x}{y}}{\gvReceive{\gvtogv{M}}}{\gvtogv{N}} \\
%% \gvtogv{\gvReceive{M}} &=& M \\
%% \gvtogv{\gvUnit} &=&
%%     \gvWith{z}
%%     {\gvServeOld{z}{x}{\gvCase{x}{\row{}{}}}}
%%     {z} \\
%% %% Unnecessary as we don't have a linear unit!
%% %%
%% %% \gvtogv{\gvLet{\gvUnit}{M}{N}} &=&
%% %%   \gvLet{z}{\gvtogv{M}}{\gvtogv{N}} \\
%% \gvtogv{L : \gvUnFun{T}{U}} &=&
%%   \gvWith{z}{\gvServeOld{z}{y}{\gvLink{\gvtogv{L}}{y}}}{z} \\
%% \gvtogv{L : \gvLinFun{T}{U}} &=& \gvRequest{\gvtogv{L}} \\
%% \end{equations}

%% A problem we run into is that $\gvReceive{M}$ has tensor type, and yet
%% our translation is supposed to compile away non-session types,
%% including tensors. Similarly, $\gvTerminate{M}$ has unit type. The
%% problem illustrates an irregularity in GV. All of the typing rules for
%% the other session typing constructs mention only session types.

%% Dealing with $\key{terminate}$ is easy. We just amend our target
%% language such that $\gvTerminate{M}$ has type
%% $\gvService{(\gvPlus{}{})}$, the interpretation of the unit type.
%% %
%% Dealing with $\key{receive}$ is a little harder. We still need some
%% way of binding the two values returned by $\key{receive}$. The
%% solution is to fuse $\key{receive}$ with the pair elimination
%% construct. Notice that this is more or less what CP server input does
%% already. Because we interpret $\gvTimes{T}{U}$ as
%% $\gvInput{\gvtogv{T}}{\gvDual{\gvtogv{U}}}$, instances of
%% $\key{receive}$ from the source term are all erased. The only
%% instances of $\key{receive}$ in the target term arise from
%% interpreting lambdas and pair elimination. This may seem strange until
%% one considers that the only way to use the pair resulting from a
%% $\key{receive}$ in GV is to eliminate it. The transformation shunts
%% each receive up to the point at which the resulting pair is
%% eliminated.

%% \begin{mathpar}
%% \inferrule
%%   {\gvj{\Phi}{M}{\gvEndInput}}
%%   {\gvj{\Phi}{\gvTerminate{M}}{\gvService{(\gvPlus{}{})}}}

%% \inferrule
%%   {\gvj{\Phi}{M}{\gvInput{T}{S}} \\ \gvj{\Psi, x:T, y:S}{N}{U}}
%%   {\gvj{\Phi, \Psi}{\gvLet{\gvPair{x}{y}}{\gvReceive{M}}{N}}{U}}
%% \end{mathpar}

%% Another alternative is to get rid of terminate altogether and change
%% $\gvEndInput$ to be an unrestricted session type. Correspondingly, we
%% could also interpret the unit type as $\gvEndInput$ and $\gvUnit$ as
%% $\gvWith{x}{x}{x}$. Making $\gvEndInput$ unrestricted makes sense as
%% $\gvEndInput = \cptogv{\cpBottom}$, and weakening and contraction are
%% derivable for $\cpBottom$ in CP.

%------------------------------------------------------------------------------
%%

%------------------------------------------------------------------------------
% Index
%\printindex

%------------------------------------------------------------------------------
\end{document}

Composing the translations

(([[T -o U]])) = ?~(([[T]])).(([[U]]))
(([[T * U]])) = !(([[T]])).(([[U]]))




\x.M --> ((z(x).[[M]]z))  --> let (x,z)=receive z in (([[M]]z))
[[L M]]z --> nu y.([[L]]y | y[x].([[M]]x | y <-> z)) -->
       with y connect
         (([[L]]y))
       to
         with x connect
           (([[M]]x))
         to
           let y=send x y in link y z
(M,N) --> z[y].([[M]]y | [[N]]z) --> with y connect (([[M]]y)) to let z = send y z in (([[N]]z))
let (x, y) = M in N
   --> nu y.([[M]]y | y(x).[[N]]z)
   --> with y connect
         (([[M]]y))
       to
         let (x, y) = receive y in (([[N]]z))

Phi |- L : T -o U  un(Phi)
--------------------------
Phi |- L : T -> U
  --> !z(y).[[L]]y
  --> serve z(y) = (([[L]]y))

Phi |- L : T -> U
-----------------
Phi |- L : T -o U
  --> nu y.([[L]]y | ?y[x].x <-> z)
  --> with y connect
        (([[L]]z))
      to
        with x connect link (request y) x to link x z
  ==
     with y connect
       (([[L]]z))
     to
       link (request y) z

A problem is that we appear to have to CPS transform everything
globally - including the session typing constructs. For instance:

send M N --> nu x.(x[y].([[M]]y | x <-> z) | [[N]]x)
         --> with x connect
               with y connect
                 (([[M]]y))
               to
                 let x = send y x in link x z
             to
               (([[N]]))x

send (\v.v) w -->
    with x connect
      with y connect
        let (v,y) = receive y in link v y
      to
        let x = send y x in link x z
    to
      link w x
  ==
    with y connect
      let (v,y) = receive y in link v y
    to
      let w = send y w in link w z

If we do this as a pre-processing step, then we effectively end up
doing a CPS transformation twice! Can we do some kind of local CPS
transformation:

send (\v.v) w -->
    with y connect
      let (v,y) = receive y in link v y
    to
      send y w
  ==
    send
      (with y connect
        let (v,y) = receive y in link v y
       to
         y)
    w


let syntactic sugar after translating away lambdas:

  let x = M in N
  ==
  send M (with z connect let (x,z)=receive z in link N z to z)



Attempting to undualise the GV to CP translation on types

[[T -o U]] = [[~T || U]]

z : [[T]] * ~[[U]]
[[\x.N]]z = nu y:[[U]].z[x].([[N]]y|y <-> z)



P |- x : A, y : B
----------------------------------------------------
y[x].(P | nu r s.(r <-> x | s <-> y))) |- y : A * B


P |- x : A, x : C     Q |- x : ~C, y : B
----------------------------------------
     nu x.y[z].(P | Q) |- y : A * B

z : ~[[U]]
[[L M]]z = nu y.([[L]]y | y(x).([[M]]x | y <-> z))



y(x).x().y <->z  |- y : bot || 1, z:bot

y(x).y <->z  |- y : 1 || 1, z:bot


[[L]]y |- [[Phi]],y:[[T]]*~[[U]]   ? |- [[Psi]],y:~[[T]] || [[U]],z:~[[U]]
--------------------------------------------------------------------------
? |- [[Phi]],[[Psi]],z:~[[U]]



P |- G,x:~A

? |- G,x:~A,y:B,z:~B
----------------------------------
y(x).? |- y:~A || B,z:~B

z : ~[[T]] || ~[[U]]
[[(M, N)]]z = z(x).([[M]]x || [[N]]z)


x(y).x(z).x().y <-> z |- x:1||(bot || bot)



nu y1 : !top * !top . (foo <-> y1 |  y1(x2).!z0(y3).y3.case(){}) |- foo : ~(!top * !top),z0:!top


  foo : ?#+{}.#+{}, z0 : $&{}
|-
  with y1 : !#+{}.$&{}
  connect
    link foo y1
  to
    let (x2, y1)=receive y1 in serve z0 (y3)=case y3 of {}
: end!


((!top*!top)) = !~((!top)).((!top)) = !#+{}.$&{}

foo : ?#+{}.#+{}, z0 : $&{} |- with y1 : !#+{}.$&{} connect link foo y1 to let (x2, y1)=receive y1 in serve z0 (y3)=case y3 of {} : end!

New version of terminate:

[[terminate M]](z : !top) = nu (x:1).([[M]]x|x().!z(y).y.case())

Let unit:

[[ let () = m in n ]]z = [[ (\().n)m ]] z
  = nu y.(y(x).[[n]]y | y[x].([[m]]x | y <-> z))
  = nu x.(nu y.([[n]]y | y <-> z) | [[m]]x)
  = nu x.([[m]]x | [[n]]z)

Rules for sendType and receiveType

G |- M : ??X.S'
---------------------------
G |- sendType S M : S'[S/X]

G |- M : !!X.S'   X notin FV(G)
-------------------------------
G |- receiveType M : S'

[[sendType S M]](z : S'[S/X]) = nu (x:exists X.[[S']]).(x[S].x <-> z | [[M]]x)
[[receiveType M]](z : S')     = nu.(x:forall X.[[S']]).(x(X).x <-> z | [[M]]x)


%% Each type $T$ is classified as either linear ($\lin{T}$) or unlimited
%% ($\un{T}$).
%% \[
%% \begin{array}{l}
%% \lin{\gvOutput{T}{S}}  \quad \lin{\gvInput{T}{S}} \quad
%% \lin{\gvPlus{\la_i:S_i}{i}} \quad \lin{\gvChoice{\la_i:S_i}{i}} \quad
%% \lin{\gvEndOutput} \quad \un{\gvEndInput} \\
%% \lin{X} \quad
%% \lin{\gvOutputType{X}{S}} \quad \lin{\gvInputType{X}{S}} \quad
%% \lin{\gvServer{S}} \quad \un{\gvService{S}} \\
%% \lin{\gvTimes{T}{U}} \quad \lin{\gvLinFun{T}{U}} \quad \un{\gvUnFun{T}{U}}
%% \end{array}
%% \]
%% The only unlimited type constructors are those for end input,
%% services, and unlimited functions.

%% Apart from the extensions, the two differences in the types of GV are
%% that there is no unit type (called $\gvUnitType$ in GV), and
%% $\gvEndInput$ is unlimited. We omit unit because it is isomorphic to
%% both $\gvEndInput$ and $\gvService{(\gvPlus{}{})}$.

%% TODO: fork vs with

%% The terms and typing rules for \hgv are given in
%% Figure~\ref{fig:hgv-typing}. The first three rules are structural. The
%% next six rules cover the non-session fragment of \hgv. The remaining
%% rules cover the session fragment of \hgv.

%% Notice that the non-session and session fragments are orthogonal, in
%% that the non-session rules mention only non-session type constructors,
%% and the session rules mention only session type constructors. This is
%% a useful property which does not hold of the original GV. As we shall
%% see, it enables us to compile away the non-session fragment into the
%% session fragment.

%% Vanilla GV, has session constructs $\key{receive}$ and
%% $\key{terminate}$, both of whose typing rules mention non-session
%% types.
%% \begin{mathpar}
%% \inferrule[Receive-$\otimes$]
%% {\gvj{\Phi}{M}{\gvInput{T}{S}}}
%% {\gvj{\Phi}{\gvReceive{M}}{\gvTimes{T}{S}}}

%% \inferrule[Terminate-$\otimes$]
%% {\gvj{\Phi}{M}{\gvTimes{T}{\gvEndInput}}}
%% {\gvj{\Phi}{\gvTerminate{M}}{T}}
%% \end{mathpar}
%% \hgv dispenses with $\key{terminate}$ by making $\gvEndOutput$
%% unlimited, and builds a pair binding into $\key{receive}$, thus
%% immediately eliminating the tensor.

%% The final five typing rules of Figure~\ref{fig:hgv-typing} extend the
%% functionality of \hgv with respect to GV: $\gvLink{M}{N}$ links
%% channel $M$ to channel $N$, $\gvSendType{S}{M}$ sends session type $S$
%% along $M$, $\gvReceiveType{M}$ receives a type along $M$,
%% $\gvServe{x}{M}$ defines a server as $M$ parameterised by channel $x$,
%% and $\gvRequest{M}$ requests a fresh instance of service $M$.
%% %

%% We argue that each of the five new constructs adds expressive power to
%% GV.
%% %
%% It seems clear that the ability to send and receive types adds
%% expressive power.
%% %
%% One can straightforwardly simulate $\gvLink{M}{N}$ in terms of other
%% constructs for monomorphic types, but not for polymorphic types.
%% %
%% There are parallels between servers and unlimited functions. One might
%% expect to be able to simulate the former in terms of the latter --- a
%% server is much like an unlimited function parameterised by a
%% channel. A key difference is that functions are not session types, so
%% cannot appear everywhere that a server type can.
%% %% Maybe not...
%% %%
%% %% We believe that servers can be simulated by unlimited functions,
%% %% but only if one performs a global translation.
%% %
%% %% A key difference is that we can disassociate a server declaration
%% %% ($\gvWith{s}{\dots}{\dots}$) from its definition
%% %% ($\gvServeOld{s}{x}{\dots}$). Thus, servers support a very limited
%% %% form of linear dynamic binding, which functions do not. We believe
%% %% that servers can be simulated by unlimited functions, but only if one
%% %% performs a global translation similar to closure conversion.
%% %
%% %% In fact, we will be more interested in going the other way,
%% %% translating away functions as sessions.
